[
  {
    "id": "b2_ch1",
    "title": "ç¬¬1ç« ï¼šæ³¢å‹•æ€§",
    "number": 1,
    "content": {
      "intro": "# ç¬¬ 1 ç« ï¼šæ³¢å‹•æ€§ - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   1.1 å›žå ±çŽ‡ (Returns) çš„æ ¸å¿ƒè¨ˆç®—\n*   1.2 æ­·å²æ³¢å‹•æ€§ (Historical Volatility) çš„çµ±è¨ˆåŸºç¤Ž\n*   1.3 ç§»å‹•å¹³å‡ (MA) èˆ‡æŒ‡æ•¸åŠ æ¬Šç§»å‹•å¹³å‡ (EWMA)\n*   4.4 è‡ªå›žæ­¸æ¢ä»¶ç•°æ–¹å·®æ¨¡åž‹ (ARCH)\n*   1.5 å»£ç¾©è‡ªå›žæ­¸æ¢ä»¶ç•°æ–¹å·®æ¨¡åž‹ (GARCH)\n*   1.6 æ³¢å‹•æ€§ä¼°è¨ˆã€é æ¸¬èˆ‡æ¨¡åž‹è©•ä¼°\n*   1.7 éš±å«æ³¢å‹•æ€§ (Implied Volatility) èˆ‡æ³¢å‹•çŽ‡å¾®ç¬‘\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\næ³¢å‹•æ€§ï¼ˆVolatilityï¼‰æ˜¯é‡‘èžé¢¨éšªç®¡ç†ä¸­æœ€åŸºç¤Žä¹Ÿæœ€é‡è¦çš„æŒ‡æ¨™ã€‚æœ¬ç« è©³ç´°æŽ¢è¨Žäº†å¾žç°¡å–®çš„å›žå ±çŽ‡è¨ˆç®—åˆ°è¤‡é›œçš„éš¨æ©Ÿæ³¢å‹•æ¨¡åž‹ï¼ˆARCH/GARCHï¼‰ï¼Œä¸¦å¯¦ä½œäº†æœŸæ¬Šå¸‚å ´ä¸­è‡³é—œé‡è¦çš„éš±å«æ³¢å‹•çŽ‡è¨ˆç®—ã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   æŽŒæ¡å°æ•¸æ”¶ç›ŠçŽ‡ï¼ˆLog Returnsï¼‰çš„å„ªå‹¢èˆ‡æ•¸å­¸æŽ¨å°Žã€‚\n*   ç†è§£æ³¢å‹•æ€§èšé›†ï¼ˆClusteringï¼‰ç¾è±¡ä¸¦ä½¿ç”¨ GARCH æ¨¡åž‹å»ºæ¨¡ã€‚\n*   å­¸æœƒå¾ž BS æ¨¡åž‹ä¸­åæŽ¨éš±å«æ³¢å‹•çŽ‡ï¼Œä¸¦è§€å¯Ÿå¸‚å ´æƒ…ç·’ã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šè¨ˆç®—é¢¨éšªå€¼ï¼ˆVaRï¼‰æ™‚ï¼Œæº–ç¢ºçš„æ³¢å‹•çŽ‡è¼¸å…¥æ˜¯æ¨¡åž‹æˆæ•—çš„é—œéµã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šç†è§£ç‚ºä»€éº¼æ–¹å·®éš¨æ™‚é–“è®ŠåŒ–ï¼ˆTime-varying Varianceï¼‰åœ¨é‡‘èžæ™‚é–“åºåˆ—ä¸­æ˜¯å¸¸æ…‹ã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch1_1.py** | å¯¦ä½œæ™‚é–“åºåˆ—ä½ç§»èˆ‡æ”¶ç›ŠçŽ‡è¨ˆç®—ï¼Œæ¶µè“‹æ•¸æ“šæ“·å–ã€‚ |\n| **B2_Ch1_2.py** | å¤šè³‡ç”¢æ”¶ç›ŠçŽ‡è¦–è¦ºåŒ–å°æ¯”èˆ‡ç™¾åˆ†æ¯”è®ŠåŒ–åˆ†æžã€‚ |\n| **B2_Ch1_3.py** | æ³¢å‹•çŽ‡ï¼ˆæ¨™æº–å·®ï¼‰å‹•æ…‹è¨ˆç®—èˆ‡åœ–è¡¨å‘ˆç¾ã€‚ |\n| **B2_Ch1_4.py** | æ·±å…¥åˆ†æžæ­·å²æ³¢å‹•çŽ‡çš„æ™‚é–“åºåˆ—ç‰¹å¾µã€‚ |\n| **B2_Ch1_5.py** | æ¼”ç¤ºé‡‘èžæ•¸æ“šçš„å¤šç¶­è¦–è¦ºåŒ–ä½ˆå±€ã€‚ |\n| **B2_Ch1_6.py** | æ”¶ç›ŠçŽ‡åˆ†ä½ˆç‰¹å¾µèˆ‡çµ±è¨ˆç¹ªåœ–å¯¦ä½œã€‚ |\n| **B2_Ch1_7.py** | **[æ ¸å¿ƒ]** ARCH/GARCH æ¨¡åž‹é…é©èˆ‡æ³¢å‹•çŽ‡é æ¸¬ã€‚ |\n| **B2_Ch1_8.py** | æœŸæ¬Šå¸Œè‡˜å­—æ¯ Delta çš„åŸºç¤Žè¨ˆç®—èˆ‡è¦–è¦ºåŒ–ã€‚ |\n| **B2_Ch1_9.py** | **[æ ¸å¿ƒ]** å¯¦ä½œ Black-Scholes Formula èˆ‡ IV æ±‚è§£ç®—ä¾‹ã€‚ |\n| **B2_Ch1_10.py** | æœŸæ¬Šéˆæ•¸æ“šåˆ†æžèˆ‡éš±å«æ³¢å‹•çŽ‡æ›²é¢åˆæ­¥ã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 1.1 å›žå ±çŽ‡ (Returns)\nåœ¨é¢¨éšªç®¡ç†ä¸­ï¼Œæˆ‘å€‘é€šå¸¸å„ªå…ˆä½¿ç”¨**å°æ•¸æ”¶ç›ŠçŽ‡** ($r_t = \\ln(P_t/P_{t-1})$)ï¼Œå› ç‚ºï¼š\n1.  **å¯åŠ æ€§**ï¼šå¤šæœŸå°æ•¸æ”¶ç›ŠçŽ‡ä¹‹å’Œç­‰æ–¼ç¸½æ”¶ç›ŠçŽ‡ã€‚\n2.  **å¸¸æ…‹åˆ†ä½ˆå‡è¨­æ›´åˆç†**ï¼šè³‡ç”¢åƒ¹æ ¼æœ¬èº«ä¸ç‚ºè² æ•¸ï¼Œå°æ•¸æ”¶ç›ŠçŽ‡å‡è¨­åƒ¹æ ¼æœå¾žå°æ•¸å¸¸æ…‹åˆ†ä½ˆã€‚\n\n### 1.4-1.5 ARCH èˆ‡ GARCH æ¨¡åž‹\né‡‘èžæ™‚é–“åºåˆ—å¾€å¾€å­˜åœ¨ã€Œæ¢ä»¶ç•°æ–¹å·®æ€§ã€ã€‚GARCH(1,1) æ–¹ç¨‹å®šç¾©ç‚ºï¼š\n$$\\sigma_t^2 = \\omega + \\alpha \\epsilon_{t-1}^2 + \\beta \\sigma_{t-1}^2$$\nå…¶ä¸­ $\\alpha$ åæ˜ äº†è¡æ“Šçš„æŒä¹…æ€§ï¼Œ$\\beta$ åæ˜ äº†æ³¢å‹•çŽ‡çš„è‡ªç›¸é—œæ€§ã€‚å¦‚æžœ $\\alpha + \\beta$ æŽ¥è¿‘ 1ï¼Œè¡¨ç¤ºæ³¢å‹•çŽ‡è¡æ“Šå…·æœ‰å¾ˆé•·çš„æŒä¹…æ€§ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\n### ðŸ“„ B2_Ch1_1.py - æ•¸æ“šæ“·å–èˆ‡æ”¶ç›ŠçŽ‡åŸºç¤Ž\n- **å¯¦ä½œé‡é»ž**ï¼šä½¿ç”¨ `pandas_datareader` æŠ“å– Yahoo Finance æ•¸æ“šï¼Œç¢ºä¿é¢¨éšªåº¦é‡çš„ä¸€è‡´æ€§ï¼Œä¸¦è€ƒæ…®æ¥µç«¯å¸‚å ´æƒ…æ³ä¸‹çš„æ•¸æ“šå®Œæ•´æ€§ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šå°æ•¸æ”¶ç›ŠçŽ‡ã€æ™‚é–“åºåˆ—ä½ç§» (Shift)ã€‚\n\n### ðŸ“„ B2_Ch1_7.py - GARCH æ¨¡åž‹å»ºæ¨¡\n- **å¯¦ä½œé‡é»ž**ï¼šä½¿ç”¨ `arch` å¥—ä»¶é€²è¡Œæ¨¡åž‹é…é©ï¼Œæ·»åŠ é©ç•¶çš„éŒ¯èª¤è™•ç†æ©Ÿåˆ¶ï¼Œä¸¦ä½¿ç”¨è¨»é‡‹èªªæ˜Žé—œéµè¨ˆç®—æ­¥é©Ÿï¼ˆå¦‚åƒæ•¸åˆå€¼è¨­å®šï¼‰ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šæ³¢å‹•æ€§èšé›†ã€æŒä¹…æ€§ (Persistence)ã€åƒæ•¸ä¼°è¨ˆã€‚\n\n### ðŸ“„ B2_Ch1_9.py & B2_Ch1_10.py - æœŸæ¬Šå®šåƒ¹èˆ‡ IV\n- **ä¸»è¦å‡½æ•¸**ï¼š`option_price_BS()`, `implied_vol()`, `compute_implied_volatility()`\n- **å¯¦ä½œé‡é»ž**ï¼šæ³¨æ„æ•¸å€¼è¨ˆç®—çš„ç²¾åº¦å•é¡Œï¼Œç‰¹åˆ¥æ˜¯åœ¨ $\\sigma$ æŽ¥è¿‘é›¶æˆ–æ¨™çš„åƒ¹æ ¼èˆ‡è¡Œæ¬Šåƒ¹å·®è·éŽå¤§æ™‚çš„æ•¸å€¼ç©©å®šæ€§ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šéš±å«æ³¢å‹•æ€§ã€Black-Scholes æ¨¡åž‹ã€ç‰›é “æ³•æ±‚è§£ã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- æ³¢å‹•æ€§ä¸ç­‰æ–¼é¢¨éšªï¼Œä½†å®ƒæ˜¯é¢¨éšªåº¦é‡çš„æ ¸å¿ƒè®Šæ•¸ã€‚\n- éœæ…‹æ³¢å‹•çŽ‡å‡è¨­ï¼ˆå¦‚åŸºç¤Ž BS æ¨¡åž‹ï¼‰åœ¨ç¾å¯¦ä¸­å¾€å¾€å¤±æ•ˆï¼Œå› æ­¤éœ€è¦å‹•æ…‹æ¨¡åž‹ï¼ˆGARCHï¼‰æˆ–å¸‚å ´é æœŸï¼ˆIVï¼‰ã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 2 ç« éš¨æ©ŸéŽç¨‹ï¼ˆGBM çš„æ³¢å‹•é …ï¼‰ã€ç¬¬ 8 ç« å¸‚å ´é¢¨éšªï¼ˆVaR æ³¢å‹•çŽ‡è¼¸å…¥ï¼‰ã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Engle (1982), Bollerslev (1986)* åŽŸå§‹è«–æ–‡ã€‚\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch1*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "1.1 B2_Ch1_1.py",
        "filename": "B2_Ch1_1.py",
        "code": "# B2_Ch1_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch1_1_A.py\nimport numpy as np\nimport pandas_datareader \n\nticker = 'AMZN'\nstock = pandas_datareader.data.DataReader(ticker, data_source='yahoo', start='12-21-2020', end='12-28-2020')['Adj Close']\nprint(stock)\n\n# B2_Ch1_1_B.py\n# via formula\nreturns_daily = (stock / stock.shift(1)) - 1\nprint(returns_daily)\n\n# B2_Ch1_1_C.py\n# alternative via pct_change() function\nreturns_daily = stock.pct_change()\nprint(returns_daily)\n\n# B2_Ch1_1_D.py\n# log return\nlog_return_daily = np.log(stock / stock.shift(1))\nprint(log_return_daily)"
      },
      {
        "id": "ex2",
        "title": "1.2 B2_Ch1_2.py",
        "filename": "B2_Ch1_2.py",
        "code": "# B2_Ch1_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch1_2_A.py\nimport pandas_datareader \nimport matplotlib.pyplot as plt\n\n# sp500 price\nsp500 = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2010', end='12-28-2020')\n# plot sp500 price\nplt.plot(sp500['sp500'], color='dodgerblue')\nplt.title('S&P 500 price')\nplt.xlabel('Date')\nplt.ylabel('Price')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n# B2_Ch1_2_B.py\n# daily return\nsp500['return_daily'] = sp500['sp500'].pct_change()\nsp500.dropna(inplace=True)\n# plot daily return\nplt.plot(sp500['return_daily'], color='dodgerblue')\nplt.title('S&P 500 daily returns')\nplt.xlabel('Date')\nplt.ylabel('Daily return')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n# B2_Ch1_2_C.py\n# monthly return\nsp500_monthly_returns = sp500['sp500'].resample('M').ffill().pct_change()\n# plot monthly return\nplt.plot(sp500_monthly_returns, color='dodgerblue')\nplt.title('S&P 500 monthly returns')\nplt.xlabel('Date')\nplt.ylabel('Monthly return')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n# B2_Ch1_2_D.py\n# daily cumulative return\nsp500_cum_returns_daily = (sp500['return_daily'] + 1).cumprod()\n# plot daily cumulative return\nplt.plot(sp500_cum_returns_daily, color='dodgerblue')\nplt.title('S&P 500 daily cumulative returns')\nplt.xlabel('Date')\nplt.ylabel('Cumulative return')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n# B2_Ch1_2_E.py\n# monthly cumulative return\nsp500_cum_returns_monthly = (sp500_monthly_returns + 1).cumprod()\n# plot monthly cumulative return\nplt.plot(sp500_cum_returns_monthly, color='dodgerblue')\nplt.title('S&P 500 daily cumulative returns')\nplt.xlabel('Date')\nplt.ylabel('Cumulative return')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex3",
        "title": "1.3 B2_Ch1_3.py",
        "filename": "B2_Ch1_3.py",
        "code": "# B2_Ch1_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib as mpl\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas_datareader\n \n# sp500 price\nsp500 = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2019', end='12-28-2020')\n\n# daily log return\nlog_return_daily = np.log(sp500 / sp500.shift(1))\nlog_return_daily.dropna(inplace=True)\n     \n# calculate daily standard deviation of returns\ndaily_std = np.std(log_return_daily)[0]\n \n# annualize daily standard deviation\nstd = daily_std * 252 ** 0.5\n \n# Plot histograms\nmpl.style.use('ggplot')\nfig, ax = plt.subplots(1, 1, figsize=(10, 6))\nn, bins, patches = ax.hist(\n    log_return_daily['sp500'],\n    bins='auto', alpha=0.7, color='dodgerblue', rwidth=0.85)\n\nax.set_xlabel('Log return')\nax.set_ylabel('Frequency of log return')\nax.set_title('Historical volatility for SP500')\n \n# get x and y coordinate limits\nx_corr = ax.get_xlim()\ny_corr = ax.get_ylim()\n \n# make room for text\nheader = y_corr[1] / 5\ny_corr = (y_corr[0], y_corr[1] + header)\nax.set_ylim(y_corr[0], y_corr[1])\n\n# print historical volatility on plot\nx = x_corr[0] + (x_corr[1] - x_corr[0]) / 30\ny = y_corr[1] - (y_corr[1] - y_corr[0]) / 15\nax.text(x, y , 'Annualized volatility: ' + str(np.round(std*100, 1))+'%',\n    fontsize=11, fontweight='bold')\nx = x_corr[0] + (x_corr[1] - x_corr[0]) / 15\ny -= (y_corr[1] - y_corr[0]) / 20\n\nfig.tight_layout()"
      },
      {
        "id": "ex4",
        "title": "1.4 B2_Ch1_4.py",
        "filename": "B2_Ch1_4.py",
        "code": "# B2_Ch1_4.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport pandas_datareader\nimport matplotlib.pyplot as plt \n\n# sp500 price\ndf = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2010', end='12-28-2020')\ndf.dropna(inplace=True)\n\n# daily log return\ndf['Daily return squared'] = np.log(df['sp500'] / df['sp500'].shift(1))*np.log(df['sp500'] / df['sp500'].shift(1))\ndf.dropna(inplace=True)\n\n# calculate simple moving average\nwin_list = [5, 50, 100, 250]\nfor win in win_list:\n    ma = df['sp500'].rolling(win).std()\n    df[win] = ma\n    df.rename(columns={win:'Vol via '+str(win)+' days MA'}, inplace=True)\n\n# plot dataframe\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 12))\n# sp500 price\nax1.plot(df['sp500'])\nax1.set_title('SP500 price')\nax1.set_xlabel(\"Date\")\nax1.set_ylabel(\"Price\")\nax1.spines['right'].set_visible(False)\nax1.spines['top'].set_visible(False)\nax1.yaxis.set_ticks_position('left')\nax1.xaxis.set_ticks_position('bottom')\n# daily log return squared\nax2.plot(df['Daily return squared'])\nax2.set_title('Daily return squared')\nax2.set_xlabel(\"Date\")\nax2.set_ylabel(\"Daily return squared\")\nax2.spines['right'].set_visible(False)\nax2.spines['top'].set_visible(False)\nax2.yaxis.set_ticks_position('left')\nax2.xaxis.set_ticks_position('bottom')\n# ma vol\nax3.plot(df.loc[:, (df.columns != 'sp500') & (df.columns != 'Daily return squared')])\nax3.legend(df.loc[:, (df.columns != 'sp500') & (df.columns != 'Daily return squared')].columns)\nax3.set_title('SP500 price volatility via moving average analysis')\nax3.set_xlabel(\"Date\")\nax3.set_ylabel(\"Volatility\")\nax3.spines['right'].set_visible(False)\nax3.spines['top'].set_visible(False)\nax3.yaxis.set_ticks_position('left')\nax3.xaxis.set_ticks_position('bottom')\n\nfig.tight_layout()"
      },
      {
        "id": "ex5",
        "title": "1.5 B2_Ch1_5.py",
        "filename": "B2_Ch1_5.py",
        "code": "# B2_Ch1_5.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport pandas_datareader\nimport matplotlib.pyplot as plt \n\n# sp500 price\ndf = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2010', end='12-28-2020')\ndf.dropna(inplace=True)\n\n# calculate cumulative moving average\ndf['cma'] = df['sp500'].expanding(1).std()\ndf.dropna(inplace=True)\n# df.rename(columns={win:'Vol via '+str(win)+' days MA'}, inplace=True)\n\n# plot dataframe\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 12))\nax1.plot(df['sp500'])\nax1.set_title('SP500 price')\nax1.set_xlabel(\"Date\")\nax1.set_ylabel(\"Price\")\nax1.spines['right'].set_visible(False)\nax1.spines['top'].set_visible(False)\nax1.yaxis.set_ticks_position('left')\nax1.xaxis.set_ticks_position('bottom')\n\nax2.plot(df['cma'])\nax2.set_title('SP500 price volatility via cumulative moving average analysis')\nax2.set_xlabel(\"Date\")\nax2.set_ylabel(\"Volatility\")\nax2.spines['right'].set_visible(False)\nax2.spines['top'].set_visible(False)\nax2.yaxis.set_ticks_position('left')\nax2.xaxis.set_ticks_position('bottom')\n\nfig.tight_layout()\n"
      },
      {
        "id": "ex6",
        "title": "1.6 B2_Ch1_6.py",
        "filename": "B2_Ch1_6.py",
        "code": "# B2_Ch1_6.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport pandas_datareader\nimport matplotlib.pyplot as plt \nimport numpy as np\n\n# sp500 price\ndf = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2010', end='12-28-2020')\ndf.dropna(inplace=True)\n\n# daily log return\ndf['Daily return squared'] = np.log(df['sp500'] / df['sp500'].shift(1))*np.log(df['sp500'] / df['sp500'].shift(1))\ndf.dropna(inplace=True)\n\n# calculate exponentially weighted moving average\nalpha_list = [0.01, 0.03, 0.06]\nfor alpha in alpha_list:\n    ma = df['sp500'].ewm(alpha=alpha, adjust=False).std()\n    df[alpha] = ma\n    df.rename(columns={alpha:'$\\lambda$ = '+str(1-alpha)}, inplace=True)\n\n# plot dataframe\n# sp500 price\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 12))\nax1.plot(df['sp500'])\nax1.set_title('SP500 price')\nax1.set_xlabel(\"Date\")\nax1.set_ylabel(\"Price\")\nax1.spines['right'].set_visible(False)\nax1.spines['top'].set_visible(False)\nax1.yaxis.set_ticks_position('left')\nax1.xaxis.set_ticks_position('bottom')\n\n# daily log return squared\nax2.plot(df['Daily return squared'])\nax2.set_title('Daily return squared')\nax2.set_xlabel(\"Date\")\nax2.set_ylabel(\"Daily return squared\")\nax2.spines['right'].set_visible(False)\nax2.spines['top'].set_visible(False)\nax2.yaxis.set_ticks_position('left')\nax2.xaxis.set_ticks_position('bottom')\n# ewma vol\nax3.plot(df.loc[:, (df.columns != 'sp500') & (df.columns != 'Daily return squared')])\nax3.legend(df.loc[:, (df.columns != 'sp500') & (df.columns != 'Daily return squared')].columns)\nax3.set_title('SP500 price volatility via EWMA analysis')\nax3.set_xlabel(\"Date\")\nax3.set_ylabel(\"Volatility\")\nax3.spines['right'].set_visible(False)\nax3.spines['top'].set_visible(False)\nax3.yaxis.set_ticks_position('left')\nax3.xaxis.set_ticks_position('bottom')\n\nfig.tight_layout()"
      },
      {
        "id": "ex7",
        "title": "1.7 B2_Ch1_7.py",
        "filename": "B2_Ch1_7.py",
        "code": "# B2_Ch1_7.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch1_7_A.py\nimport numpy as np\nimport pandas_datareader\nimport matplotlib.pyplot as plt \nfrom arch import arch_model\n\n# sp500 price\nsp500 = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2009', end='12-28-2020')\n\n# daily log return\nlog_return_daily = np.log(sp500 / sp500.shift(1))\nlog_return_daily.dropna(inplace=True)\n\n# ARCH(1) model\narch=arch_model(y=log_return_daily,mean='Constant',lags=0,vol='ARCH',p=1,o=0,q=0,dist='normal')\narchmodel=arch.fit()\narchmodel.summary()\narchmodel.plot()\n\n# B2_Ch1_7_B.py\nplt.figure(figsize=(12,8))\nplt.plot(log_return_daily,label='Daily return')\nplt.plot(archmodel.conditional_volatility, label='Conditional volatility')\nplt.legend()\nplt.xlabel('Date')\nplt.ylabel('Return/Volatility')\n\n# B2_Ch1_7_C.py\n# GARCH(1,1) model\ngarch=arch_model(y=log_return_daily,mean='Constant',lags=0,vol='GARCH',p=1,o=0,q=1,dist='normal')\ngarchmodel=garch.fit()\ngarchmodel.summary()\ngarchmodel.plot()\n\n# B2_Ch1_7_D.py\nplt.figure(figsize=(12,8))\nplt.plot(log_return_daily,label='Daily return')\nplt.plot(archmodel.conditional_volatility, label='Conditional volatility')\nplt.legend()\nplt.xlabel('Date')\nplt.ylabel('Return/Volatility')"
      },
      {
        "id": "ex8",
        "title": "1.8 B2_Ch1_8.py",
        "filename": "B2_Ch1_8.py",
        "code": "# B2_Ch1_8.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport pandas_datareader\nimport matplotlib.pyplot as plt \nimport datetime\nimport matplotlib.dates as mdates\n\n\n# sp500 price\nsp500 = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2009', end='12-28-2020')\n\n# daily log return\nlog_return_daily = np.log(sp500 / sp500.shift(1))\nlog_return_daily.dropna(inplace=True)\n\nn = 250\nr = log_return_daily.iloc[-n:]\n\n# volatility prediction by EWMA with Î»=0.94\nlmd = 0.94\nvol_ewma = np.zeros(n)\nvol_ewma[0] = log_return_daily[(-n+1):(-n+6)].std()\nfor i in range(n-1):\n    vol_ewma[i+1] = np.sqrt(lmd*vol_ewma[i]**2 + (1-lmd)*r.iloc[i]**2)\n    \n# volatility prediction by ARCH(1)\nomega_arch = 0.000068\nalpha1 = 0.45 \nvol_arch = np.zeros(n)\nvol_arch[0] = np.sqrt(omega_arch + alpha1*log_return_daily.iloc[-n-1]**2)\nfor i in range(n-1):\n    vol_arch[i+1] = np.sqrt(omega_arch + alpha1*r.iloc[i]**2)\n\n#GARCH(1,1)\nomega = 0.000002\nalpha1 = 0.2\nbeta1 = 0.78\n\nvol_garch = np.zeros(n)\nvol_garch[0] = log_return_daily[-n+1:-n+6].std()\nfor i in range(n-1):\n    vol_garch[i+1] = np.sqrt(omega + alpha1*r.iloc[i]**2 + beta1*vol_garch[i]**2)\n\n# plot the curves\nxdate=(r.index+datetime.timedelta(days=1))\nplt.figure(figsize=(12,8))\nplt.xlabel('Date')\nplt.ylabel('Volatility')\nplt.title('Volatility comparison')\nplt.plot(xdate,vol_arch, label='ARCH(1)')\nplt.plot(xdate,vol_garch, label='GARCH(1,1)')\nplt.plot(xdate,vol_ewma, label='EWMA') \n\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%m/%d/%Y'))\nplt.gca().xaxis.set_major_locator(mdates.DayLocator(15))\nplt.xticks(rotation=30)\nplt.legend()\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex9",
        "title": "1.9 B2_Ch1_9.py",
        "filename": "B2_Ch1_9.py",
        "code": "# B2_Ch1_9.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nfrom scipy import stats\n\n# function to calculate price of options (call or put) by BS\ndef option_price_BS(option_type, sigma, s, k, r, T, q=0.0):    \n    d1 = (np.log(s / k) + (r - q + sigma ** 2 * 0.5) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    if option_type == 'call':\n        option_price = np.exp(-r*T) * (s * np.exp((r - q)*T) * stats.norm.cdf(d1) - k *  stats.norm.cdf(d2))\n        return option_price\n    elif option_type == 'put':\n        option_price = np.exp(-r*T) * (k * stats.norm.cdf(-d2) - s * np.exp((r - q)*T) *  stats.norm.cdf(-d1))\n        return option_price\n    else:\n        print('Option type should be call or put.')\n\n# funciton to calculate implied volatility by bisection method\ndef implied_vol(option_type, option_price, s, k, r, T, q):  \n    precision = 0.00001\n    upper_vol = 500.0\n    lower_vol = 0.0001\n    iteration = 0\n\n    while iteration >= 0:\n\n        iteration +=1\n        mid_vol = (upper_vol + lower_vol)/2.0\n        price = option_price_BS(option_type, mid_vol, s, k, r, T, q)\n        \n        if option_type == 'call':\n            lower_price = option_price_BS(option_type, lower_vol, s, k, r, T, q)\n            if (lower_price - option_price) * (price - option_price) > 0:\n                lower_vol = mid_vol\n            else:\n                upper_vol = mid_vol\n            if abs(price - option_price) < precision: \n                break \n\n        elif option_type == 'put':\n            upper_price = option_price_BS(option_type, upper_vol, s, k, r, T, q)\n\n            if (upper_price - option_price) * (price - option_price) > 0:\n                upper_vol = mid_vol\n            else:\n                lower_vol = mid_vol\n            if abs(price - option_price) < precision: \n                break \n            \n        if iteration == 100: \n            break\n    print('Implied volatility: %.2f' % mid_vol)\n    return mid_vol\n\n\nimplied_vol('call', 17.5, 586.08, 585, 0.0002, 30.0/365, 0.0)\n"
      },
      {
        "id": "ex10",
        "title": "1.10 B2_Ch1_10.py",
        "filename": "B2_Ch1_10.py",
        "code": "# B2_Ch1_10.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch1_10_A.py\nfrom mibian import BS\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# convert data to dataframe and initialize \"Implied volatility\" column\noption_data = pd.read_csv(r\"C:\\Users\\anran\\Dropbox\\FRM Book\\Volatility\\SPX_Option.csv\")\noption_data['date'] = pd.to_datetime(option_data['date'])\noption_data['Implied volatility'] = 0\noption_data.head\n\n\n# B2_Ch1_10_B.py\n# function to calculate implied volatility\ndef compute_implied_volatility(row):\n    underlyingPrice = row['underlying value']\n    strikePrice = row['strike']\n    interestRate = 0.002\n    daysToMaturity = row['days to maturity']\n    optionPrice = row['call price']\n    result = BS([underlyingPrice, strikePrice, interestRate, daysToMaturity], callPrice= optionPrice)\n    return result.impliedVolatility\n\noption_data['Implied volatility'] = option_data.apply(compute_implied_volatility, axis=1)\n\n\n# B2_Ch1_10_C.py\n# plot volatility smile\noption_data = option_data[option_data['date'] == pd.to_datetime('1/15/2021')]\nplt.plot(option_data['strike'], option_data['Implied volatility'])\nplt.title('Volatility smile')\nplt.ylabel('Implied volatility')\nplt.xlabel('Strike price')           \n\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')"
      }
    ]
  },
  {
    "id": "b2_ch2",
    "title": "ç¬¬2ç« ï¼šéš¨æ©ŸéŽç¨‹",
    "number": 2,
    "content": {
      "intro": "# ç¬¬ 2 ç« ï¼šéš¨æ©ŸéŽç¨‹ - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   2.1 éš¨æ©Ÿè®Šæ•¸èˆ‡éš¨æ©ŸéŽç¨‹ (Stochastic Process)\n*   2.2 é¦¬å¯å¤«éŽç¨‹ (Markov Process) èˆ‡æ­·å²ç„¡é—œæ€§\n*   2.3 é¦¬ä¸æ ¼çˆ¾ (Martingale) èˆ‡å…¬å¹³åšå¼ˆ\n*   2.4 éš¨æ©Ÿæ¼«æ­¥ (Random Walk) çš„é›¢æ•£èˆ‡é€£çºŒç‰¹å¾µ\n*   2.5 ç¶­ç´éŽç¨‹ (Wiener Process) / æ¨™æº–å¸ƒæœ—é‹å‹•\n*   2.6 ä¼Šè—¤å¼•ç† (ItÃ´'s Lemma) èˆ‡éš¨æ©Ÿè®Šæ›\n*   2.7 å¹¾ä½•å¸ƒæœ—é‹å‹• (Geometric Brownian Motion) èˆ‡è‚¡åƒ¹å»ºæ¨¡\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\néš¨æ©ŸéŽç¨‹æ˜¯ç¾ä»£é‡‘èžæ•¸å­¸çš„éˆé­‚ã€‚å¾žé¦¬å¯å¤«æ€§è³ªçš„ã€Œç„¡è¨˜æ†¶æ€§ã€å‡ºç™¼ï¼Œæœ¬ç« å¸¶é ˜è®€è€…ä¸€æ­¥æ­¥æ§‹å»ºå‡ºæè¿°é‡‘èžå¸‚å ´åƒ¹æ ¼æ³¢å‹•çš„æ ¸å¿ƒæ¨¡åž‹â€”â€”å¹¾ä½•å¸ƒæœ—é‹å‹•ï¼ˆGBMï¼‰ã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   ç†è§£ç‚ºä½•è‚¡ç¥¨åƒ¹æ ¼è¡Œç‚ºåœ¨é¦¬å¯å¤«å‡è¨­ä¸‹ç¬¦åˆå¼±å¼æ•ˆçŽ‡å¸‚å ´ï¼ˆEfficient Market Hypothesisï¼‰ã€‚\n*   æŽŒæ¡ç¶­ç´éŽç¨‹ï¼ˆ$dz$ï¼‰çš„ä¸‰å¤§ç‰¹é»žï¼šå¸¸æ…‹åˆ†ä½ˆã€å¢žé‡ç¨ç«‹ã€è·¯å¾‘é€£çºŒã€‚\n*   æŽŒæ¡ä¼Šè—¤å¼•ç†â€”â€”éš¨æ©Ÿå¾®ç©åˆ†ä¸­çš„ã€Œé€£éŽ–è¦å‰‡ã€ï¼Œé€™æ˜¯æŽ¨å°Ž Black-Scholes æ–¹ç¨‹çš„å¿…å‚™å·¥å…·ã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šåˆ©ç”¨ GBM æ¨¡æ“¬æœªä¾†ä¸€å¹´çš„è‚¡ç¥¨åƒ¹æ ¼è·¯å¾‘ï¼Œé€²è¡Œé¢¨éšªæƒ…å¢ƒåˆ†æžã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šä¼Šè—¤å¼•ç†çš„å…¬å¼æ‡‰ç”¨ï¼š$df = (\\frac{\\partial f}{\\partial S} \\mu S + \\frac{\\partial f}{\\partial t} + \\frac{1}{2} \\frac{\\partial^2 f}{\\partial S^2} \\sigma^2 S^2) dt + \\frac{\\partial f}{\\partial S} \\sigma S dz$ã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch2_1.py** | **[æ ¸å¿ƒ]** å¯¦ä½œå¹¾ä½•å¸ƒæœ—é‹å‹• (GBM) æ¨¡æ“¬èˆ‡å¤šè·¯å¾‘ç”Ÿæˆã€‚ |\n| **B2_Ch2_2.py** | æ¼”ç¤ºåŸºç¤Žéš¨æ©ŸéŽç¨‹æ•¸å€¼é‹ç®—èˆ‡æ•¸æ“šçµæ§‹è™•ç†ã€‚ |\n| **B2_Ch2_3.py** | éš¨æ©Ÿæ¨¡æ“¬ä¸­çš„åèª¤æ ¡æ­£èˆ‡ NumPy é«˜æ•ˆé‹ç®—ã€‚ |\n| **B2_Ch2_4.py** | è’™åœ°å¡ç¾…è·¯å¾‘ä¸‹çš„æ¨¡åž‹æ“¬åˆèˆ‡åœ–è¡¨åˆ†æžã€‚ |\n| **B2_Ch2_5.py** | æ¨¡æ“¬è·¯å¾‘çš„çµ±è¨ˆç‰¹å¾µï¼ˆå‡å€¼ã€æ¨™æº–å·®ï¼‰è¦–è¦ºåŒ–ã€‚ |\n| **B2_Ch2_6.py** | æ¼”ç¤ºå¤šè³‡ç”¢éš¨æ©Ÿè·¯å¾‘çš„ä¸¦è¡Œè¦–è¦ºåŒ–ä½ˆå±€ã€‚ |\n| **B2_Ch2_7.py** | é€²éšŽéš¨æ©ŸéŽç¨‹åœ–å½¢ç¹ªè£½èˆ‡é¢¨éšªæ•æ„Ÿåº¦å‘ˆç¾ã€‚ |\n| **B2_Ch2_8.py** | æ¼”ç¤ºéš¨æ©Ÿç¨®å­ (Random Seed) çš„é‡è¦æ€§èˆ‡é‡è¤‡æ€§é©—è­‰ã€‚ |\n| **B2_Ch2_9.py** | åˆ©ç”¨éš¨æ©Ÿè·¯å¾‘è¨ˆç®— Delta æŒ‡æ¨™ï¼Œåˆ†æžæ³¢å‹•çŽ‡å½±éŸ¿ã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 2.2-2.3 é¦¬å¯å¤«éŽç¨‹èˆ‡é¦¬ä¸æ ¼çˆ¾\n- **é¦¬å¯å¤«éŽç¨‹**ï¼šæœªä¾†çš„å€¼åƒ…å–æ±ºæ–¼ã€Œç¾åœ¨ã€ï¼Œè€Œèˆ‡ã€ŒéŽåŽ»ã€ç„¡é—œã€‚é€™åæ˜ äº†å¸‚å ´åƒ¹æ ¼å·²åŒ…å«æ‰€æœ‰æ­·å²è³‡è¨Šçš„å‡è¨­ã€‚\n- **é¦¬ä¸æ ¼çˆ¾**ï¼šé€™æ˜¯ä¸€å€‹é—œæ–¼å…¬å¹³åšå¼ˆçš„æ¦‚å¿µã€‚åœ¨ $t$ æ™‚åˆ»å° $T$ æ™‚åˆ»åƒ¹æ ¼çš„é æœŸï¼Œç­‰æ–¼ $t$ æ™‚åˆ»çš„ç•¶å‰åƒ¹æ ¼ï¼ˆç¶“éŽç„¡é¢¨éšªåˆ©çŽ‡æŠ˜ç¾å¾Œï¼‰ã€‚\n\n### 2.6 ä¼Šè—¤å¼•ç† (ItÃ´'s Lemma)\nåœ¨å‚³çµ±å¾®ç©åˆ†ä¸­ï¼Œæˆ‘å€‘å¿½ç•¥ $dt^2$ã€‚ä½†åœ¨éš¨æ©Ÿå¾®ç©åˆ†ä¸­ï¼Œç”±æ–¼ $dz^2 = dt$ï¼Œé€™å€‹äºŒéšŽé …å¿…é ˆä¿ç•™ã€‚é€™å°±æ˜¯ç‚ºä½•è¡ç”Ÿå“åƒ¹æ ¼çš„æ¼”åŒ–æ–¹ç¨‹ä¸­æœƒå‡ºç¾ã€Œå‡¸æ€§é …ã€ï¼ˆ$\\frac{1}{2} \\sigma^2 S^2 \\frac{\\partial^2 f}{\\partial S^2}$ï¼‰ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\n### ðŸ“„ B2_Ch2_1.py - GBM æ¨¡æ“¬\n- **å¯¦ä½œé‡é»ž**ï¼šå¯¦ä½œå¹¾ä½•å¸ƒæœ—é‹å‹•çš„é›¢æ•£å½¢å¼ $S_{t+\\Delta t} = S_t \\exp((\\mu - \\frac{\\sigma^2}{2})\\Delta t + \\sigma \\sqrt{\\Delta t} Z)$ã€‚æ¼”ç¤ºéš¨æ©Ÿè·¯å¾‘ç”Ÿæˆèˆ‡åœ–è¡¨ç¹ªè£½ã€‚\n- **é‡‘èžæ‡‰ç”¨**ï¼šé€™æ˜¯è’™åœ°å¡ç¾…å®šåƒ¹æ³•ç”¢å‡ºæ¨™çš„è³‡ç”¢åƒ¹æ ¼çš„æ ¸å¿ƒå…¬å¼ã€‚\n\n### ðŸ“„ B2_Ch2_8.py - å¯é‡è¤‡æ€§é©—è­‰\n- **å¯¦ä½œé‡é»ž**ï¼šæ¼”ç¤ºéš¨æ©Ÿç¨®å­è¨­å®šå°æ¨¡æ“¬çµæžœçš„å½±éŸ¿ã€‚åœ¨é¢¨éšªæŽ§ç®¡å¯¦å‹™ä¸­ï¼Œç‚ºäº†ä½¿æ¨¡åž‹å¯©æ ¸ï¼ˆAuditï¼‰å¯è¿½æº¯ï¼Œå¿…é ˆå›ºå®šéš¨æ©Ÿç¨®å­ã€‚\n- **æŠ€è¡“ç´°ç¯€**ï¼šä½¿ç”¨ `np.random.seed()` ç¢ºä¿çµæžœçš„ä¸€è‡´æ€§ã€‚\n\n### ðŸ“„ B2_Ch2_9.py - Delta èˆ‡éš¨æ©Ÿè·¯å¾‘\n- **å¯¦ä½œé‡é»ž**ï¼šåˆ©ç”¨è’™åœ°å¡ç¾…ç”Ÿæˆçš„éš¨æ©Ÿè·¯å¾‘ï¼Œé€šéŽå¾®å°æ“¾å‹•æ³•è¨ˆç®— Delta å¸Œè‡˜å­—æ¯ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šè·¯å¾‘ä¾è³´åž‹ç”¢å“çš„æ•æ„Ÿåº¦åˆ†æžã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- è‚¡ç¥¨åƒ¹æ ¼è·¯å¾‘æœ¬è³ªä¸Šæ˜¯ä¸é€£çºŒå¯å¾®çš„ï¼ˆContinuous but nowhere differentiableï¼‰ï¼Œå› æ­¤éœ€è¦éš¨æ©Ÿå¾®ç©åˆ†ã€‚\n- å¹¾ä½•å¸ƒæœ—é‹å‹•è§£æ±ºäº†åƒ¹æ ¼ç‚ºæ­£ï¼ˆLog-normalï¼‰èˆ‡å›žå ±çŽ‡å¸¸æ…‹çš„å„ªé›…çµåˆã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 3 ç« è’™åœ°å¡ç¾…ï¼ˆGBM çš„å¤§é‡æ‡‰ç”¨ï¼‰ã€ç¬¬ 6 ç«  BSM å®šåƒ¹ï¼ˆGBM çš„è§£æžè§£ï¼‰ã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Hull (2021) Options, Futures, and Other Derivatives*.\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch2*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "2.1 B2_Ch2_1.py",
        "filename": "B2_Ch2_1.py",
        "code": "# B2_Ch2_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport pandas_datareader\nimport matplotlib as mpl\nmpl.style.use('ggplot')\n\n## real stock price\n# stock: Twitter Inc\nticker = 'TWTR'\n\n# calibration period\nstart_date = '2018-10-1'\nend_date = '2020-10-1'\n\n# extract and plot historical stock data\nstock = pandas_datareader.data.DataReader(ticker, data_source='yahoo',  start=start_date, end=end_date)['Adj Close']\n\n## simulated stock price\nnp.random.seed(66)\ndef gbm(S,v,r,T):\n    return S * np.exp((r - 0.5 * v**2) * T + v * np.sqrt(T) * np.random.normal(0,1.0))\n\n# initial\nS0 = 26.68 \n# volatility\nvol = 0.8865\n# mu\nmu = 0.35 \n# time increment\ndt = 1/252\n# maturity in year\nT = 2 \n# step numbers\nN = int(T/dt) \n\npath=[]\nS=S0\nfor i in range(1,N+1):\n    S_t = gbm(S,vol,mu,dt)\n    S= S_t\n    path.append(S_t)\n\n## plot stock price\nrows = 2\ncols = 1\nfig, (ax1, ax2) = plt.subplots(rows, cols, figsize=(14,8))\n# real stock price\nax1.plot(stock)\nax1.set_title('(a) Stock price for TWTR', loc='left')\nax1.set_xlabel('Time')\nax1.set_ylabel('Real Stock price')\n# simulated stochastic process\nax2.plot(path)\nax2.set_title('(b) Simulated stochastic process', loc='left')\nax2.set_xlabel('t')\nax2.set_ylabel('S')\nplt.tight_layout()\n"
      },
      {
        "id": "ex2",
        "title": "2.2 B2_Ch2_2.py",
        "filename": "B2_Ch2_2.py",
        "code": "# B2_Ch2_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\n\n# today: stock price up\nI = np.matrix([[1, 0]])\n\n# transition matrix\nT = np.matrix([[.75, 0.25],\n               [.65, 0.35]])\n\nn = 3\nfor i in range(0, n):\n    T_tmp = I * T\n    I = T_tmp\n    # print ('The probability of stock price up/down after  day: ' , T)\n    print ('The probability of stock price up/down after %d day: ' % (i+1), I)\n"
      },
      {
        "id": "ex3",
        "title": "2.3 B2_Ch2_3.py",
        "filename": "B2_Ch2_3.py",
        "code": "# B2_Ch2_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\n\n#Current state\nI = np.matrix([[0.5, 0.5]])\n\n#Transition Matrix\nT = np.matrix([[.75, 0.25],\n               [.65, 0.35]])\n\nn = 3\nfor i in range(0, n):\n    T_tmp = I * T\n    I = T_tmp\n    print ('The probability of stock price up/down after %d day: ' % (i+1), I)\n"
      },
      {
        "id": "ex4",
        "title": "2.4 B2_Ch2_4.py",
        "filename": "B2_Ch2_4.py",
        "code": "# B2_Ch2_4.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport pandas as pd\nimport matplotlib.pyplot as plt \n\nfirst_win = 8\nwin_prob = 0.5\nprofit = 0\n\ntoss_list = []\nbet_list = []\nprofit_list = []\nwinlose_list = []\n\n# toss = 1\nbet = 1\nbet_list.append(bet)\nfor toss in range(1, first_win):    \n    toss_list.append(toss)\n    winlose_list.append('Lose')\n   \n    profit -= bet\n    bet *= 2\n    \n    bet_list.append(bet)\n    profit_list.append(profit)\n    \n    toss += 1\n\nif toss == first_win:\n    toss_list.append(toss)   \n    winlose_list.append('Win')\n    profit += bet \n    profit_list.append(profit)\n\nresults = pd.DataFrame(\n    {\n     'Toss': toss_list,\n     'Bet': bet_list,\n     'Win/Lose': winlose_list,\n     'Profit': profit_list\n     }                    \n    )\n\nprint(results)\n\nresults.plot.bar(x='Toss')\nplt.xlabel('Toss')\nplt.ylabel('Bet/Profit')\nplt.title('Bet and profit')\n"
      },
      {
        "id": "ex5",
        "title": "2.5 B2_Ch2_5.py",
        "filename": "B2_Ch2_5.py",
        "code": "# B2_Ch2_5.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# define parameters\ndims = 1\nstep_num = 500\npath_num = 10\nmove_mode = [-1, 1]\norigin = np.zeros((1, dims))\n\nfor path in range(path_num):\n    # random walk\n    step_shape = (step_num, dims)\n    steps = np.random.choice(a=move_mode, size=step_shape)\n    path = np.concatenate([origin, steps]).cumsum(0)\n    start = path[:1]\n    stop = path[-1:]\n    # plot path\n    plt.plot(np.arange(step_num+1), path, marker='+', markersize=0.02);\n    plt.plot(0, start, c='green', marker='s')\n    plt.plot(step_num, stop, c='red', marker='o')\n   \nplt.title('Random Walk in 1D')\nplt.xlabel('Step')\nplt.ylabel('Position')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex6",
        "title": "2.6 B2_Ch2_6.py",
        "filename": "B2_Ch2_6.py",
        "code": "# B2_Ch2_6.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndims = 2\nstep_num = 500\npath_num = 1\nmove_mode = [-1, 1]\norigin = np.zeros((1, dims))\n\nfor path in range(path_num):\n    # random walk\n    step_shape = (step_num, dims)\n    steps = np.random.choice(a=move_mode, size=step_shape)\n    path = np.concatenate([origin, steps]).cumsum(0)\n    start = path[:1]\n    stop = path[-1:]\n    # plot path\n    plt.plot(path[:,0], path[:,1], marker='+', markersize=0.02, c='lightblue');\n    plt.plot(start[:,0], start[:,1], marker='s', c='green') \n    plt.plot(stop[:,0], stop[:,1], marker='o', c='red')\n\nplt.title('Random Walk in '+str(dims)+'D')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex7",
        "title": "2.7 B2_Ch2_7.py",
        "filename": "B2_Ch2_7.py",
        "code": "# B2_Ch2_7.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndims = 3\nstep_num = 500\nmove_mode = [-1, 0, 1]\norigin = np.zeros((1, dims))\n\n# random walk\nstep_shape = (step_num, dims)\nsteps = np.random.choice(a=move_mode, size=step_shape)\npath = np.concatenate([origin, steps]).cumsum(0)\nstart = path[:1]\nstop = path[-1:]\n\n# plot path\nfig = plt.figure()\nax = plt.axes(projection='3d')\nax.plot3D(path[:,0], path[:,1], path[:,2],c='lightblue', marker='+');\nax.plot3D(start[:,0], start[:,1], start[:,2],c='green', marker='s')\nax.plot3D(stop[:,0], stop[:,1], stop[:,2],c='red', marker='o')\nax.set_title('Random Walk in '+str(dims)+'D')\n"
      },
      {
        "id": "ex8",
        "title": "2.8 B2_Ch2_8.py",
        "filename": "B2_Ch2_8.py",
        "code": "# B2_Ch2_8.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN = 1000\nT = 10\nsigma = 0.5\nmu = 0.8\ndt = T / float(N)\nt = np.linspace(0.0, N*dt, N+1)\nW0 = [0]\n\n# simulate the increments by normal random variable generator\nnp.random.seed(666)\nincrements = np.random.normal(0, 1*np.sqrt(dt), N)\nWt1 = W0 + list(np.cumsum(increments))\nWt2 = sigma*np.array(Wt1)\nWt3 = mu*t + sigma*np.array(Wt1)\n# plt.figure(figsize=(15,10))\nplt.plot(t, Wt1, label='W(t)')\nplt.plot(t, Wt2, label='$\\sigma$W(t)')\nplt.plot(t, Wt3, label='$\\mu$t+$\\sigma$W(t)')\nplt.plot(t, mu*t, '--', label='$\\mu$t')\nplt.legend()\nplt.xlabel('Time')\nplt.ylabel('X(t)')\n\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex9",
        "title": "2.9 B2_Ch2_9.py",
        "filename": "B2_Ch2_9.py",
        "code": "# B2_Ch2_9.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch2_9_A.py\nimport pandas as pd\nimport numpy as np\nimport pandas_datareader\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.style.use('ggplot')\n\n# stock: Apple Inc.\nticker = 'AAPL'\n\n# calibration period\nstart_date = '2010-9-1'\nend_date = '2020-9-30'\n\n# extract and plot historical stock data\nstock = pandas_datareader.data.DataReader(ticker, data_source='yahoo',  start=start_date, end=end_date)['Adj Close']\nstock.plot(figsize=(15,8), legend=None, c='r')\nplt.title('Stock price for AAPL')\nplt.xlabel('Time')\nplt.ylabel('Stock price')\n\n\n# B2_Ch2_9_B.py\n# stock log returns\nlog_returns = np.log(1 + stock.pct_change())\n\n# inital stock price\nS0 = stock.iloc[-1]\n# time increment\ndt = 1 \n# end date of prediction\npred_end_date = '2020-10-31' \n# days of prediction time horizon\nT = pd.date_range(start = pd.to_datetime(end_date, format = \"%Y-%m-%d\") + pd.Timedelta('1 days'), \n                 end = pd.to_datetime(pred_end_date,format = \"%Y-%m-%d\")).to_series().map(lambda x: 1 if x.isoweekday() in range(1,6) else 0).sum()\n\n# simulation steps\nN = int(T / dt)\n# mean\nmu = np.mean(log_returns)\nprint('Model mean: %.3f' % mu)\n# volitality\nvol = np.std(log_returns)\nprint('Model volatility: %.3f' % vol)\n\n\n# B2_Ch2_9_C.py\nS =  [None] * (N+1)\nS[0] = S0\nfor t in range(1, N+1):\n    # calculate drift and diffusion\n    drift = (mu - 0.5 * vol**2) * dt\n    diffusion = vol * np.random.normal(0, 1.0)  \n    # predict stock price\n    daily_returns = np.exp(drift + diffusion)\n    S[t] = S[t-1]*daily_returns\n\n# plot simulations\nplt.figure(figsize = (15,8))\nplt.title(\"Stock price prediction \")\nplt.plot(pd.date_range(start = stock.index.max(), \n                       end = pred_end_date, freq = 'D').map(lambda x: x if x.isoweekday() in range(1, 6) else np.nan).dropna(), \n         S)\nplt.xlabel('Time')\nplt.xticks(rotation = 45, ha='center')\nplt.ylabel('Stock price')\n"
      }
    ]
  },
  {
    "id": "b2_ch3",
    "title": "ç¬¬3ç« ï¼šè’™åœ°å¡ç¾…æ¨¡æ“¬",
    "number": 3,
    "content": {
      "intro": "# ç¬¬ 3 ç« ï¼šè’™åœ°å¡ç¾…æ¨¡æ“¬ - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   3.1 è’™åœ°å¡ç¾…æ¨¡æ“¬ (Monte Carlo Simulation) åŸºæœ¬æ€æƒ³\n*   3.2 å®šç©åˆ†çš„æ•¸å€¼æ±‚è§£èˆ‡ä¼°ç®—\n*   3.3 ä¼°ç®—åœ“å‘¨çŽ‡ ($\\pi$)ï¼šéš¨æ©Ÿå¯¦é©—çš„ç¶“å…¸æ¡ˆä¾‹\n*   3.4 è‚¡åƒ¹è·¯å¾‘æ¨¡æ“¬ (Price Path Simulation)\n*   3.5 å¤šè³‡ç”¢ç›¸é—œæ€§ (Correlation) æ¨¡æ“¬èˆ‡ Cholesky åˆ†è§£\n*   3.6 æ­å¼é¸æ“‡æ¬Š (European Options) çš„å®šåƒ¹å¯¦å‹™\n*   3.7 äºžå¼é¸æ“‡æ¬Š (Asian Options) çš„å®šåƒ¹èˆ‡è·¯å¾‘ç›¸ä¾æ€§\n*   3.8 é¦¬å¯å¤«éˆè’™åœ°å¡ç¾… (MCMC) æŠ½æ¨£æ¦‚è«–\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\nè’™åœ°å¡ç¾…æ¨¡æ“¬ï¼ˆMonte Carlo Simulationï¼‰æ˜¯è™•ç†è¤‡é›œé‡‘èžè¡ç”Ÿå“å®šåƒ¹èˆ‡é¢¨éšªè¯„ä¼°çš„æ ¸å¿ƒæ­¦å™¨ã€‚ç•¶æ¨¡åž‹ä¸å­˜åœ¨å°é–‰å¼è¡¨é”ï¼ˆClosed-form Solutionï¼‰æ™‚ï¼Œé€éŽç”Ÿæˆå¤§é‡éš¨æ©Ÿæ¨£æœ¬ä¸¦è¨ˆç®—å…¶æœŸæœ›å€¼ï¼Œæˆ‘å€‘å¯ä»¥è§£æ±ºé«˜ç¶­åº¦çš„å®šåƒ¹å•é¡Œã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   ç†è§£å¤§æ•¸æ³•å‰‡ï¼ˆLaw of Large Numbersï¼‰èˆ‡ä¸­å¤®æ¥µé™å®šç†ï¼ˆCLTï¼‰å¦‚ä½•æ”¯æ’è’™åœ°å¡ç¾…çµæžœçš„æ”¶æ–‚æ€§ã€‚\n*   å­¸æœƒå¦‚ä½•å°‡ç¨ç«‹çš„æ­£æ…‹åˆ†ä½ˆéš¨æ©Ÿæ•¸è½‰æ›ç‚ºå…·æœ‰ç‰¹å®šç›¸é—œæ€§çš„å¤šè³‡ç”¢æ”¶ç›ŠçŽ‡ã€‚\n*   æŽŒæ¡äºžå¼é¸æ“‡æ¬Šçš„å¹³å‡åƒ¹æ ¼ï¼ˆå‡å€¼ï¼‰è¨ˆç®—é‚è¼¯åŠå…¶åœ¨å¼·è·¯å¾‘ç›¸ä¾ç”¢å“ä¸­çš„æ‡‰ç”¨ã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šè¨ˆç®—çµæ§‹åž‹å•†å“ï¼ˆå¦‚é³³å‡°ç¥¨æ“šã€éšœç¤™æœŸæ¬Šï¼‰çš„å…¬å¹³åƒ¹å€¼ã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šç†è§£è’™åœ°å¡ç¾…èª¤å·®çš„æ¨™æº–å·®èˆ‡æ¨¡æ“¬æ¬¡æ•¸ $N$ çš„é—œä¿‚ï¼ˆ$\\sigma_{\\text{error}} \\propto 1/\\sqrt{N}$ï¼‰ã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch3_1.py** | å¯¦ä½œåŸºç¤Žæ•¸å€¼ç©åˆ†ï¼Œæ¼”ç¤ºéš¨æ©Ÿæ¨¡æ“¬èˆ‡è¦–è¦ºåŒ–ã€‚ |\n| **B2_Ch3_2.py** | **[æ ¸å¿ƒ]** å¯¦ä½œå®šç©åˆ†çš„è’™åœ°å¡ç¾…ä¼°ç®—ï¼Œåˆ†æžæ”¶æ–‚ç²¾åº¦ã€‚ |\n| **B2_Ch3_3.py** | æ¼”ç¤ºéš¨æ©Ÿæ•¸ç”Ÿæˆåœ¨ä¼°ç®—æ©ŸçŽ‡åˆ†ä½ˆä¸­çš„æ‡‰ç”¨ã€‚ |\n| **B2_Ch3_4.py** | **[æ ¸å¿ƒ]** åˆ©ç”¨ Cholesky åˆ†è§£å¯¦ä½œå…·æœ‰ç›¸é—œæ€§çš„å¤šè³‡ç”¢è·¯å¾‘æ¨¡æ“¬ã€‚ |\n| **B2_Ch3_5.py** | ä½¿ç”¨ Seaborn çµ±è¨ˆåœ–è¡¨å±•ç¤ºæ¨¡æ“¬è·¯å¾‘çš„åˆ†ä½ˆé‚Šç•Œã€‚ |\n| **B2_Ch3_6.py** | å¯¦ä½œ SciPy åœ¨é¢¨éšªè¨ˆé‡æ¨¡åž‹ä¸­çš„é€²éšŽæ‡‰ç”¨èˆ‡åƒæ•¸è©•ä¼°ã€‚ |\n| **B2_Ch3_7.py** | æ¼”ç¤ºæ­å¼é¸æ“‡æ¬Šçš„å¤šè·¯å¾‘å®šåƒ¹èˆ‡é æ¸¬åˆ†å¸ƒã€‚ |\n| **B2_Ch3_8.py** | è¦–è¦ºåŒ–è·¯å¾‘æ¨¡æ“¬çµæžœï¼Œåˆ†æžä¸åŒæ³¢å‹•çŽ‡æ°´å¹³ä¸‹çš„æ”¶æ–‚ç‰¹å¾µã€‚ |\n| **B2_Ch3_9.py** | **[æ ¸å¿ƒ]** å®šç¾©äºžå¼é¸æ“‡æ¬Šå®šåƒ¹å‡½æ•¸ï¼Œå¯¦ä½œè·¯å¾‘å¹³å‡åƒ¹æ ¼è¨ˆç®—ã€‚ |\n| **B2_Ch3_10.py** | å¯¦ä½œ MCMC (Metropolis-Hastings) æŠ½æ¨£ï¼Œæ±‚è§£è¤‡é›œçš„åˆ†ä½ˆæœŸæœ›å€¼ã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 3.2-3.3 æ•¸å€¼æ±‚è§£èˆ‡ä¼°ç®— $\\pi$\nè’™åœ°å¡ç¾…çš„æ ¸å¿ƒæ˜¯å°‡ç©åˆ†å•é¡Œè½‰åŒ–ç‚ºç©åˆ†åŸŸå…§çš„å–æ¨£å•é¡Œã€‚ä¾‹å¦‚ï¼Œä¼°ç®— $\\pi$ ä¾¿æ˜¯é€éŽåœ¨æ­£æ–¹å½¢å…§éš¨æ©ŸæŠ•é»žï¼Œè¨ˆç®—è½åœ¨åœ“å…§é»žçš„æ¯”ä¾‹ $\\frac{N_{in}}{N_{total}} \\approx \\frac{\\pi}{4}$ã€‚\n\n### 3.5 ç›¸é—œæ€§èˆ‡ Cholesky åˆ†è§£\nåœ¨å¤šè³‡ç”¢é¢¨éšªè©•ä¼°ï¼ˆå¦‚ Portfolio VaRï¼‰ä¸­ï¼Œå„è³‡ç”¢é–“å­˜åœ¨ç›¸é—œæ€§ã€‚è‹¥çµ¦å®šç›¸é—œçŸ©é™£ $R$ï¼Œæˆ‘å€‘é€éŽ $L = \\text{Cholesky}(R)$ å¾—åˆ°ä¸‹ä¸‰è§’çŸ©é™£ $L$ï¼Œå‰‡ç›¸é—œéš¨æ©Ÿæ•¸ $X = L \\epsilon$ï¼Œå…¶ä¸­ $\\epsilon$ æ˜¯ç¨ç«‹çš„æ¨™æº–æ­£æ…‹éš¨æ©Ÿæ•¸ã€‚\n\n### 3.7 äºžå¼é¸æ“‡æ¬Š (Asian Options)\näºžå¼æœŸæ¬Šæ˜¯è·¯å¾‘ç›¸ä¾åž‹ç”¢å“çš„å…¸åž‹ä»£è¡¨ã€‚å…¶æ”¶ç›Šå–æ±ºæ–¼æŒæœ‰æœŸå…§æ¨™çš„è³‡ç”¢åƒ¹æ ¼çš„å¹³å‡å€¼ï¼ˆç®—è¡“å¹³å‡æˆ–å¹¾ä½•å¹³å‡ï¼‰ã€‚é€™é¡žæœŸæ¬Šå°å¸‚å ´åƒ¹æ ¼çš„æš«æ™‚æ€§åŠ‡çƒˆè®Šå‹•ä¸æ•æ„Ÿï¼Œå› æ­¤å¸¸è¢«ä¼æ¥­ç”¨æ–¼å¥—æœŸä¿å€¼ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\n### ðŸ“„ B2_Ch3_4.py - å¤šè³‡ç”¢ç›¸é—œè·¯å¾‘\n- **å¯¦ä½œé‡é»ž**ï¼šä½¿ç”¨ `np.linalg.cholesky` è™•ç†ç›¸é—œçŸ©é™£ã€‚åˆ†æžç›¸é—œæ€§ä¿‚æ•¸å°æŠ•è³‡çµ„åˆé¢¨éšªï¼ˆè®Šç•°æ•¸ï¼‰çš„åˆ†æ•£ä½œç”¨ã€‚\n- **é‡‘èžæ‡‰ç”¨**ï¼šé€™æ˜¯ç±ƒå­æœŸæ¬Šï¼ˆBasket Optionsï¼‰å®šåƒ¹çš„æ¨™æº–æ¨¡çµ„ã€‚\n\n### ðŸ“„ B2_Ch3_9.py - äºžå¼é¸æ“‡æ¬Šå®šåƒ¹\n- **å¯¦ä½œé‡é»ž**ï¼šåœ¨æ¯å€‹æ¨¡æ“¬è·¯å¾‘ä¸­ï¼Œå…ˆè¨ˆç®—è©²è·¯å¾‘çš„æ‰€æœ‰æ™‚é–“æ­¥åƒ¹æ ¼çš„å¹³å‡å€¼ï¼Œå†å¸¶å…¥ Payoff å‡½æ•¸é€²è¡ŒæŠ˜ç¾ã€‚\n- **é—œéµä»£ç¢¼**ï¼š`Asian_Payoff = np.mean(price_path) - Strike`ã€‚\n\n### ðŸ“„ B2_Ch3_10.py - MCMC æŠ½æ¨£\n- **ä¸»è¦ç®—æ³•**ï¼šMetropolis-Hastings æŠ½æ¨£ã€‚\n- **å¯¦ä½œé‡é»ž**ï¼šå¯¦ä½œè¤‡é›œåˆ†ä½ˆçš„æ¨£æœ¬ç”Ÿæˆï¼Œæ¼”ç¤ºå¦‚ä½•åœ¨æ²’æœ‰é¡¯å¼ PDF å‡½æ•¸çš„æƒ…æ³ä¸‹ï¼Œé€šéŽè½‰ç§»æ ¸ï¼ˆTransition Kernelï¼‰é€²è¡ŒæœŸæœ›å€¼æ±‚è§£ã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- è’™åœ°å¡ç¾…æ³•æ˜¯ä¸æ‡‚è§£æžè§£æ™‚çš„ã€Œæš´åŠ›ç¾Žå­¸ã€ï¼Œå…¶å„ªé»žæ˜¯èˆ‡ç¶­åº¦ç„¡é—œï¼Œç¼ºé»žæ˜¯è¨ˆç®—è³‡æºæ¶ˆè€—è¼ƒå¤§ã€‚\n- è®Šç•°æ•¸ç¸®æ¸›æŠ€è¡“ï¼ˆå¦‚å°å¶è®Šé‡æ³• Anthetic Variatesï¼‰æ˜¯æå‡æ¨¡æ“¬æ•ˆçŽ‡çš„å¯¦å‹™é—œéµã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 5 ç« äºŒå…ƒæ¨¹ï¼ˆå¦ä¸€ç¨®æ•¸å€¼å®šåƒ¹æ³•ï¼‰ã€ç¬¬ 8 ç« å¸‚å ´é¢¨éšªï¼ˆè’™åœ°å¡ç¾…æ³•è¨ˆç®— VaRï¼‰ã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Glasserman (2003) Monte Carlo Methods in Financial Engineering*.\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch3*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "3.1 B2_Ch3_1.py",
        "filename": "B2_Ch2_1.py",
        "code": "# B2_Ch3_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\n# number of rectangle\nN = 20\n\n# integration domain\nl = 0.\nh = 5.\n\n# function to be integrated\ndef func(x):\n    return x**4 + x**3 + x**2\n\nx = np.linspace(l, h, N)\n\n# height for each rectangle\nfvalue = func(x) \n\n# area for each rectangle\narea = fvalue * (h - l)/N \nintgr = sum(area)\n\nprint(\"Integration result: \", round(intgr))\n\nmpl.style.use('ggplot')\nplt.plot(x, func(x), color='r')\nfor i in range(1,len(x)):\n    a = x[i-1]\n    b = x[i]\n    plt.plot([a,a], [0, func((a+b)/2)], color='#3C9DFF', alpha=0.5)\n    plt.plot([b,b], [0, func(b)], color='#3C9DFF', alpha=0.5)\n    plt.plot([a,b], [func((a+b)/2), func((a+b)/2)], color='#3C9DFF', alpha=0.5)\n\nwidth = x[N-4]-x[N-5]\nheight =  0.5*(func(x[N-4])+func(x[N-5]))\nXi = 0.5*(x[N-5]+x[N-4])\n\nrect = mpl.patches.Rectangle((x[N-5],0), width, height, color='#DBEEF4')\nplt.gca().add_patch(rect)\n\n# mark Xi\nplt.annotate('Xi', xy=(Xi, 0), xytext=(Xi, 40), horizontalalignment='center', verticalalignment='center',\n              arrowprops=dict(arrowstyle=\"-|>\",\n                              connectionstyle=\"arc3\",\n                              mutation_scale=10,\n                              color='r',\n                              fc=\"w\"))\nplt.text(Xi, 0.5*height, 'Ai', horizontalalignment='center', verticalalignment='center')\n\n# mark width\nplt.annotate(r'',\n            xy=(x[N-5], height+10),\n            xytext=(x[N-4], height+10),\n            arrowprops=dict(arrowstyle=\"<|-|>\",\n                            connectionstyle=\"arc3\",\n                            mutation_scale=20,\n                            color='coral',\n                            fc=\"w\")\n            )\nplt.text(Xi, height+20, '(h-l)/N', horizontalalignment='center', verticalalignment='center')\n\n# mark height\nplt.annotate(r'',\n            xy=(x[N-4]+0.05, 0), #xycoords='data',\n            xytext=(x[N-4]+0.05, height), #textcoords='data',\n            arrowprops=dict(arrowstyle=\"<|-|>\",\n                            connectionstyle=\"arc3\",\n                            mutation_scale=20,\n                            color='coral',\n                            fc=\"w\")\n            )\nplt.text(x[N-4]+0.1, height/2, 'f(Xi)', horizontalalignment='center', verticalalignment='center')\n\nplt.xlim([0,5])\nplt.ylim([0,800])\nplt.xlabel('x')\nplt.ylabel('f(x)')\n"
      },
      {
        "id": "ex2",
        "title": "3.2 B2_Ch3_2.py",
        "filename": "B2_Ch2_2.py",
        "code": "# B2_Ch3_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\n## monte carlo\n# number of rectangle\nMC_num = 20\n\n# integration domain\nl = 0.\nh = 5.\n\n# function to be integrated\ndef func(x):\n    return x**4 + x**3 + x**2\n\n\nmpl.style.use('ggplot')\nxx = np.linspace(l, h, 100)\nplt.plot(xx, func(xx), color='r')\narea_list = []\nfor _ in range(0, MC_num):\n    \n    # randomly generate mid point for rectangle\n    x = l + (h-l)/MC_num *np.random.randint(1, MC_num-1)\n    \n    # height for each rectangle\n    fvalue = func(x) \n    \n    # area for each rectangle\n    area = fvalue * (h - l)/MC_num \n    area_list.append(area)\n    \n    a = x-(h-l)/(2*MC_num)\n    b = x+(h-l)/(2*MC_num)\n    plt.plot([a,a], [0, func((a+b)/2)], color='#3C9DFF', alpha=0.5)\n    plt.plot([b,b], [0, func((a+b)/2)], color='#3C9DFF', alpha=0.5)\n    plt.plot([a,b], [func((a+b)/2), func((a+b)/2)], color='#3C9DFF', alpha=0.5)\n\nintgr = sum(area_list)\nprint(\"Integration result: \", round(intgr))\n \nplt.xlim([0,5])\nplt.ylim([0,800])\nplt.xlabel('x')\nplt.ylabel('f(x)')\n"
      },
      {
        "id": "ex3",
        "title": "3.3 B2_Ch3_3.py",
        "filename": "B2_Ch2_3.py",
        "code": "# B2_Ch3_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nMC_num = 2000\n\n# integration domain\nl = 0.\nh = 5.\n\n# function to be integrated\ndef func(x):\n    return x**4 + x**3 + x**2\n\n# plot function\nX = np.linspace(l, h, 100)\nplt.plot(X, func(X))\n\n# rectangle region\ny1 = 0\ny2 = func(h)\narea = (h-l)*(y2-y1)\n\nunderneath_list = []\nx_list = []\ny_list = []\nfor _ in range(MC_num):\n    x = np.random.uniform(l,h,1)\n    x_list.append(x)\n    y = np.random.uniform(y1,y2,1)\n    y_list.append(y)\n    if abs(y)>abs(func(x)) or y<0:\n        underneath_list.append(0)\n    else:\n        underneath_list.append(1)\n\n# integration result\nintgr = np.mean(underneath_list)*area\nprint(\"Integration result: \", round(intgr,2))\n\n# visualize the process\ndf = pd.DataFrame()\ndf['x'] = x_list\ndf['y'] = y_list\ndf['underneath'] = underneath_list\n\nplt.scatter(df[df['underneath']==0]['x'], df[df['underneath']==0]['y'], color='red')\nplt.scatter(df[df['underneath']==1]['x'], df[df['underneath']==1]['y'], color='blue') \nplt.xlim([0,5])\nplt.ylim([0,800])\nplt.xlabel('x')\nplt.ylabel('f(x)')\n"
      },
      {
        "id": "ex4",
        "title": "3.4 B2_Ch3_4.py",
        "filename": "B2_Ch2_4.py",
        "code": "# B2_Ch3_4.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch3_4_A.py \nimport mcint \nimport random \nimport math \nimport matplotlib.pyplot as plt\n\ndef w(r, theta, phi, alpha, beta, gamma): \n    return(-math.log(theta * beta)) \n\ndef integrand(x): \n    r  = x[0] \n    theta = x[1] \n    alpha = x[2] \n    beta = x[3] \n    gamma = x[4] \n    phi = x[5] \n    k = 1. \n    T = 1. \n    ww = w(r, theta, phi, alpha, beta, gamma) \n    return (math.exp(-ww/(k*T)) - 1.)*r*r*math.sin(beta)*math.sin(theta) \n\ndef sampler(): \n    while True: \n     r  = random.uniform(0.,1.) \n     theta = random.uniform(0.,2.*math.pi) \n     alpha = random.uniform(0.,2.*math.pi) \n     beta = random.uniform(0.,2.*math.pi) \n     gamma = random.uniform(0.,2.*math.pi) \n     phi = random.uniform(0.,math.pi) \n     yield (r, theta, alpha, beta, gamma, phi) \n\ndomainsize = math.pow(2*math.pi,4)*math.pi*1 \nexpected = 16*math.pow(math.pi,5)/3. \n\nMC_num_list = [50000, 100000, 500000, 1000000, 5000000, 10000000, 50000000, 100000000]\nrelative_error_list = []\nfor MC_num in MC_num_list: \n    random.seed(1) \n    # monte carlo integration via mcint library\n    result, error = mcint.integrate(integrand, sampler(), measure=domainsize, n=MC_num) \n    diff = abs(result - expected) \n    relative_error = diff/expected\n    relative_error_list.append(relative_error)\n    print(\"Monte Carlo simulation number: \", MC_num) \n    print(\"Monte Carlo simulation result: \", round(result,2), \" estimated error: \", round(error,2)) \n    print (\"True result = \", round(expected,2))\n    print (\"Relative error: {:.2%}\".format(relative_error))\n\n\n# B2_Ch3_4_B.py \nplt.plot(MC_num_list, relative_error_list, 'ro')\nplt.xscale('log')\nplt.xlabel('Monte Carlo simulation number')\nplt.ylabel('Relative error')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex5",
        "title": "3.5 B2_Ch3_5.py",
        "filename": "B2_Ch2_5.py",
        "code": "# B2_Ch3_5.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport random\n\nl = 2\nax, ay = -l/2, l/2\nbx, by = -l/2, -l/2\ncx, cy = l/2, l/2\ndx, dy = l/2, -l/2\n\nox, oy = int((ax+cx)/2), int((ay+by)/2)\n\npoint_num_list = [10, 50, 200, 500, 1000, 10000]\n\nrows = 3\ncols = 2\nfig, ax = plt.subplots(rows, cols, figsize=(14,8))\nfign = 0\nfig_label = ['(a)', '(b)', '(c)', '(d)', '(e)', '(f)']\n\nfor i in range(rows):\n    for j in range(cols):\n        print('Figure #: ', [i, j])\n        inside = 0\n        for _ in range(point_num_list[fign]):\n            x_inside = []\n            y_inside = []\n            x_outside = []\n            y_outside = []\n            \n            x = random.uniform(-l/2, l/2)\n            y = random.uniform(-l/2, l/2)\n            if (x-ox)**2+(y-oy)**2 <= (l/2)**2:\n                inside += 1\n                x_inside.append(x)\n                y_inside.append(y)\n            else:\n                x_outside.append(x)\n                y_outside.append(y)\n            \n            sns.scatterplot(x=x_inside, y=y_inside, color='g', ax=ax[i, j])\n            sns.scatterplot(x=x_outside, y=y_outside, color='r', ax=ax[i, j])\n            ax[i, j].set_title(fig_label[fign], loc='left')\n            ax[i, j].set_aspect('equal')\n            ax[i, j].set_xticks([-1, 0, 1])\n            ax[i, j].set_yticks([-1, 0, 1])\n        pi = 4*inside/point_num_list[fign]\n        print('Estimated /pi is %.4f based on %s points simulation.' %(pi,  point_num_list[fign]))            \n        fign+=1\n"
      },
      {
        "id": "ex6",
        "title": "3.6 B2_Ch3_6.py",
        "filename": "B2_Ch2_6.py",
        "code": "# B2_Ch3_6.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch3_6_A.py \nimport numpy as np\nimport pandas as pd\nimport pandas_datareader\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport seaborn as sns\nfrom scipy.stats import norm\nimport random\n\nmpl.style.use('ggplot')\n# extract stock data\nticker = 'AAPL'\nstock = pd.DataFrame()\nstock[ticker] = pandas_datareader.data.DataReader(ticker, data_source='yahoo', start='2010-1-1', end='2019-12-31')['Adj Close']\n\nstock.plot(figsize=(15,8), legend=None, c='r')\nplt.title('Stock price for AAPL')\nplt.xlabel('Time')\nplt.ylabel('Stock price')\n\n\n# B2_Ch3_6_B.py \n# logarithmic returns\nlog_returns = np.log(1 + stock.pct_change())\nax = sns.distplot(log_returns.iloc[1:])\nax.set_xlabel(\"Daily Log Return\")\nax.set_ylabel(\"Frequency\")\nax.set_yticks([10, 20, 30, 40])\n\n\n# B2_Ch3_6_C.py \n# drift and volatility\nu = log_returns.mean()\nvar = log_returns.var()\ndrift = u - (0.5*var)\nstdev = log_returns.std()\nprint('Model mean: %.3f' % u)\nprint('Model variance: %.4f' % var)\nprint('Model drift: %.3f' % drift)\nprint('Model volatility: %.3f' % stdev)\n\n\n\n# B2_Ch3_6_D.py \n# daily returns and simulations\ndays = 60\nMC_trials = 2000\nrandom.seed(66)\nZ = norm.ppf(np.random.rand(days, MC_trials)) \ndaily_returns = np.exp(drift.values + stdev.values * Z)\n\nprice_paths = np.zeros_like(daily_returns)\nprice_paths[0] = stock.iloc[-1]\nfor t in range(1, days):\n    price_paths[t] = price_paths[t-1]*daily_returns[t]\n\n# plot paths and distribution for last day\nrows = 1\ncols = 2\nfig, (ax1, ax2) = plt.subplots(rows, cols, figsize=(14,5), gridspec_kw={'width_ratios': [3, 1]})    \nax1.plot(price_paths, lw=0.5)\nax1.set_yticks([40, 70, 100, 130])\nax1.set_title('(a)', loc='left')\nax2 = sns.distplot(price_paths[-1], rug=True, rug_kws={\"color\": \"green\", \"alpha\": 0.5, \"height\": 0.06, \"lw\": 0.5}, vertical=True, label='(b)')\nax2.set_yticks([40, 70, 100, 130])\nax2.set_title('(b)', loc='left')\n\n"
      },
      {
        "id": "ex7",
        "title": "3.7 B2_Ch3_7.py",
        "filename": "B2_Ch2_7.py",
        "code": "# B2_Ch3_7.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch3_7_A.py \nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport pandas_datareader\nimport matplotlib as mpl\n\ntickers = ['AAPL','AMZN']\nticker_num = len(tickers)\nprice_data = []\nfor ticker in range(ticker_num):   \n    prices = pandas_datareader.DataReader(tickers[ticker], start='2016-01-15', end = '2021-01-15', data_source='yahoo')   \n    price_data.append(prices[['Adj Close']])\n    df_stocks = pd.concat(price_data, axis=1)\ndf_stocks.columns = tickers\n\nmpl.style.use('ggplot')\nfig, axs = plt.subplots(2, 1, figsize=(14,8))\naxs[0].plot(df_stocks['AAPL'], label='AAPL')\naxs[0].set_title('(a) AAPL', loc='left')\naxs[0].set_xlabel('Time')\naxs[0].set_ylabel('Stock price')\naxs[1].plot(df_stocks['AMZN'], label='AMZN')\naxs[1].set_title('(b) AMZN', loc='left')\naxs[1].set_xlabel('Time')\naxs[1].set_ylabel('Stock price')\nplt.tight_layout()\n\n\n\n# B2_Ch3_7_B.py \n# calculate log returns\nstock_return = []\nfor i in range(ticker_num):  \n    return_tmp = np.log(df_stocks[[tickers[i]]]/df_stocks[[tickers[i]]].shift(1))[1:]  \n    return_tmp = (return_tmp+1).cumprod()\n    stock_return.append(return_tmp[[tickers[i]]])\n    returns = pd.concat(stock_return,axis=1)\nreturns.head()\n\n# calculate mu and sigma\nmu = returns.mean()\nsigma = returns.cov()\n\n# cholesky decomp\nR = np.linalg.cholesky(returns.corr())\n\n\n\n# B2_Ch3_7_C.py \n# parameters\nT = 1\nN = 252\nStock_0 = df_stocks.iloc[0]\ndim = np.size(Stock_0)\nt = np.linspace(0., T, int(N))\nstockPrice = np.zeros([dim, int(N)])\nstockPrice[:, 0] = Stock_0\n\n# monte carlo simulations\nMC_num = 100\nmpl.style.use('ggplot')\nfig, axs = plt.subplots(2, 1, figsize=(14,8))\nfor num in range(MC_num):\n    for i in range(1, int(N)):    \n        drift = (mu - 0.5 * np.diag(sigma)) * (t[i] - t[i-1])\n        Z = np.random.normal(0., 1., dim)\n        diffusion = np.matmul(Z, R) * (np.sqrt(t[i] - t[i-1]))\n        stockPrice[:, i] = stockPrice[:, i-1]*np.exp(drift + diffusion)  \n    axs[0].plot(t, stockPrice.T[:,0], label='AAPL')\n    axs[0].set_title('(a) AAPL', loc='left')\n    axs[0].set_xlabel('Time')\n    axs[0].set_ylabel('Stock price')\n    axs[1].plot(t, stockPrice.T[:,1], label='AMZN')\n    axs[1].set_title('(b) AMZN', loc='left')\n    axs[1].set_xlabel('Time')\n    axs[1].set_ylabel('Stock price')\n    plt.tight_layout()\n    num+=1\n"
      },
      {
        "id": "ex8",
        "title": "3.8 B2_Ch3_8.py",
        "filename": "B2_Ch2_8.py",
        "code": "# B2_Ch3_8.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch3_8_A.py \nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport datetime\n\n# underlying price\nS0 = 857.29 \n# volatility\nv = 0.2076 \n# risk free interest rate\nr = 0.0014 # rate of 0.14%\n# maturity\nT = (datetime.date(2020,9,30) - datetime.date(2020,9,1)).days / 252.0\n# strike price\nK = 900.\n# monte carlo simulation numbers\nMC_num = 1000\n\nST_list = []\npayoff_list = []\ndiscount_factor = np.exp(-r * T)\n# monte carlo simulation\nfor i in range(MC_num):\n    ST = S0 * np.exp((r - 0.5 * v**2) * T + v * np.sqrt(T) * np.random.normal(0,1.0))\n    ST_list.append(ST)\n    payoff = max(0.0, ST-K)\n    payoff_list.append(payoff)\n\n# plot simulated asset price\nmpl.style.use('ggplot')\nplt.plot(ST_list, 'o', color='#3C9DFF', markersize=5)\nplt.hlines(S0, 0, MC_num, colors='g', linestyles='--',label='Initial asset price')\nplt.text(MC_num+1, S0, 'Initial asset price')\nplt.hlines(K, 0, MC_num, colors='r', linestyles='--',label='Strike price')\nplt.text(MC_num+1, K, 'Strike price')\nplt.title(\"Monte Carlo simulation for asset price\")\nplt.xlabel(\"Number of simulations\")\nplt.ylabel(\"Simulated asset price\")\n\n\n\n# B2_Ch3_8_B.py \noption_price = discount_factor * (sum(payoff_list) / float(MC_num))\nprint ('European call option price: %.2f' % option_price)\n"
      },
      {
        "id": "ex9",
        "title": "3.9 B2_Ch3_9.py",
        "filename": "B2_Ch2_9.py",
        "code": "# B2_Ch3_9.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch3_9_A.py \nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport pandas as pd\n\ndef MC_sim_asset_price(S0, r, v, steps_per_year, T_year, MC_sim_num):\n    np.random.seed(666)\n    sim_steps = steps_per_year*T_year\n    dt = 1/steps_per_year\n    drift = (r-0.5*v*v)*dt\n    voli = v*np.sqrt(dt)\n    St = np.zeros(shape=(sim_steps,MC_sim_num))\n    St[0,] = S0\n    for i in range(1,sim_steps):\n            for j in range(0,MC_sim_num):\n                e = np.random.randn(1)\n                St[i,j] = St[i-1,j]*np.exp(drift+voli*e)\n    return St \n\n\n\n# B2_Ch3_9_B.py \n# stock price simulation\nstock_price_sim = MC_sim_asset_price(S0=100, r=0.03, v=0.3, steps_per_year=252, T_year=2, MC_sim_num=10000)\n\nmpl.style.use('ggplot')\n# show first 9 steps of simulation\nplt.plot(pd.DataFrame(stock_price_sim).head(10))\nplt.title(\"Monte Carlo simulations for stock price\")\nplt.xlabel(\"Number of simulations\")\nplt.ylabel(\"Simulated stock prices\")\n\n\n\n# B2_Ch3_9_C.py \n# European call options\n# discount interest rate\nr = 0.03 \n# strike price\nK = 90 \n# simulation steps per year\nsteps_per_year = 252 \n# maturity\nT_year = 2 \n# monte carlo simulation number\nMC_sim_num = 10000\n\nsim_stocks = pd.DataFrame(stock_price_sim)\npayoffs_eur = []\n\nsim_steps = steps_per_year*T_year\nfor j in range(0, MC_sim_num):\n    payoffs_eur.append(max(sim_stocks.iloc[sim_steps-1, j]-K,0)*np.exp(-r*T_year))\n\neuropean_opt_price  = np.mean(payoffs_eur)\n\nprint('The price for the European call option: %.2f' % european_opt_price)\n\n\n\n# B2_Ch3_9_D.py \n# Asian call options\n# discount interest rate\nr = 0.03 \n# strike price\nK = 90 \n# simulation steps per year\nsteps_per_year = 252 \n# maturity\nT_year = 2 \n# monte carlo simulation number\nMC_sim_num = 10000\n# average time in days\nave_period = 10 \n\nsim_stocks = pd.DataFrame(stock_price_sim)\nave_prices = []\npayoffs_asian = []\n\nsim_steps = steps_per_year*T_year\nfor i in range(sim_steps-ave_period, sim_steps):\n    # arithmetic mean for each step\n    ave_prices.append(np.mean(sim_stocks [i]))\n    payoffs_asian.append(max(np.mean(sim_stocks [i])-K,0)*np.exp(-r*(i/steps_per_year)))\n\nasian_opt_price  = np.mean(payoffs_asian)\n\nprint('The price for the Asian call option: %.2f' % asian_opt_price)\n"
      },
      {
        "id": "ex10",
        "title": "3.10 B2_Ch3_10.py",
        "filename": "B2_Ch2_10.py",
        "code": "# B2_Ch3_10.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch3_10_A.py \nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.stats as stats\nimport matplotlib as mpl\n\nnp.random.seed(66)\n\ndef target_dist(likelihood, prior_dist, n, k, theta):\n    if theta < 0 or theta > 1:\n        return 0\n    else:\n        return likelihood(n, theta).pmf(k)*prior_dist.pdf(theta)\n\n\nlikelihood = stats.binom\nalpha = 20\nbeta = 20\nprior = stats.beta(alpha, beta)\nn = 100\nk = 70\n\nsigma = 0.2\ntheta = 0.3\naccept_num = 0\nMC_num = 50000\n\nsamples = np.zeros(MC_num+1)\nsamples[0] = theta\nfor i in range(MC_num):\n    theta_p = theta + stats.norm(0, sigma).rvs()\n    rho = min(1, target_dist(likelihood, prior, n, k, theta_p)/target_dist(likelihood, prior, n, k, theta))\n    # acceptation or rejection\n    u = np.random.uniform()\n    if rho > u:\n        accept_num += 1\n        theta = theta_p\n    samples[i+1] = theta\n\n# true posterior distribution\npost = stats.beta(k+alpha, n-k+beta)\nthetas = np.linspace(0, 1, 200)\n\n# assume markov chain stationary after half MC simulation number\nn_stationary = len(samples)//2\n\n# visualization\nmpl.style.use('ggplot')\nplt.figure(figsize=(14, 8))\nplt.hist(prior.rvs(n_stationary), 50, histtype='step', density=True, linewidth=1, label='Prior distribution')\nplt.hist(samples[n_stationary:], 50, histtype='step', density=True, linewidth=1, label='Target/Posterior distribution')\nplt.plot(thetas, post.pdf(thetas), c='red', linestyle='--', alpha=0.5, label='True posterior distribution')\nplt.xlim([0,1])\nplt.legend(loc='best')\n\n\n\n# B2_Ch3_10_B.py \n# MCMC: Metropolis-Hastings algorithm\ndef MCMC_MH(MC_num, n, k, theta, likelihood, prior_dist, sigma):\n    samples = [theta]\n    while len(samples) < MC_num:\n        theta_p = theta + stats.norm(0, sigma).rvs()\n        rho = min(1, target_dist(likelihood, prior_dist, n, k, theta_p)/target_dist(likelihood, prior_dist, n, k, theta ))\n        u = np.random.uniform()\n        if rho > u:\n            theta = theta_p\n        samples.append(theta)\n    return samples\n\n# parameters\nalpha = 20\nbeta = 20\nprior = stats.beta(alpha, beta)\nn = 100\nk = 70\nlikelihood = stats.binom\nsigma = 0.2\nMC_num = 40\n\nsample_list = [MCMC_MH(MC_num, n, k, theta, likelihood, prior, sigma) for theta in np.arange(0.1, 1, 0.2)]\n\n# Convergence of multiple chains\nfor sample in sample_list:\n    plt.plot(sample, '-o', markersize=8)\nplt.xlim([0, MC_num])\nplt.ylim([0, 1]);\nplt.xlabel('Monte Carlo simulation number')\nplt.ylabel('Probability')\n"
      }
    ]
  },
  {
    "id": "b2_ch4",
    "title": "ç¬¬4ç« ï¼šå›žæ­¸åˆ†æž",
    "number": 4,
    "content": {
      "intro": "# ç¬¬ 4 ç« ï¼šå›žæ­¸åˆ†æž - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   4.1 å›žæ­¸åˆ†æžæ¦‚è¿°\n*   4.2 å›žæ­¸æ¨¡åž‹çš„å»ºæ¨¡èˆ‡è©•ä¼°\n*   4.3 ç·šæ€§å›žæ­¸ (Linear Regression)\n*   4.4 é‚è¼¯å›žæ­¸ (Logistic Regression)\n*   4.5 å¤šé …å¼å›žæ­¸ (Polynomial Regression)\n*   4.6 å¶ºå›žæ­¸ (Ridge Regression)\n*   4.7 å¥—ç´¢å›žæ­¸ (Lasso Regression)\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\næœ¬ç« ä»‹ç´¹å„ç¨®å›žæ­¸åˆ†æžæ–¹æ³•åœ¨é‡‘èžå»ºæ¨¡ä¸­çš„æ‡‰ç”¨ã€‚å›žæ­¸åˆ†æžæ˜¯çµ±è¨ˆå­¸ä¸­çš„æ ¸å¿ƒå·¥å…·ï¼Œç”¨æ–¼å»ºç«‹è®Šæ•¸é–“çš„é—œä¿‚æ¨¡åž‹ã€‚åœ¨é‡‘èžé ˜åŸŸï¼Œå›žæ­¸åˆ†æžå»£æ³›æ‡‰ç”¨æ–¼é¢¨éšªå› å­åˆ†æžã€è³‡ç”¢å®šåƒ¹æ¨¡åž‹å’Œä¿¡ç”¨é¢¨éšªè©•ä¼°ç­‰æ–¹é¢ã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   æŽŒæ¡å„ç¨®å›žæ­¸åˆ†æžæ–¹æ³•åœ¨é‡‘èžä¸­çš„æ‡‰ç”¨ã€‚\n*   ç†è§£æ¨¡åž‹é¸æ“‡èˆ‡è©•ä¼°çš„çµ±è¨ˆæ–¹æ³•ï¼ˆå¦‚ MSE, $R^2$ï¼‰ã€‚\n*   ç†Ÿæ‚‰æ­£å‰‡åŒ–æŠ€è¡“ï¼ˆRidge, Lassoï¼‰åœ¨é‡‘èžå»ºæ¨¡ä¸­çš„é‹ç”¨ï¼Œè§£æ±ºå¤šé‡å…±ç·šæ€§å•é¡Œã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šåˆ©ç”¨é‚è¼¯å›žæ­¸å»ºç«‹ç°¡å–®çš„ä¿¡ç”¨è©•åˆ†æ¨¡åž‹ï¼Œé æ¸¬é•ç´„æ©ŸçŽ‡ã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šç†è§£ Lasso å›žæ­¸å¦‚ä½•é€²è¡Œç‰¹å¾µé¸æ“‡ï¼ˆFeature Selectionï¼‰ä»¥åŠéŽåº¦æ“¬åˆï¼ˆOverfittingï¼‰çš„é˜²æ²»ã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch4_1.py** | å¯¦ä½œå¤šç¨®å‡½æ•¸æ“¬åˆï¼Œæ¼”ç¤ºæ¨¡åž‹è¤‡é›œåº¦èˆ‡é æ¸¬æ€§èƒ½çš„å¹³è¡¡ã€‚ |\n| **B2_Ch4_2.py** | æ¼”ç¤ºåŸºç¤Žå›žæ­¸æ¨¡åž‹å»ºç«‹èˆ‡åœ–è¡¨è¦–è¦ºåŒ–ã€‚ |\n| **B2_Ch4_3.py** | åˆ©ç”¨ SciPy èˆ‡ Statsmodels é€²è¡Œç·šæ€§å›žæ­¸çµ±è¨ˆåˆ†æžã€‚ |\n| **B2_Ch4_4.py** | å¯¦ä½œä¸‰ç¶­ç·šæ€§å›žæ­¸è¦–è¦ºåŒ–ï¼Œåˆ†æžå¤šå€‹å› å­å°ç›®æ¨™è®Šæ•¸çš„å½±éŸ¿ã€‚ |\n| **B2_Ch4_5.py** | æ¼”ç¤ºæŒ‡æ•¸é‡åŒ–æ¨¡åž‹çš„åŸºç¤Žå›žæ­¸èˆ‡è¦–è¦ºåŒ–ã€‚ |\n| **B2_Ch4_6.py** | å¯¦ä½œé‚è¼¯å›žæ­¸ (Logistic Regression)ï¼Œæ‡‰ç”¨æ–¼åˆ†é¡žå•é¡Œèˆ‡æ··æ·†çŸ©é™£åˆ†æžã€‚ |\n| **B2_Ch4_7.py** | å¯¦ä½œå¤šé …å¼å›žæ­¸èˆ‡ MSE èª¤å·®è©•ä¼°ã€‚ |\n| **B2_Ch4_8.py** | åˆ©ç”¨çµ±è¨ˆæ–¹æ³•é€²è¡Œç·šæ€§æ“¬åˆèˆ‡åƒæ•¸é¡¯è‘—æ€§æª¢å®šã€‚ |\n| **B2_Ch4_9.py** | å¯¦ä½œå¶ºå›žæ­¸ (Ridge Regression)ï¼Œåˆ†æžæ­£å‰‡åŒ–åƒæ•¸å°ä¿‚æ•¸çš„æ“ å£“æ•ˆæžœã€‚ |\n| **B2_Ch4_10.py** | å¯¦ä½œå¥—ç´¢å›žæ­¸ (Lasso Regression)ï¼Œå±•ç¤ºå…¶ç‰¹å¾µé¸æ“‡ç‰¹æ€§ã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 4.3 ç·šæ€§å›žæ­¸ (Linear Regression)\n\n#### æ¦‚å¿µå®šç¾©\nç·šæ€§å›žæ­¸æ—¨åœ¨å°‹æ‰¾ä¸€æ¢ç›´ç·š $y = \\beta_0 + \\beta_1 x + \\epsilon$ï¼Œä½¿å¾—æ®˜å·®å¹³æ–¹å’Œæœ€å°åŒ– (Ordinary Least Squares, OLS)ã€‚\n\n#### è²¡é‡‘ç†è«–èƒŒæ™¯\nè³‡æœ¬è³‡ç”¢å®šåƒ¹æ¨¡åž‹ (CAPM) æœ¬è³ªä¸Šå°±æ˜¯ä¸€å€‹å–®å› å­ç·šæ€§å›žæ­¸ï¼š$E(R_i) = R_f + \\beta_i (E(R_m) - R_f)$ã€‚\n\n---\n\n### 4.6-4.7 æ­£å‰‡åŒ–ï¼šRidge èˆ‡ Lasso\n\n#### æ¦‚å¿µå®šç¾©\n- **Ridge å›žæ­¸**ï¼šåœ¨æå¤±å‡½æ•¸ä¸­åŠ å…¥ L2 æ‡²ç½°é …ï¼ˆä¿‚æ•¸å¹³æ–¹å’Œï¼‰ã€‚\n- **Lasso å›žæ­¸**ï¼šåŠ å…¥ L1 æ‡²ç½°é …ï¼ˆä¿‚æ•¸çµ•å°å€¼ä¹‹å’Œï¼‰ï¼Œå¯ä½¿éƒ¨åˆ†ä¿‚æ•¸ç¸®æ¸›ç‚ºé›¶ã€‚\n\n#### è²¡é‡‘ç†è«–èƒŒæ™¯\nåœ¨é‡‘èžå› å­æ¨¡åž‹ä¸­ï¼Œå› å­æ•¸é‡å¯èƒ½éŽå¤šä¸”é«˜åº¦ç›¸é—œã€‚æ­£å‰‡åŒ–èƒ½æœ‰æ•ˆè™•ç†å¤šé‡å…±ç·šæ€§ï¼Œæå‡æ¨¡åž‹åœ¨æ¸¬è©¦é›†ä¸Šçš„æ³›åŒ–èƒ½åŠ›ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\nä»¥ä¸‹ç‚ºæœ¬ç« å„å¯¦ä½œè…³æœ¬çš„æŠ€è¡“ç´°ç¯€è£œå……ï¼š\n\n### ðŸ“„ B2_Ch4_1.py - æ¨¡åž‹è¤‡é›œåº¦åˆ†æž\n- **ä¸»è¦å‡½æ•¸**ï¼š`fun1()`, `fun2()`, `fun3()`, `fun4()`\n- **å¯¦ä½œé‡é»ž**ï¼šä½¿ç”¨ `PolynomialFeatures` èˆ‡ `Pipeline` å»ºç«‹ä¸åŒéšŽæ•¸çš„å›žæ­¸æ¨¡åž‹ï¼Œè§€å¯Ÿæ¬ æ“¬åˆèˆ‡éŽæ“¬åˆç¾è±¡ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šæ¨¡åž‹é¸æ“‡ã€åèª¤-è®Šç•°æ¬Šè¡¡ (Bias-Variance Trade-off)ã€‚\n\n### ðŸ“„ B2_Ch4_6.py - é‚è¼¯å›žæ­¸åˆ†é¡ž\n- **å¯¦ä½œé‡é»ž**ï¼šå¯¦ä½œè³‡æ–™åˆ†å‰² (`train_test_split`)ã€æ¨¡åž‹è¨“ç·´åŠæ··æ·†çŸ©é™£ (`confusion_matrix`) è¦–è¦ºåŒ–ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šä¿¡ç”¨è©•ç­‰é æ¸¬ã€äºŒå…ƒåˆ†é¡žé¢¨éšªæŒ‡æ¨™ã€‚\n\n### ðŸ“„ B2_Ch4_9.py & B2_Ch4_10.py - æ­£å‰‡åŒ–å¯¦å‹™\n- **ä¸»è¦å‡½æ•¸**ï¼š`ridge_regression_fit_plot()`, `lasso_regression_fit_plot()`\n- **å¯¦ä½œé‡é»ž**ï¼šåˆ†æžä¸åŒçš„ $\\alpha$ (Lambda) åƒæ•¸å¦‚ä½•å½±éŸ¿å›žæ­¸æ›²ç·šçš„å¹³æ»‘åº¦èˆ‡ç‰¹å¾µæ¬Šé‡ã€‚\n- **æ¨¡åž‹è¨ºæ–·**ï¼šåŒ…å«æ®˜å·®åˆ†æžèˆ‡äº¤å‰é©—è­‰çš„åŸºæœ¬é‚è¼¯ã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- å›žæ­¸åˆ†æžå»ºç«‹è®Šæ•¸é–“çš„çµ±è¨ˆé—œä¿‚æ¨¡åž‹ã€‚\n- æ­£å‰‡åŒ–æŠ€è¡“æœ‰åŠ©æ–¼é˜²æ­¢éŽåº¦é…é©å•é¡Œï¼Œæ˜¯é‡‘èžé«˜ç¶­æ•¸æ“šå»ºæ¨¡çš„å¿…å‚™å·¥å…·ã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 9 ç« ä¿¡ç”¨é¢¨éšªã€ç¬¬ 11 ç« æŠ•è³‡çµ„åˆç†è«–ï¼ˆå› å­æ¨¡åž‹æ‡‰ç”¨ï¼‰ã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Hastie et al., The Elements of Statistical Learning*\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch4*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "4.1 B2_Ch4_1.py",
        "filename": "B2_Ch4_1.py",
        "code": "# B2_Ch4_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\n# define functions for data point generation\ndef fun1(x):\n    return -2*x+3\n\ndef fun2(x):\n    return 2*x+1\n\ndef fun3(x):\n    return np.sin(1.5 * np.pi * x)\n\ndef fun4(x):\n    return np.cos(2.1 * np.pi * (x-1.))+np.cos(3 * np.pi * x)\n\n\nnp.random.seed(6)\n\nnum_sample = 30\n\nX = np.sort(np.random.rand(num_sample))\n\nrows = 2\ncols = 2\nfig, axs = plt.subplots(rows, cols, figsize=(14,8))\n\n# fig1\ny1 = fun1(X) + np.random.randn(num_sample) * 0.1\npolynomial_features = PolynomialFeatures(degree=1, include_bias=False)\nlinear_regression = LinearRegression()\npipeline = Pipeline([(\"polynomial_features\", polynomial_features),\n                     (\"linear_regression\", linear_regression)])\npipeline.fit(X[:, np.newaxis], y1)\n\nX_test = np.linspace(0, 1, 1000)\naxs[0, 0].plot(X_test, pipeline.predict(X_test[:, np.newaxis]), color='red', label=\"Fitting model\")\naxs[0, 0].scatter(X, y1)\naxs[0, 0].set_yticks([1.0, 1.5, 2.0, 2.5, 3.0])\naxs[0, 0].set_title('(a)', loc='left')\n\n# fig2\ny2 = fun2(X) + np.random.randn(num_sample) * 0.1\npolynomial_features = PolynomialFeatures(degree=1, include_bias=False)\nlinear_regression = LinearRegression()\npipeline = Pipeline([(\"polynomial_features\", polynomial_features),\n                     (\"linear_regression\", linear_regression)])\npipeline.fit(X[:, np.newaxis], y2)\n\nX_test = np.linspace(0, 1, 1000)\naxs[0, 1].plot(X_test, pipeline.predict(X_test[:, np.newaxis]), color='red', label=\"Fitting model\")\naxs[0, 1].scatter(X, y2)\naxs[0, 1].set_yticks([1.0, 1.5, 2.0, 2.5, 3.0])\naxs[0, 1].set_title('(b)', loc='left')\n\n# fig3\ny3 = fun3(X) + np.random.randn(num_sample) * 0.1\npolynomial_features = PolynomialFeatures(degree=5, include_bias=False)\nlinear_regression = LinearRegression()\npipeline = Pipeline([(\"polynomial_features\", polynomial_features),\n                     (\"linear_regression\", linear_regression)])\npipeline.fit(X[:, np.newaxis], y3)\n\nX_test = np.linspace(0, 1, 1000)\naxs[1, 0].plot(X_test, pipeline.predict(X_test[:, np.newaxis]), color='red', label=\"Fitting model\")\naxs[1, 0].scatter(X, y3)\naxs[1, 0].set_title('(c)', loc='left')\n\n# fig4\ny4 = fun4(X) + np.random.randn(num_sample) * 0.1\npolynomial_features = PolynomialFeatures(degree=8, include_bias=False)\nlinear_regression = LinearRegression()\npipeline = Pipeline([(\"polynomial_features\", polynomial_features),\n                     (\"linear_regression\", linear_regression)])\npipeline.fit(X[:, np.newaxis], y4)\n\nX_test = np.linspace(0, 1, 1000)\naxs[1, 1].plot(X_test, pipeline.predict(X_test[:, np.newaxis]), color='red', label=\"Fitting model\")\naxs[1, 1].scatter(X, y4)\naxs[1, 1].set_yticks([-1.0, 0.0, 1.0, 2.0])\naxs[1, 1].set_title('(d)', loc='left')\n"
      },
      {
        "id": "ex2",
        "title": "4.2 B2_Ch4_2.py",
        "filename": "B2_Ch4_2.py",
        "code": "# B2_Ch4_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\ndef original_fun(X):\n    return np.sin(1.5 * np.pi * X)\n\nnp.random.seed(6)\n\nnum_sample = 30\ndegrees = [1, 5, 15]\ntitles = ['(a) Underfitting', '(b) Optimalfitting', '(c) Overfitting']\nX = np.sort(np.random.rand(num_sample))\ny = original_fun(X) + np.random.randn(num_sample) * 0.1\n\nrows = 1\ncols = 3\nfig, axs = plt.subplots(rows, cols, figsize=(14,5))\n\nfor i in range(len(degrees)):\n    polynomial_features = PolynomialFeatures(degree=degrees[i],\n                                             include_bias=False)\n    linear_regression = LinearRegression()\n    pipeline = Pipeline([(\"polynomial_features\", polynomial_features),\n                         (\"linear_regression\", linear_regression)])\n    pipeline.fit(X[:, np.newaxis], y)\n\n    X_test = np.linspace(0, 1, 100)\n    axs[i].plot(X_test, pipeline.predict(X_test[:, np.newaxis]), color='red', label=\"Fitting model\")\n    axs[i].plot(X_test, original_fun(X_test), color='lightblue', label=\"Original function\")\n    axs[i].scatter(X, y, s=20, label=\"Samples\")\n    axs[i].set_xlim(0, 1)\n    axs[i].set_ylim(-2, 2)\n    axs[i].set_xticks([0.0, 0.5, 1.0])\n    axs[i].set_yticks([-2, -1, 0, 1, 2])\n    axs[i].legend(loc=\"best\")\n    axs[i].set_title(titles[i], loc='left')\n"
      },
      {
        "id": "ex3",
        "title": "4.3 B2_Ch4_3.py",
        "filename": "B2_Ch4_3.py",
        "code": "# B2_Ch4_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nfrom scipy import stats\nimport pandas as pd\nimport datetime as dt\n\n# WTI price        \ndf_WTIPrice = pd.read_csv(r'C:\\Users\\anran\\Dropbox\\FRM Book\\Regression\\WTI.csv', sep=',', usecols=['Date', 'Price'])\n# hazard rate of an energy company\ndf_HazardRate = pd.read_csv(r'C:\\Users\\anran\\Dropbox\\FRM Book\\Regression\\HazardRate.csv', sep=',', usecols=['Date', 'HazardRate'])\n# merge harzard rate file and wti price file\ndf_dwr = df_HazardRate.merge(df_WTIPrice, left_on='Date', right_on='Date', how = 'inner')\n\ndf_dwr['Date'] = pd.to_datetime(df_dwr['Date'])\ndf_dwr = df_dwr[(df_dwr['Date']>=dt.datetime(2008, 8, 30))&(df_dwr['Date']<=dt.datetime(2008, 10, 30))]\nxdata = df_dwr['Price']\nydata = df_dwr['HazardRate']\nplt.plot(xdata, ydata, 'o', label='data')\n\n# linear regression between hazard rate of an energy company and wti\nslope, intercept, r_value, p_value, std_err = stats.linregress(xdata,ydata)\nprint('slope: %f, intercept: %f, r_value: %f, p_value: %f, std_err: %f' % (slope, intercept, r_value, p_value, std_err))\n\nR_squared = r_value*r_value\nprint('R squared: %.2f' % R_squared)\nrline = intercept + slope*xdata\n\nplt.plot(xdata, rline,'r-')\nplt.title('Simple Linear Regression')\nplt.xlabel('WTI')\nplt.ylabel('Hazard Rate')\nplt.gca().set_yticks([0.005, 0.010, 0.015, 0.020])\nplt.legend(['Observed Data', 'y=%5.4f+%5.5fÃ—x, RÂ²=%5.2f' % (intercept, slope, r_value**2)])\n\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex4",
        "title": "4.4 B2_Ch4_4.py",
        "filename": "B2_Ch4_4.py",
        "code": "# B2_Ch4_4.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch4_4_A.py\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\nimport matplotlib as mpl\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom sklearn.metrics import mean_squared_error, r2_score\n\n\n# B2_Ch4_4_B.py\n# read data\ndf = pd.read_csv(r'C:\\Users\\anran\\Dropbox\\FRM Book\\Regression\\MultiLrRegrData.csv')\ndf.head()\n\n\n# B2_Ch4_4_C.py\n# plot stock index price vs interest rate and unemployment rate\nmpl.style.use('ggplot')\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6), sharey=True)\nax1.scatter(df['InterestRate'], df['StockIndexPrice'], color='red')\nax1.set_title('(a) Stock index price VS interest rate', loc='left', fontsize=14)\nax1.set_xlabel('Interest rate', fontsize=14)\nax1.set_ylabel('Stock index price', fontsize=14)\nax1.set_yticks([700, 900, 1100, 1300, 1500])\nax1.grid(True)\n\nax2.scatter(df['UnemploymentRate'], df['StockIndexPrice'], color='green')\nax2.set_title('(b) Stock index price VS unemployment rate', loc='left', fontsize=14)\nax2.set_xlabel('Unemployment rate', fontsize=14)\nax2.set_ylabel('Stock index price', fontsize=14)\nax2.grid(True)\n\n\n# B2_Ch4_4_D.py\n# implement linear regression model\nx = df[['InterestRate','UnemploymentRate']] \ny = df['StockIndexPrice']\nMultiLrModel = LinearRegression()\nMultiLrModel.fit(x, y)\n\n# plot multiple regression model\nfig = plt.figure()\nax = plt.axes(projection='3d')\nzdata = df['StockIndexPrice']\nxdata = df['InterestRate']\nydata = df['UnemploymentRate']\nax.scatter(xdata, ydata, zdata, c=zdata)\nx3d, y3d = np.meshgrid(xdata, ydata)\nz3d_pred = MultiLrModel.intercept_+MultiLrModel.coef_[0]*x3d+MultiLrModel.coef_[1]*y3d\nax.plot_surface(x3d, y3d, z3d_pred, color = 'grey', rstride = 100, cstride = 100, alpha=0.3)\nax.set_title('Multiple Linear Regression', fontsize=14)\nax.set_xlabel('Interest rate')\nax.set_ylabel('Unemployment rate')\nax.set_zlabel('Stock index price')\n\n\n# B2_Ch4_4_E.py\nzdata_pred = MultiLrModel.intercept_+MultiLrModel.coef_[0]*xdata+MultiLrModel.coef_[1]*ydata\nrmse = (np.sqrt(mean_squared_error(zdata, zdata_pred)))\nr2 = r2_score(zdata, zdata_pred)\nprint('RMSE of this polynomial regression model: %.2f' % rmse)\nprint('R square of this polynomial regression model: %.2f' % r2)\n"
      },
      {
        "id": "ex5",
        "title": "4.5 B2_Ch4_5.py",
        "filename": "B2_Ch4_5.py",
        "code": "# B2_Ch4_5.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pylab as plt\nimport numpy as np\n\nx = np.arange(-8, 8, 0.1)\nsig = 1 / (1 + np.exp(-x))\nplt.plot(x, sig)\nplt.title('Sigmoid Function')\nplt.xlabel('x')\nplt.ylabel('p')\nplt.show()\n"
      },
      {
        "id": "ex6",
        "title": "4.6 B2_Ch4_6.py",
        "filename": "B2_Ch4_6.py",
        "code": "# B2_Ch4_6.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch4_6_A.py\nimport pandas as pd\nimport matplotlib.pyplot as plt \nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nimport seaborn as sns\nfrom sklearn.metrics import confusion_matrix\n\n\n# B2_Ch4_6_B.py\nbankdata = pd.read_csv(r'C:\\Users\\anran\\Dropbox\\FRM Book\\Regression\\BankTeleCompaign.csv')\nbankdata = bankdata.dropna()\nbankdata.head()\n\n# B2_Ch4_6_C.py\n# plot related item/column \nsns.set(palette=\"pastel\")\nfig, ax = plt.subplots(3, 2, figsize=(6, 8))\nsns.countplot(y=\"job\",  data=bankdata, ax=ax[0, 0])\nsns.countplot(x=\"marital\", data=bankdata, ax=ax[0, 1])\nsns.countplot(x=\"default\", data=bankdata, ax=ax[1, 0])\nsns.countplot(x=\"housing\", data=bankdata, ax=ax[1, 1])\nsns.countplot(x=\"loan\", data=bankdata, ax=ax[2, 0])\nsns.countplot(x=\"poutcome\", data=bankdata, ax=ax[2, 1])\nplt.tight_layout()\n\n# B2_Ch4_6_D.py\n# create dunny variables with only two values: 0 or 1\ndata = pd.get_dummies(bankdata, columns =['job', 'marital', 'default', 'housing', 'loan', 'poutcome'])\n# drop unknow columns\ndata.drop([col for col in data.columns if 'unknow' in col], axis=1, inplace=True)\n# plot correlation heatmap\nsns.heatmap(data.corr(), square=True, cmap=\"YlGnBu\", linewidths=.01, linecolor='lightgrey', cbar_kws={\"orientation\": \"horizontal\", \"shrink\": 0.3, \"pad\": 0.25})\n\n# B2_Ch4_6_E.py\n# split data into training and test sets\nX = data.iloc[:,1:]\ny = data.iloc[:,0]\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)\n# implement logistic regression model\nmodelclassifier = LogisticRegression(random_state=0)\nmodelclassifier.fit(X_train, y_train)\n\n\n# B2_Ch4_6_F.py\n# evaluate model via confusion matrix \n# evaluate performance of classification model on a set of test dataset with known true values \ny_pred = modelclassifier.predict(X_test)\nconfusion_matrix = confusion_matrix(y_test, y_pred)\nprint(confusion_matrix)\n\n\n# B2_Ch4_6_G.py\n# evaluate model by accuracy\nmodel_score = modelclassifier.score(X_test, y_test)\nprint('Model accuracy on test set: {:.2f}'.format(model_score))\n"
      },
      {
        "id": "ex7",
        "title": "4.7 B2_Ch4_7.py",
        "filename": "B2_Ch4_7.py",
        "code": "# B2_Ch4_7.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch4_7_A.py\n# importing libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression\nimport matplotlib as mpl\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.metrics import mean_squared_error, r2_score\n\n# B2_Ch4_6_B.py\ndata = pd.read_csv(r'C:\\Users\\anran\\Dropbox\\FRM Book\\Regression\\PolyRegrData.csv')\n\n# plot data\nmpl.style.use('ggplot')\nplt.figure(figsize=(14,8))\nplt.scatter(data.iloc[:,0].values,data.iloc[:,1].values, c='#1f77b4')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title('Raw Data')\n\n\n# B2_Ch4_6_C.py\n# preprocess input data\nx = data.iloc[:,0].values.reshape(-1, 1)\ny = data.iloc[:,1].values.reshape(-1, 1)\npolynomial_features= PolynomialFeatures(degree=3)\nx_poly = polynomial_features.fit_transform(x)\n# create and then fit model\nLRmodel = LinearRegression()\nLRmodel.fit(x_poly,y)\nprint('intercept:', LRmodel.intercept_)\nprint('slope:', LRmodel.coef_)\n\n# plot\nplt.plot(x,y,'o',c='#1f77b4')\ny_poly_pred = LRmodel.predict(x_poly)\nplt.plot(x,y_poly_pred,'red')\nplt.legend(['Raw Data',       \n            'y=%5.2f+%5.2f*x+%5.2f*xÂ²+%5.2f*xÂ³' % (LRmodel.intercept_, LRmodel.coef_[0][1],LRmodel.coef_[0][2],LRmodel.coef_[0][3])    \n            ], prop={'size': 8})\nplt.title('Polynomial Regression Model')\n\n\n# B2_Ch4_6_D.py\n# valuate model\nrmse = np.sqrt(mean_squared_error(y,y_poly_pred))\nr2 = r2_score(y,y_poly_pred)\nprint('RMSE of this polynomial regression model: %.2f' % rmse)\nprint('R square of this polynomial regression model: %.2f' % r2)\n"
      },
      {
        "id": "ex8",
        "title": "4.8 B2_Ch4_8.py",
        "filename": "B2_Ch4_8.py",
        "code": "# B2_Ch4_8.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport pandas as pd\nfrom scipy import stats \nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv(r'C:\\Users\\anran\\Dropbox\\FRM Book\\Regression\\outliersimpact.csv')\n\nX = df.x\ny = df.y\n\nplt.plot(X, y, 'bo')\n\nslope1, intercept1, r_value1, p_value1, std_err1 = stats.linregress(X, y)\nrline1 = intercept1 + slope1*X\n\nplt.plot(X, rline1,'r-', label='Fitting with outliers')\n\nplt.annotate('Fitting with outliers', xy=(0.6, intercept1 + slope1*0.6), xytext=(0.6, 1.2), \n              arrowprops=dict(arrowstyle=\"-|>\",\n                             connectionstyle=\"arc3\",\n                             mutation_scale=20,\n                             fc=\"w\"))\n\nplt.annotate('outliers', xy=(0.802171, 0.5), xytext=(0.75, 0.6))#, \n             # arrowprops=dict(arrowstyle=\"-|>\",\n             #                connectionstyle=\"arc3\",\n             #                mutation_scale=20,\n             #                fc=\"w\"))\nplt.annotate('', xy=(0.89286, 0.6), xytext=(0.75, 0.6))#, \n                          # arrowprops=dict(arrowstyle=\"-|>\",\n                          #               connectionstyle=\"arc3\",\n                          #               mutation_scale=20,\n                          #               fc=\"w\"))\n\n# eliminate two outliers\ndf_nooutliers = df[(df['y']!=0.5) & (df['y']!=0.6)]\n\nX = df_nooutliers.x\ny = df_nooutliers.y\n\nslope2, intercept2, r_value2, p_valu2e, std_err2 = stats.linregress(X, y)\nrline2 = intercept2 + slope2*X\nplt.plot(X, rline2,'r--', label='Fitting without outliers')\n\nplt.annotate('Fitting without outliers', xy=(0.7, intercept2 + slope2*0.7), xytext=(0.4, 2.2), \n              arrowprops=dict(arrowstyle=\"-|>\",\n                             connectionstyle=\"arc3\",\n                             mutation_scale=20,\n                             fc=\"w\"))\n\nplt.title('Impact on linear regression by outliers')\nplt.gca().set_yticks([0.5, 1.0, 1.5, 2.0, 2.5])\n\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex9",
        "title": "4.9 B2_Ch4_9.py",
        "filename": "B2_Ch4_9.py",
        "code": "# B2_Ch4_9.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch4_9_A.py\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.linear_model import Ridge\n\n\n# B2_Ch4_9_B.py\n# extract and plot raw data\ndata = pd.read_csv(r'C:\\Users\\anran\\Dropbox\\FRM Book\\Regression\\RidgeRegrData.csv')\nplt.plot(data['x'], data['y'], 'o')\nplt.title('Raw Data')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n\n# B2_Ch4_9_C.py\n# prepare data with powers up to 15\nfor i in range(2,16):  \n    colname = 'x_%d'%i      \n    data[colname] = data['x']**i\nprint(data.head())\n\n\n# B2_Ch4_9_D.py\n# create ridge regression fit and plot function\ndef ridge_regression_fit_plot(data, predictors, alpha, alpha_subplotpos):\n    # fit ridge regression model\n    ridgeregrmodel = Ridge(alpha=alpha, normalize=True)\n    ridgeregrmodel.fit(data[predictors], data['y'])\n    y_pred = ridgeregrmodel.predict(data[predictors])\n    \n    # plot for model with predefined alpha\n    if alpha in alpha_subplotpos:\n        plt.subplot(alpha_subplotpos[alpha])\n        plt.tight_layout()\n        plt.plot(data['x'], data['y'],'.')\n        plt.plot(data['x'], y_pred, 'g-')         \n        plt.title('Ridge Regression:  $\\\\alpha$=%.3g'%alpha)\n    \n    # return results\n    rss = sum((y_pred-data['y'])**2)\n    ret = [rss]\n    ret.extend([ridgeregrmodel.intercept_])\n    ret.extend(ridgeregrmodel.coef_)\n    return ret\n\n\n# B2_Ch4_9_E.py\n# initialize predictors to be set of 15 powers of x\npredictors=['x']\npredictors.extend(['x_%d'%i for i in range(2,16)])\n# set list of alpha values\nalpha_list = [1e-20, 1e-10, 1e-5, 1e-3, 1e-2, 1e-1, 1, 2, 3, 5, 10, 20]\n# store coefficients\ncol = ['rss','intercept'] + ['coef_x_%d'%i for i in range(1,16)]\nind = ['alpha_%.2g' % alpha_list[i] for i in range(0,len(alpha_list))]\ncoef_matrix_ridge = pd.DataFrame(index=ind, columns=col)\n# alpha:subplot position\nalpha_subplotpos = {1e-20:241, 1e-10:242, 1e-3:243, 1e-2:244, 1e-1:245, 1:246, 5:247, 20:248}\nfor i in range(len(alpha_list)):\n    coef_matrix_ridge.iloc[i,] = ridge_regression_fit_plot(data, predictors, alpha_list[i], alpha_subplotpos)    \n\n\n\n# B2_Ch4_9_F.py\n# show parameter matrix\npd.options.display.float_format = '{:,.2g}'.format\ncoef_matrix_ridge\n\n# B2_Ch4_9_G.py\n# plot rss of models\nplt.plot(coef_matrix_ridge['rss'], 'o')\nplt.title('RSS Trend')\nplt.xlabel(r'$\\alpha$')\nplt.xticks(rotation=30)\nplt.ylabel('RSS')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n\n# B2_Ch4_9_H.py\ncoef_matrix_ridge.apply(lambda x: sum(x.values==0),axis=1)\n\n"
      },
      {
        "id": "ex10",
        "title": "4.10 B2_Ch4_10.py",
        "filename": "B2_Ch4_10.py",
        "code": "# B2_Ch4_10.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch4_10_A.py\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.linear_model import Lasso\n\n# create lasso regression fit and plot function\ndef lasso_regression_fit_plot(data, predictors, alpha, alpha_subplotpos):\n    # fit lasso regression model\n    lassoregrmodel = Lasso(alpha=alpha, normalize=True, tol=0.1)\n    lassoregrmodel.fit(data[predictors], data['y'])\n    y_pred = lassoregrmodel.predict(data[predictors])\n    \n    # plot for model with predefined alpha\n    if alpha in alpha_subplotpos:\n        plt.subplot(alpha_subplotpos[alpha])\n        plt.plot(data['x'], data['y'],'.')\n        plt.plot(data['x'], y_pred, 'r')         \n        plt.title('$\\\\alpha$=%.3g'%alpha)\n    plt.yticks([-1.0, -0.5, 0, 0.5, 1.0])\n    \n    # return results\n    rss = sum((y_pred-data['y'])**2)\n    ret = [rss]\n    ret.extend([lassoregrmodel.intercept_])\n    ret.extend(lassoregrmodel.coef_)\n    return ret\n\n\n# B2_Ch4_10_B.py\n# extract raw data\ndata = pd.read_csv(r'C:\\Users\\anran\\Dropbox\\FRM Book\\Regression\\RidgeRegrData.csv')\n\n# prepare data with powers up to 15\nfor i in range(2,16):  \n    colname = 'x_%d'%i      \n    data[colname] = data['x']**i\n\n# initialize predictors to be set of 15 powers of x\npredictors=['x']\npredictors.extend(['x_%d'%i for i in range(2,16)])\n\n# set list of alpha values\nalpha_list = [1e-20, 1e-10, 1e-5, 1e-3, 1e-2, 1e-1, 1, 2, 3, 5, 10, 20]\n\n# store coefficients\ncol = ['rss','intercept'] + ['coef_x_%d'%i for i in range(1,16)]\nind = ['alpha_%.2g'%alpha_list[i] for i in range(0,len(alpha_list))]\ncoef_matrix_lasso = pd.DataFrame(index=ind, columns=col)\n\n# alpha:subplot position\nalpha_subplotpos = {1e-20:231, 1e-10:232, 1e-5:233, 1e-3:234, 1e-2:235, 1e-1:236}\nfor i in range(len(alpha_list)):\n    coef_matrix_lasso.iloc[i,] = lasso_regression_fit_plot(data, predictors, alpha_list[i], alpha_subplotpos)\n\n\n# B2_Ch4_10_C.py\n# show parameter matrix\npd.options.display.float_format = '{:,.2g}'.format\ncoef_matrix_ridge\n\n\n# B2_Ch4_10_D.py\n# plot rss of models\nplt.plot(coef_matrix_lasso['rss'], 'o')\nplt.title('RSS Trend')\nplt.xlabel(r'$\\alpha$')\nplt.xticks(rotation=30)\nplt.ylabel('RSS')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n\n# B2_Ch4_10_E.py\ncoef_matrix_lasso.apply(lambda x: sum(x.values==0),axis=1)\n"
      }
    ]
  },
  {
    "id": "b2_ch5",
    "title": "ç¬¬5ç« ï¼šé¸æ“‡æ¬ŠäºŒå…ƒæ¨¹",
    "number": 5,
    "content": {
      "intro": "# ç¬¬ 5 ç« ï¼šé¸æ“‡æ¬ŠäºŒå…ƒæ¨¹ - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   5.1 é¸æ“‡æ¬Šå¸‚å ´èˆ‡åˆç´„è¦æ ¼\n*   5.2 æ¨™çš„ç‰©äºŒå…ƒæ¨¹ (Asset Tree) æ§‹å»º\n*   5.3 æ­å¼é¸æ“‡æ¬ŠäºŒå…ƒæ¨¹ (European Options)\n*   5.4 ç¾Žå¼é¸æ“‡æ¬ŠäºŒå…ƒæ¨¹ (American Options) èˆ‡æå‰è¡Œæ¬Š\n*   5.5 äºŒå…ƒæ¨¹æ­¥æ•¸ (Steps) å°æ”¶æ–‚æ€§çš„å½±éŸ¿\n*   5.6 å…¶ä»–äºŒå…ƒæ¨¹è®Šé«”èˆ‡æ“´å±•\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\näºŒå…ƒæ¨¹æ¨¡åž‹ï¼ˆBinomial Tree Modelï¼‰æ˜¯è¡ç”Ÿå“å®šåƒ¹ä¸­æœ€é‡è¦çš„é›¢æ•£æ™‚é–“æ¨¡åž‹ã€‚å®ƒä¸åƒ…åœ¨ç†è«–ä¸Šæ­ç¤ºäº†é¢¨éšªä¸­æ€§å®šåƒ¹èˆ‡ç„¡å¥—åˆ©åŽŸç†ï¼Œæ›´åœ¨å¯¦å‹™ä¸Šæˆç‚ºè™•ç†ã€Œç¾Žå¼é¸æ“‡æ¬Šã€æå‰è¡Œæ¬Šå•é¡Œçš„é¦–é¸å·¥å…·ã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   ç†è§£å¦‚ä½•å°‡æ³¢å‹•çŽ‡ $\\sigma$ æ˜ å°„ç‚ºå‘ä¸Š $(u)$ èˆ‡å‘ä¸‹ $(d)$ çš„è®Šå‹•å¹…åº¦ã€‚\n*   æŽŒæ¡é¢¨éšªä¸­æ€§æ©ŸçŽ‡ ($p$) çš„æŽ¨å°ŽåŠå…¶èˆ‡ç„¡å¥—åˆ©åŽŸç†çš„é—œä¿‚ã€‚\n*   æŽŒæ¡é€†å‘èª˜å°Žï¼ˆBackward Inductionï¼‰åœ¨å®šåƒ¹éŽç¨‹ä¸­çš„æ‡‰ç”¨ã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šè¨ˆç®—å…·æœ‰è¤‡é›œæå‰è¡Œæ¬Šæ¢ä»¶çš„å€‹è‚¡é¸æ“‡æ¬Šåƒ¹å€¼ã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šç†è§£äºŒå…ƒæ¨¹æ­¥æ•¸å¢žåŠ æ™‚ï¼Œå…¶çµæžœå¦‚ä½•è¶¨è¿‘æ–¼ Black-Scholes è§£æžè§£ã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch5_1.py** | å®šç¾©æœŸæ¬Šæç›Šèˆ‡ Payoff å‡½æ•¸ï¼Œæ¼”ç¤ºå¤šç¨®é‡‘èžè¡ç”Ÿå“ç­–ç•¥è¦–è¦ºåŒ–ã€‚ |\n| **B2_Ch5_2.py** | å¯¦ä½œåŸºç¤ŽäºŒé …æ¨¹æ¨¡åž‹ (Binomial Tree) è¨ˆç®—æœŸæ¬Šåƒ¹æ ¼ã€‚ |\n| **B2_Ch5_3.py** | æ¼”ç¤ºäºŒé …æ¨¹æ¨¡åž‹åœ¨ä¸åŒæ­¥æ•¸è¨­å®šä¸‹ï¼ŒæœŸæ¬Šåƒ¹å€¼çš„æ³¢å‹•èˆ‡æ”¶æ–‚ã€‚ |\n| **B2_Ch5_4.py** | å¯¦ä½œäºŒé …æ¨¹æ¨¡åž‹å®šåƒ¹åˆ†æžï¼Œæ¼”ç¤ºæ³¢å‹•çŽ‡å°æœŸæ¬Šåƒ¹å€¼çš„éžç·šæ€§å½±éŸ¿ã€‚ |\n| **B2_Ch5_5.py** | **[å°æ¯”]** äºŒé …æ¨¹æ¨¡åž‹èˆ‡ Black-Scholes è§£æžè§£çš„æ”¶æ–‚æ€§åˆ†æžã€‚ |\n| **B2_Ch5_6.py** | **[æ ¸å¿ƒ]** å¯¦ä½œç¾Žå¼æœŸæ¬ŠäºŒé …æ¨¹å®šåƒ¹æ¨¡åž‹ï¼Œåˆ†æžæå‰è¡Œæ¬Šé‚Šç•Œã€‚ |\n| **B2_Ch5_7.py** | æ¼”ç¤ºäºŒé …æ¨¹æ¨¡åž‹åœ¨åŒ…å«ç´…åˆ© (Dividend Yield) ä¸‹çš„å®šåƒ¹èª¿æ•´ã€‚ |\n| **B2_Ch5_8.py** | å¯¦ä½œå¤šåƒæ•¸æ•æ„Ÿæ€§åˆ†æžï¼Œç¹ªè£½æœŸæ¬Šåƒ¹å€¼èˆ‡åƒæ•¸é—œä¿‚åœ–ã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 5.2 æ¨™çš„ç‰©äºŒå…ƒæ¨¹\näºŒå…ƒæ¨¹çš„æ§‹å»ºåŸºæ–¼è³‡ç”¢åƒ¹æ ¼åœ¨ $\\Delta t$ æ™‚é–“å¾Œåƒ…æœ‰å…©ç¨®å¯èƒ½ï¼š$Su$ æˆ– $Sd$ã€‚\n- $u = e^{\\sigma \\sqrt{\\Delta t}}$\n- $d = 1/u$\n- é¢¨éšªä¸­æ€§æ©ŸçŽ‡ $p = \\frac{e^{r\\Delta t} - d}{u - d}$\n\n### 5.4 ç¾Žå¼é¸æ“‡æ¬Šèˆ‡æå‰è¡Œæ¬Š\né€™æ˜¯äºŒå…ƒæ¨¹å„ªæ–¼ BSM å…¬å¼ä¹‹è™•ã€‚åœ¨æ¯å€‹ç¯€é»žï¼Œæˆ‘å€‘æ¯”è¼ƒï¼š\n1.  **ç¹¼çºŒæŒæœ‰åƒ¹å€¼**ï¼šå¾ŒçºŒç¯€é»žåƒ¹å€¼çš„æŠ˜ç¾æœŸæœ›å€¼ã€‚\n2.  **ç«‹å³è¡Œæ¬Šåƒ¹å€¼**ï¼š$S - K$ (Call) æˆ– $K - S$ (Put)ã€‚\nå–å…©è€…å¤§è€…ä½œç‚ºè©²ç¯€é»žçš„æœ€çµ‚åƒ¹å€¼ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\n### ðŸ“„ B2_Ch5_2.py - åŸºç¤ŽäºŒé …æ¨¹å‡½æ•¸\n- **ä¸»è¦å‡½æ•¸**ï¼š`Binomialtree()`\n- **å¯¦ä½œé‡é»ž**ï¼šå¯¦ä½œé€†å‘éžè¿´ç®—æ³•ã€‚åœ¨ä½¿ç”¨æ•¸å€¼å¾®åˆ†è¨ˆç®—å¸Œè‡˜å­—æ¯æ™‚ï¼Œéœ€æ³¨æ„æ­¥é•·å°ç²¾åº¦çš„å½±éŸ¿ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šé¢¨éšªä¸­æ€§æ©ŸçŽ‡ã€æ™‚é–“åƒ¹å€¼ã€ç„¡å¥—åˆ©åŽŸç†ã€‚\n\n### ðŸ“„ B2_Ch5_5.py - æ¨¡åž‹æ”¶æ–‚æ€§\n- **å¯¦ä½œé‡é»ž**ï¼šåŒæ™‚è¨ˆç®— `Binomialtree()` èˆ‡ `option_analytical()` (BSM)ã€‚\n- **æŠ€è¡“ç´°ç¯€**ï¼šé€éŽå¢žåŠ  Steps Nï¼Œè§€å¯Ÿé›¢æ•£æ¨¡åž‹çµæžœå¦‚ä½•æ“ºå‹•ä¸¦æœ€çµ‚æ”¶æ–‚è‡³é€£çºŒæ¨¡åž‹è§£ã€‚\n\n### ðŸ“„ B2_Ch5_6.py - ç¾Žå¼æœŸæ¬Šæ¼”ç®—æ³•\n- **å¯¦ä½œé‡é»ž**ï¼šåœ¨é€†å‘èª˜å°Žä¸­åŠ å…¥ `max(intrinsic_value, option_value)` é‚è¼¯ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šç¾Žå¼æœŸæ¬Šæå‰è¡Œæ¬Š (Early Exercise) çš„æœ€å„ªæ±ºç­–ã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- äºŒå…ƒæ¨¹æä¾›äº†ä¸€å€‹ç›´è¦ºçš„æ¡†æž¶ä¾†è§€å¯ŸæœŸæ¬Šåƒ¹å€¼çš„éš¨æ™‚é–“èˆ‡åƒ¹æ ¼è®Šå‹•çš„æ¼”åŒ–ã€‚\n- å°æ–¼é›¢æ•£äº‹ä»¶ï¼ˆå¦‚åˆ†ç´…ï¼‰æˆ–è¤‡é›œå¥‘ç´„ï¼ˆå¦‚ç¾Žå¼ï¼‰ï¼ŒäºŒå…ƒæ¨¹æ¯”è§£æžå…¬å¼æ›´å…·å½ˆæ€§ã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 6 ç«  BSM å®šåƒ¹ï¼ˆé€£çºŒæ¥µé™æƒ…æ³ï¼‰ã€ç¬¬ 7 ç« å¸Œè‡˜å­—æ¯ï¼ˆæ•æ„Ÿåº¦åˆ†æžï¼‰ã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Cox, Ross, & Rubinstein (1979) åŽŸå§‹è«–æ–‡*ã€‚\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch5*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "5.1 B2_Ch5_1.py",
        "filename": "B2_Ch5_1.py",
        "code": "# B2_Ch5_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef generic_payoff(buy_or_sell, put_call_indicator, strike, spot):\n    payoff = buy_or_sell*np.maximum(put_call_indicator*(spot - strike),0)\n    return payoff\n\ndef generic_pnl(buy_or_sell, put_call_indicator, strike, spot, premium):\n    pnl = buy_or_sell*np.maximum(put_call_indicator*(spot - strike),0) - buy_or_sell*premium\n    return pnl\n\ndef plot_decor(x, y, y_label):\n    plt.figure()\n    plt.plot(x, y)\n    plt.xlabel('S, spot price of underlying at expiration', fontsize=8)\n    plt.ylabel(y_label,fontsize=8) \n    plt.gca().set_aspect(1)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)\n    plt.gca().spines['left'].set_position(('data',0))\n    plt.gca().spines['bottom'].set_position(('data',0))\n\n    plt.axvline(x=strike, linestyle='--', color='r', linewidth = .5)\n\n    plt.xticks(np.arange(0, 200, step=20))\n    plt.yticks(np.arange(np.floor(np.min(pay_off)/10.0)*10.0, np.ceil(np.max(pay_off)/10.0)*10.0, step=20))\n    plt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\n\nput_call_indicator = 1; \n# 1 for call; -1 for put\nbuy_or_sell = 1;\n# 1 for buy ;-1 for sell\nstrike = 100 \nspot = np.arange(0,200,1)\npremium = 10 \n\n# long a call\n\npay_off = generic_payoff(buy_or_sell,put_call_indicator,strike,spot)\ny_label = 'Payoff';\nplot_decor(spot, pay_off, y_label)\n\npnl = generic_pnl(buy_or_sell,put_call_indicator,strike,spot,premium)\ny_label = 'PnL';\nplot_decor(spot, pnl, y_label)\n\n# short a call\n\nput_call_indicator = 1; \nbuy_or_sell = -1;\npay_off = generic_payoff(buy_or_sell,put_call_indicator,strike,spot)\ny_label = 'Pay off';\nplot_decor(spot, pay_off, y_label)\n\npnl = generic_pnl(buy_or_sell,put_call_indicator,strike,spot,premium)\ny_label = 'PnL';\nplot_decor(spot, pnl, y_label)\n\n# long a put\n\nput_call_indicator = -1; \nbuy_or_sell = 1;\npay_off = generic_payoff(buy_or_sell,put_call_indicator,strike,spot)\ny_label = 'Pay off';\nplot_decor(spot, pay_off, y_label)\n\npnl = generic_pnl(buy_or_sell,put_call_indicator,strike,spot,premium)\ny_label = 'PnL';\nplot_decor(spot, pnl, y_label)\n\n# short a put\n\nput_call_indicator = -1; \nbuy_or_sell = -1;\npay_off = generic_payoff(buy_or_sell,put_call_indicator,strike,spot)\ny_label = 'Pay off';\nplot_decor(spot, pay_off, y_label)\n\npnl = generic_pnl(buy_or_sell,put_call_indicator,strike,spot,premium)\ny_label = 'PnL';\nplot_decor(spot, pnl, y_label)\n"
      },
      {
        "id": "ex2",
        "title": "5.2 B2_Ch5_2.py",
        "filename": "B2_Ch5_2.py",
        "code": "# B2_Ch5_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.special\n\ndef Binomialtree(n, S0, K, r, vol, t, PutCall, EuropeanAmerican):  \n    deltaT = t/n \n    u = np.exp(vol*np.sqrt(deltaT))\n    d = 1./u\n    p = (np.exp(r*deltaT)-d) / (u-d) \n \n    #Binomial tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]     \n    \n    scatter_x_stock = [0.0]\n    scatter_y_stock = [stockvalue[0,0]]\n    scatter_prob_stock = [1.0]\n       \n    plt.figure(1)\n    \n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            \n            x_stock_tree_u = [(i-1)*deltaT]\n            x_stock_tree_d = [(i-1)*deltaT]\n            y_stock_tree_upper = [stockvalue[i-1,j-1]]\n            y_stock_tree_lower = [stockvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT                  \n            y_temp1 = stockvalue[i,j-1]\n            y_temp3 = stockvalue[i,j]\n            \n            x_stock_tree_u.append(x_temp)\n            x_stock_tree_d.append(x_temp)\n            scatter_x_stock.append(i*deltaT)\n                        \n            y_stock_tree_lower.append(y_temp1)\n            y_stock_tree_upper.append(y_temp3)\n            scatter_y_stock.append(stockvalue[i,j-1])\n            \n            temp_prob = scipy.special.comb(i, j - 1, exact=True)*p**(j - 1)*(1 - p)**(i-j+1)\n            scatter_prob_stock.append(temp_prob)\n                       \n            plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'b-',linewidth=0.4)\n            plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'b-',linewidth=0.4)\n            \n      \n        temp_prob = scipy.special.comb(i, j, exact=True)*p**(j)*(1 - p)**(i-j)\n        scatter_prob_stock.append(temp_prob)    \n        scatter_x_stock.append(i*deltaT)\n        scatter_y_stock.append(stockvalue[i,j])\n    \n    colors = scatter_prob_stock\n    plt.scatter(np.array(scatter_x_stock),np.array(scatter_y_stock),c=colors,alpha=0.5,cmap ='RdBu_r')\n    plt.xlabel('Time (year)',fontsize=8)\n    plt.ylabel('Underlying price',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)\n    plt.colorbar()\n\n    plt.figure(2)\n    plt.stem(scatter_y_stock[len(scatter_y_stock)-n-1::],scatter_prob_stock[len(scatter_y_stock)-n-1::])\n    plt.xlabel('Underlying price, T = 1 year',fontsize=8)\n    plt.ylabel('Prob',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)\n           \n    return optionvalue[0,0]\n\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nK = 55   #strike price\nvol = 0.3 #volatility\n\nt = 1.0\ny = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"European\")\n"
      },
      {
        "id": "ex3",
        "title": "5.3 B2_Ch5_3.py",
        "filename": "B2_Ch5_3.py",
        "code": "# B2_Ch5_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.special\n\ndef Binomialtree(n, S0, K, r, vol, t, PutCall, EuropeanAmerican):  \n    deltaT = t/n \n    u = np.exp(vol*np.sqrt(deltaT))\n    d = 1./u\n    p = (np.exp(r*deltaT)-d) / (u-d) \n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]        \n    \n    scatter_x_option = [0.0]\n    scatter_y_option = [optionvalue[0,0]]\n    scatter_prob_option = [1.0]             \n            \n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            x_option_tree_u = [(i-1)*deltaT]\n            x_option_tree_d = [(i-1)*deltaT]\n            y_option_tree_upper = [optionvalue[i-1,j-1]]\n            y_option_tree_lower = [optionvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT\n            \n            y_temp1 = optionvalue[i,j-1]\n            y_temp3 = optionvalue[i,j]\n            \n            x_option_tree_u.append(x_temp)\n            x_option_tree_d.append(x_temp)\n            scatter_x_option.append(i*deltaT)\n                        \n            y_option_tree_upper.append(y_temp1)\n            y_option_tree_lower.append(y_temp3)\n            scatter_y_option.append(optionvalue[i,j-1])\n            temp_prob = scipy.special.comb(i, j - 1, exact=True)*p**(j - 1)*(1 - p)**(i-j+1)\n\n            scatter_prob_option.append(temp_prob) \n        \n        temp_prob = scipy.special.comb(i, j, exact=True)*p**(j)*(1 - p)**(i-j)\n        scatter_prob_option.append(temp_prob)    \n        scatter_x_option.append(i*deltaT)\n        scatter_y_option.append(optionvalue[i,j])\n    \n    option_T_level = np.array(scatter_y_option[len(scatter_y_option)-n-1::])\n    option_T_prob = scatter_prob_option[len(scatter_y_option)-n-1::]\n    a1, c1 = np.unique(option_T_level, return_inverse=True)\n    A1 = np.bincount(c1,option_T_prob)\n    \n    plt.figure()\n    plt.stem(a1, A1)\n    plt.xlabel('Option price, T = 1 year',fontsize=8)\n    plt.ylabel('Prob',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)\n           \n    return optionvalue[0,0]\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nK = 55   #strike price\nvol = 0.3 #volatility\n\nt = 1.0\ny = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"European\")\n"
      },
      {
        "id": "ex4",
        "title": "5.4 B2_Ch5_4.py",
        "filename": "B2_Ch5_4.py",
        "code": "# B2_Ch5_4.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.special\n\ndef Binomialtree(n, S0, K, r, vol, t, PutCall, EuropeanAmerican):  \n    deltaT = t/n \n    u = np.exp(vol*np.sqrt(deltaT))\n    d = 1./u\n    p = (np.exp(r*deltaT)-d) / (u-d) \n    \n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]     \n       \n    scatter_x_option = [0.0]\n    scatter_y_option = [optionvalue[0,0]]\n    scatter_prob_option = [1.0]     \n    plt.figure()        \n            \n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            x_option_tree_u = [(i-1)*deltaT]\n            x_option_tree_d = [(i-1)*deltaT]\n            y_option_tree_upper = [optionvalue[i-1,j-1]]\n            y_option_tree_lower = [optionvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT\n            \n            y_temp1 = optionvalue[i,j-1]\n            y_temp3 = optionvalue[i,j]\n            \n            x_option_tree_u.append(x_temp)\n            x_option_tree_d.append(x_temp)\n            scatter_x_option.append(i*deltaT)\n                        \n            y_option_tree_upper.append(y_temp1)\n            y_option_tree_lower.append(y_temp3)\n            scatter_y_option.append(optionvalue[i,j-1])\n            temp_prob = scipy.special.comb(i, j - 1, exact=True)*p**(j - 1)*(1 - p)**(i-j+1)\n\n            scatter_prob_option.append(temp_prob)\n            \n            plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'b-',linewidth=0.5)\n            plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'b-',linewidth=0.5)\n        \n        temp_prob = scipy.special.comb(i, j, exact=True)*p**(j)*(1 - p)**(i-j)\n        scatter_prob_option.append(temp_prob)    \n        scatter_x_option.append(i*deltaT)\n        scatter_y_option.append(optionvalue[i,j])\n    \n    colors = scatter_prob_option\n    plt.scatter(np.array(scatter_x_option),np.array(scatter_y_option),c=colors,alpha=0.5,cmap ='RdBu_r') \n    plt.xlabel('Time (year)',fontsize=8)\n    if  PutCall==\"Put\":\n        plt.ylabel('Put option price',fontsize=8)\n    else: \n        plt.ylabel('Call option price',fontsize=8)\n        \n    # plt.gca().set_aspect(1)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)\n    plt.colorbar()\n           \n    return optionvalue[0,0]\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nK = 55   #strike price\nvol = 0.3 #volatility\nt = 1.0\ny = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"American\")\ny = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Put\", EuropeanAmerican=\"American\")"
      },
      {
        "id": "ex5",
        "title": "5.5 B2_Ch5_5.py",
        "filename": "B2_Ch5_5.py",
        "code": "# B2_Ch5_5.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef Binomialtree(n, S0, K, r, q, vol, t, PutCall, EuropeanAmerican):  \n    deltaT = t/n \n    u = np.exp(vol*np.sqrt(deltaT))\n    d = 1./u\n    p = (np.exp((r-q)*deltaT)-d) / (u-d) \n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]\n        \n    return optionvalue[0,0]    \n\ndef option_analytical(S0, vol, r, q, t, K, PutCall):\n    d1 = (np.log(S0 / K) + (r - q + 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    d2 = (np.log(S0 / K) + (r - q - 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    \n    price =  PutCall*S0 * np.exp(-q * t) * norm.cdf(PutCall*d1, 0.0, 1.0) - PutCall* K * np.exp(-r * t) * norm.cdf(PutCall*d2, 0.0, 1.0)  \n        \n    return price\n\n    # Inputs\nn= 2   #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.03  #risk-free interest rate\nq = 0.0 # dividend yield\nK = 55   #strike price\nvol = 0.3 #volatility\nt = 2.0\nPutCall = 1 # 1 for call;-1 for put\n\nbs_price = option_analytical(S0, vol, r, q, t, K, PutCall=1)\nprint('analytical Price: %.4f' % bs_price)\n\nn= range(2, 1012, 10)\nprices = np.array([Binomialtree(x, S0, K, r, q, vol, t, PutCall=\"Call\", EuropeanAmerican=\"European\") for x in n])\ndiscrepancy = (prices/bs_price -1)/0.01 \n\nplt.figure()\nplt.plot(n, prices,\"-o\",markersize = 2)\nplt.plot([0,1012],[bs_price, bs_price], \"r-\", lw=2, alpha=0.6)\nplt.xlabel(\"Number of steps\")\nplt.ylabel(\"Call option price, C (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.figure()\nplt.plot(n, discrepancy,\"-o\",markersize = 2)\nplt.xlabel(\"Number of steps\")\nplt.ylabel(\"Discrepancy (%)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nbs_price = option_analytical(S0, vol, r, q, t, K, PutCall=-1)\nprint('analytical Price: %.4f' % bs_price)\n\nn= range(2, 1012, 10)\nprices = np.array([Binomialtree(x, S0, K, r, q, vol, t, PutCall=\"Put\", EuropeanAmerican=\"European\") for x in n])\ndiscrepancy = (prices/bs_price -1)/0.01 \n\nplt.figure()\nplt.plot(n, prices,\"-o\",markersize = 2)\nplt.plot([0,1012],[bs_price, bs_price], \"r-\", lw=2, alpha=0.6)\nplt.xlabel(\"Number of steps\")\nplt.ylabel(\"Put option price, C (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.figure()\nplt.plot(n, discrepancy,\"-o\",markersize = 2)\nplt.xlabel(\"Number of steps\")\nplt.ylabel(\"Discrepancy (%)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)"
      },
      {
        "id": "ex6",
        "title": "5.6 B2_Ch5_6.py",
        "filename": "B2_Ch5_6.py",
        "code": "# B2_Ch5_6.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef Binomialtree(n, S0, K, r, vol, t, PutCall, EuropeanAmerican,Tree):  \n    deltaT = t/n \n    if Tree == 'CRR':\n        u = np.exp(vol*np.sqrt(deltaT))\n        d = 1./u\n        p = (np.exp(r*deltaT)-d) / (u-d) \n    elif Tree == 'JD':\n        u = np.exp((r - vol**2*0.5)*deltaT + vol*np.sqrt(deltaT))\n        d = np.exp((r - vol**2*0.5)*deltaT - vol*np.sqrt(deltaT))\n        p = 0.5  \n    elif Tree =='LR':\n        def  h_function(z,n):\n            h = 0.5+np.sign(z)*np.sqrt(0.25-0.25*np.exp(-((z/(n+1/3+0.1/(n+1)))**2)*(n+1/6)))\n            return h\n        \n        if np.mod(n,2)>0:\n            n_bar = n\n        else:\n            n_bar = n + 1\n        \n        d1 = (np.log(S0/K)+(r+vol**2/2)*t)/vol/np.sqrt(t);\n        d2 = (np.log(S0/K)+(r-vol**2/2)*t)/vol/np.sqrt(t);\n        pbar = h_function(d1,n_bar)\n        p = h_function(d2,n_bar)\n        u = np.exp(r*deltaT)*pbar/p\n        d = (np.exp(r*deltaT)-p*u)/(1-p)  \n            \n    else:\n        print(\"Tree type not supported\")\n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]     \n    \n    scatter_x_stock = [0.0]\n    scatter_y_stock = [stockvalue[0,0]]\n    \n    plt.figure(1)\n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            \n            x_stock_tree_u = [(i-1)*deltaT]\n            x_stock_tree_d = [(i-1)*deltaT]\n            y_stock_tree_upper = [stockvalue[i-1,j-1]]\n            y_stock_tree_lower = [stockvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT \n            y_temp1 = stockvalue[i,j-1]\n            y_temp3 = stockvalue[i,j]\n            \n            x_stock_tree_u.append(x_temp)\n            x_stock_tree_d.append(x_temp)\n            scatter_x_stock.append(i*deltaT)\n                        \n            y_stock_tree_lower.append(y_temp1)\n            y_stock_tree_upper.append(y_temp3)\n            scatter_y_stock.append(stockvalue[i,j-1])\n                      \n            if Tree == 'CRR':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'b-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'b-o',linewidth=0.4,markersize = 2)\n            elif Tree == 'JD':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'r-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'r-o',linewidth=0.4,markersize = 2)\n            elif Tree == 'LR':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'r-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'r-o',linewidth=0.4,markersize = 2)    \n            else:\n                print(\"Tree type not supported\")  \n    \n    plt.xlabel('Time (year)',fontsize=8)\n    plt.ylabel('Underlying price',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)    \n\n    plt.figure(2)\n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            x_option_tree_u = [(i-1)*deltaT]\n            x_option_tree_d = [(i-1)*deltaT]\n            y_option_tree_upper = [optionvalue[i-1,j-1]]\n            y_option_tree_lower = [optionvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT\n            \n            y_temp1 = optionvalue[i,j-1]\n            y_temp3 = optionvalue[i,j]\n            \n            x_option_tree_u.append(x_temp)\n            x_option_tree_d.append(x_temp)\n                             \n            y_option_tree_upper.append(y_temp1)\n            y_option_tree_lower.append(y_temp3)\n            \n            if Tree == 'CRR':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'b-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'b-o',linewidth=0.5,markersize = 2)\n            elif Tree == 'JD':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'r-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'r-o',linewidth=0.5,markersize = 2)\n            elif Tree == 'LR':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'r-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'r-o',linewidth=0.5,markersize = 2)    \n            else:\n                print(\"Tree type not supported\") \n    \n    plt.xlabel('Time (year)',fontsize=8)\n    if PutCall==\"Put\":\n        plt.ylabel('Put option price',fontsize=8)    \n    else:\n        plt.ylabel('Call option price',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)             \n           \n    return optionvalue[0,0]\n\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nK = 55   #strike price\nvol = 0.3 #volatility\nt = 1.0\n\ny1 = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"American\",Tree = 'CRR')\ny2 = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"American\",Tree = 'JD')\n"
      },
      {
        "id": "ex7",
        "title": "5.7 B2_Ch5_7.py",
        "filename": "B2_Ch5_7.py",
        "code": "# B2_Ch5_7.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef Binomialtree(n, S0, K, r, vol, t, PutCall, EuropeanAmerican,Tree):  \n    deltaT = t/n \n    if Tree == 'CRR':\n        u = np.exp(vol*np.sqrt(deltaT))\n        d = 1./u\n        p = (np.exp(r*deltaT)-d) / (u-d) \n    elif Tree == 'JD':\n        u = np.exp((r - vol**2*0.5)*deltaT + vol*np.sqrt(deltaT))\n        d = np.exp((r - vol**2*0.5)*deltaT - vol*np.sqrt(deltaT))\n        p = 0.5  \n    elif Tree =='LR':\n        def  h_function(z,n):\n            h = 0.5+np.sign(z)*np.sqrt(0.25-0.25*np.exp(-((z/(n+1/3+0.1/(n+1)))**2)*(n+1/6)))\n            return h\n        \n        if np.mod(n,2)>0:\n            n_bar = n\n        else:\n            n_bar = n + 1\n        \n        d1 = (np.log(S0/K)+(r+vol**2/2)*t)/vol/np.sqrt(t);\n        d2 = (np.log(S0/K)+(r-vol**2/2)*t)/vol/np.sqrt(t);\n        pbar = h_function(d1,n_bar)\n        p = h_function(d2,n_bar)\n        u = np.exp(r*deltaT)*pbar/p\n        d = (np.exp(r*deltaT)-p*u)/(1-p)  \n            \n    else:\n        print(\"Tree type not supported\")\n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]     \n    \n    scatter_x_stock = [0.0]\n    scatter_y_stock = [stockvalue[0,0]]\n    \n    plt.figure(1)\n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            \n            x_stock_tree_u = [(i-1)*deltaT]\n            x_stock_tree_d = [(i-1)*deltaT]\n            y_stock_tree_upper = [stockvalue[i-1,j-1]]\n            y_stock_tree_lower = [stockvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT \n            y_temp1 = stockvalue[i,j-1]\n            y_temp3 = stockvalue[i,j]\n            \n            x_stock_tree_u.append(x_temp)\n            x_stock_tree_d.append(x_temp)\n            scatter_x_stock.append(i*deltaT)\n                        \n            y_stock_tree_lower.append(y_temp1)\n            y_stock_tree_upper.append(y_temp3)\n            scatter_y_stock.append(stockvalue[i,j-1])\n                      \n            if Tree == 'CRR':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'b-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'b-o',linewidth=0.4,markersize = 2)\n            elif Tree == 'JD':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'r-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'r-o',linewidth=0.4,markersize = 2)\n            elif Tree == 'LR':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'r-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'r-o',linewidth=0.4,markersize = 2)    \n            else:\n                print(\"Tree type not supported\")  \n    \n    plt.xlabel('Time (year)',fontsize=8)\n    plt.ylabel('Underlying price',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)    \n\n    plt.figure(2)\n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            x_option_tree_u = [(i-1)*deltaT]\n            x_option_tree_d = [(i-1)*deltaT]\n            y_option_tree_upper = [optionvalue[i-1,j-1]]\n            y_option_tree_lower = [optionvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT\n            \n            y_temp1 = optionvalue[i,j-1]\n            y_temp3 = optionvalue[i,j]\n            \n            x_option_tree_u.append(x_temp)\n            x_option_tree_d.append(x_temp)\n                             \n            y_option_tree_upper.append(y_temp1)\n            y_option_tree_lower.append(y_temp3)\n            \n            if Tree == 'CRR':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'b-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'b-o',linewidth=0.5,markersize = 2)\n            elif Tree == 'JD':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'r-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'r-o',linewidth=0.5,markersize = 2)\n            elif Tree == 'LR':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'r-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'r-o',linewidth=0.5,markersize = 2)    \n            else:\n                print(\"Tree type not supported\") \n    \n    plt.xlabel('Time (year)',fontsize=8)\n    if PutCall==\"Put\":\n        plt.ylabel('Put option price',fontsize=8)    \n    else:\n        plt.ylabel('Call option price',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)             \n           \n    return optionvalue[0,0]\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nK = 55   #strike price\nvol = 0.3 #volatility\nt = 1.0\n\ny1 = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"American\",Tree = 'CRR')\ny2 = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"American\",Tree = 'LR')"
      },
      {
        "id": "ex8",
        "title": "5.8 B2_Ch5_8.py",
        "filename": "B2_Ch5_8.py",
        "code": "# B2_Ch5_8.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef option_analytical(S0, vol, r, q, t, K, PutCall):\n    d1 = (np.log(S0 / K) + (r - q + 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    d2 = (np.log(S0 / K) + (r - q - 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    price =  PutCall*S0 * np.exp(-q * t) * norm.cdf(PutCall*d1, 0.0, 1.0) - PutCall* K * np.exp(-r * t) * norm.cdf(PutCall*d2, 0.0, 1.0)  \n        \n    return price\n\n\ndef Binomialtree(n, S0, K, r, q, vol, t, PutCall, EuropeanAmerican,Tree):  \n    deltaT = t/n \n    if Tree == 'CRR':\n        u = np.exp(vol*np.sqrt(deltaT))\n        d = 1./u\n        p = (np.exp((r - q)*deltaT)-d) / (u-d) \n    elif Tree == 'JD':\n        u = np.exp((r - q - vol**2*0.5)*deltaT + vol*np.sqrt(deltaT))\n        d = np.exp((r - q - vol**2*0.5)*deltaT - vol*np.sqrt(deltaT))\n        p = 0.5  \n    elif Tree =='LR':\n        def  h_function(z,n):\n            h = 0.5+np.sign(z)*np.sqrt(0.25-0.25*np.exp(-((z/(n+1/3+0.1/(n+1)))**2)*(n+1/6)))\n            return h\n        \n        if np.mod(n,2)>0:\n            n_bar = n\n        else:\n            n_bar = n + 1\n        \n        d1 = (np.log(S0/K)+(r-q+vol**2/2)*t)/vol/np.sqrt(t);\n        d2 = (np.log(S0/K)+(r-q-vol**2/2)*t)/vol/np.sqrt(t);\n        pbar = h_function(d1,n_bar)\n        p = h_function(d2,n_bar)\n        u = np.exp((r-q)*deltaT)*pbar/p\n        d = (np.exp((r-q)*deltaT)-p*u)/(1-p)    \n            \n    else:\n        print(\"Tree type not supported\")\n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]     \n                    \n    return optionvalue[0,0]\n\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nq = 0.0 #dividend yield\nK = 55   #strike price\nvol = 0.3 #volatility\nt = 1.0\n\nbs_price = option_analytical(S0, vol, r, q, t, K, PutCall=1)\nprint('analytical Price: %.4f' % bs_price)\n\nn= range(5, 300, 1)\nprices_crr = np.array([Binomialtree(x, S0, K, r, q, vol, t, PutCall=\"Call\", EuropeanAmerican=\"European\",Tree = 'CRR') for x in n])\ndiscrepancy_crr = (prices_crr/bs_price -1)/0.01 \n\nplt.figure()\nplt.plot(n, prices_crr,\"b-\",label='CRR',lw = 1)\n\nplt.plot([5,300],[bs_price, bs_price], \"r-\", label='BSM',lw=1, alpha=0.6)\nplt.xlabel(\"Number of steps\")\nplt.ylabel(\"Call option price, C (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nn= range(5, 300, 2)\nprices_lr = np.array([Binomialtree(x, S0, K, r, q, vol, t, PutCall=\"Call\", EuropeanAmerican=\"European\",Tree = 'LR') for x in n])\ndiscrepancy_lr = (prices_lr/bs_price -1)/0.01 \n\nplt.plot(n, prices_lr,\"k-\", label='LR',lw = 1)\nplt.legend(loc='upper center')\n"
      }
    ]
  },
  {
    "id": "b2_ch6",
    "title": "ç¬¬6ç« ï¼šBSMé¸æ“‡æ¬Šå®šåƒ¹",
    "number": 6,
    "content": {
      "intro": "# ç¬¬ 6 ç« ï¼šBSM é¸æ“‡æ¬Šå®šåƒ¹ - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   6.1 Black-Scholes-Merton (BSM) æ¨¡åž‹\n*   6.2 æ™‚é–“åƒ¹å€¼ (Time Value) èˆ‡å…§åœ¨åƒ¹å€¼ (Intrinsic Value)\n*   6.3 å˜‰æ›¼-ç§‘çˆ¾å“ˆæ ¹æ¨¡åž‹ (Garman-Kohlhagen) èˆ‡å¤–åŒ¯é¸æ“‡æ¬Š\n*   6.4 æœŸè²¨é¸æ“‡æ¬Š (Black æ¨¡åž‹) èˆ‡å‚µåˆ¸é¸æ“‡æ¬Š\n*   6.5 æ•¸ä½é¸æ“‡æ¬Š (Digital Options) / äºŒå…ƒé¸æ“‡æ¬Š\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\nBlack-Scholes-Merton æ¨¡åž‹æ˜¯ç¾ä»£é‡‘èžç†è«–çš„åŸºçŸ³ã€‚æœ¬ç« æ·±å…¥æŽ¢è¨Ž BSM æ¨¡åž‹åœ¨ä¸åŒè³‡ç”¢é¡žåˆ¥ï¼ˆè‚¡ç¥¨ã€å¤–åŒ¯ã€æœŸè²¨ï¼‰ä¸Šçš„æ‡‰ç”¨ï¼Œä¸¦æŽ¢è¨Žäº†ç¾é‡‘æˆ–ç„¡åƒ¹å€¼ï¼ˆCash-or-Nothingï¼‰ç­‰å¥‡ç•°é¸æ“‡æ¬Šçš„å®šåƒ¹é‚è¼¯ã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   æŽŒæ¡ BSM æ¨¡åž‹ä¸­ $d_1$ èˆ‡ $d_2$ çš„æ©ŸçŽ‡æ„ç¾©èˆ‡è¨ˆç®—ã€‚\n*   æŽŒæ¡å¸¸æ…‹åˆ†ä½ˆç´¯ç©å‡½æ•¸ $N(d_2)$ åœ¨é¢¨éšªä¸­æ€§æ©ŸçŽ‡ä¸­çš„è§’è‰²ã€‚\n*   ç†è§£å¤–åŒ¯ã€æœŸè²¨èˆ‡è‚¡ç¥¨é¸æ“‡æ¬Šå®šåƒ¹å…¬å¼åœ¨ã€ŒæŒæœ‰æˆæœ¬ã€ï¼ˆCost of Carryï¼‰ä¸Šçš„ç´°å¾®å·®ç•°ã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šåœ¨æœŸæ¬Šäº¤æ˜“ä¸­ï¼Œå¿«é€Ÿè¨ˆç®—éš±å«æ³¢å‹•çŽ‡èˆ‡ç†è«–åƒ¹å€¼çš„åå·®ã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šæŽŒæ¡ BSM æ¨¡åž‹çš„äº”å¤§å‡è¨­åŠå…¶åœ¨æ¥µç«¯å¸‚å ´ï¼ˆå¦‚é»‘å¤©éµäº‹ä»¶ï¼‰ä¸‹çš„å±€é™æ€§ã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch6_1.py** | **[æ ¸å¿ƒ]** å¯¦ä½œæ­å¼æœŸæ¬Š Black-Scholes è§£æžè§£å®šåƒ¹èˆ‡åœ–è¡¨åˆ†æžã€‚ |\n| **B2_Ch6_2.py** | æ¼”ç¤ºæ¨™çš„åƒ¹æ ¼è®Šå‹•å°æœŸæ¬Šåƒ¹å€¼çš„éžç·šæ€§å½±éŸ¿ã€‚ |\n| **B2_Ch6_3.py** | åˆ©ç”¨äºŒé …æ¨¹æ¨¡åž‹è¼”åŠ©åˆ†æžï¼Œæ¼”ç¤º Delta é¢¨éšªç®¡ç†èˆ‡é›¢æ•£å°æ¯”ã€‚ |\n| **B2_Ch6_4.py** | å¯¦ä½œæœŸæ¬Šè§£æžè§£å…¬å¼ï¼Œæ¼”ç¤º SciPy çµ±è¨ˆåˆ†ä½ˆå‡½æ•¸çš„æ‡‰ç”¨ã€‚ |\n| **B2_Ch6_5.py** | **[å¥‡ç•°]** å¯¦ä½œç¾é‡‘æˆ–ç„¡åƒ¹å€¼ (Cash-or-Nothing) äºŒå…ƒæœŸæ¬Šå®šåƒ¹ã€‚ |\n| **B2_Ch6_6.py** | æ¼”ç¤ºæ³¢å‹•çŽ‡å°æœŸæ¬Šåƒ¹å€¼çš„å½±éŸ¿ï¼Œç¹ªè£½æ³¢å‹•çŽ‡ Vega æ›²ç·šã€‚ |\n| **B2_Ch6_7.py** | **[å¥‡ç•°]** å¯¦ä½œè³‡ç”¢æˆ–ç„¡åƒ¹å€¼ (Asset-or-Nothing) æœŸæ¬Šå®šåƒ¹ã€‚ |\n| **B2_Ch6_8.py** | è¨ˆç®—äºŒå…ƒæœŸæ¬Šçš„ Delta å¸Œè‡˜å­—æ¯èˆ‡é¢¨éšªæš´éœ²ç‰¹æ€§ã€‚ |\n| **B2_Ch6_9.py** | å¯¦ä½œæ­å¼æœŸæ¬Š Delta è¨ˆç®—ï¼Œæ¼”ç¤ºé¢¨éšªå°æ²–åŽŸåž‹ã€‚ |\n| **B2_Ch6_10.py** | å¯¦ä½œè³‡ç”¢æˆ–ç„¡åƒ¹å€¼äºŒå…ƒæœŸæ¬Šè§£æžå®šåƒ¹ï¼Œåˆ†æžæ®–åˆ©çŽ‡å½±éŸ¿ã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 6.1 BSM æ¨¡åž‹\næ­å¼çœ‹æ¼²æœŸæ¬Šåƒ¹æ ¼å…¬å¼ç‚ºï¼š\n$$C = S_0 N(d_1) - K e^{-rT} N(d_2)$$\nå…¶ä¸­ $N(d_1)$ æ˜¯é¢¨éšªä¸­æ€§ä¸‹çš„å°æ²–æ¯”çŽ‡ï¼Œ$N(d_2)$ æ˜¯åˆ°æœŸæ™‚åœ¨åƒ¹å…§ (ITM) çš„æ©ŸçŽ‡ã€‚\n\n### 6.2 åƒ¹å€¼çµ„æˆ\n- **å…§åœ¨åƒ¹å€¼**ï¼šç«‹å³è¡Œæ¬Šçš„åƒ¹å€¼ $\\max(S-K, 0)$ã€‚\n- **æ™‚é–“åƒ¹å€¼**ï¼šæœŸæ¬Šåƒ¹æ ¼è¶…éŽå…§åœ¨åƒ¹å€¼çš„éƒ¨åˆ†ï¼Œä»£è¡¨æœªä¾†ç²åˆ©çš„å¯èƒ½æ€§ã€‚\n\n### 6.5 æ•¸ä½é¸æ“‡æ¬Š (Digital Options)\nä¸åŒæ–¼æ™®é€šæœŸæ¬Šçš„ç·šæ€§æ”¶ç›Šï¼Œæ•¸ä½æœŸæ¬Šæ˜¯ã€Œå…¨æœ‰æˆ–å…¨ç„¡ã€ã€‚é€™é¡žæœŸæ¬Šåœ¨è¡Œæ¬Šåƒ¹é™„è¿‘å…·æœ‰æ¥µé«˜çš„ Delta å’Œ Gammaï¼Œå°é¢¨éšªç®¡ç†æå‡ºäº†å·¨å¤§æŒ‘æˆ°ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\n### ðŸ“„ B2_Ch6_1.py - BSM è§£æžè§£\n- **ä¸»è¦å‡½æ•¸**ï¼š`option_analytical()`\n- **å¯¦ä½œé‡é»ž**ï¼šå¯¦ä½œæ¨™æº– BSM å…¬å¼ã€‚éœ€æ³¨æ„æ•¸å€¼è¨ˆç®—çš„ç²¾åº¦ï¼Œç‰¹åˆ¥æ˜¯æ™‚é–“ $T$ è¶¨è¿‘æ–¼é›¶æ™‚çš„ç©©å®šæ€§ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šç„¡å¥—åˆ©å®šåƒ¹ã€å°æ•¸æ”¶ç›ŠçŽ‡ã€å¸¸æ…‹åˆ†ä½ˆã€‚\n\n### ðŸ“„ B2_Ch6_5.py - äºŒå…ƒæœŸæ¬Šå¯¦å‹™\n- **ä¸»è¦å‡½æ•¸**ï¼š`cash_or_nothing_analytical()`\n- **å¯¦ä½œé‡é»ž**ï¼šåˆ†æžæ•¸ä½æœŸæ¬Šçš„æ•¸ä½åŒ–æ”¶ç›Šç‰¹å¾µã€‚åœ¨é‡‘èžè¨ˆé‡ä¸­ï¼Œé€™ç¨®æ–·é»žå¼çš„ Payoff å¸¸ç”¨æ–¼é¢¨éšªè­¦ç¤ºæ¨¡åž‹ã€‚\n- **å¯¦å‹™æ³¨æ„**ï¼šè€ƒæ…®æ¥µç«¯å¸‚å ´æƒ…æ³å°åƒ¹æ ¼éšŽæ¢¯çš„å½±éŸ¿ã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- BSM æ¨¡åž‹æä¾›äº†æœŸæ¬Šå®šåƒ¹çš„åŸºæº–èªžè¨€ï¼Œå³ä¾¿å¸‚å ´ä¸å®Œå…¨ç¬¦åˆå…¶å‡è¨­ï¼ŒIV ä»æ˜¯äº¤æ˜“å“¡æºé€šçš„å…±åŒæ¨™æº–ã€‚\n- åªæœ‰ç†è§£äº† BSM çš„ã€ŒæŒæœ‰æˆæœ¬ã€æ¨¡åž‹ï¼Œæ‰èƒ½éˆæ´»æ‡‰ç”¨æ–¼åŒ¯çŽ‡ã€æœŸè²¨èˆ‡æŒ‡æ•¸ã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 5 ç« äºŒå…ƒæ¨¹ï¼ˆé›¢æ•£å°æ¯”ï¼‰ã€ç¬¬ 7 ç« å¸Œè‡˜å­—æ¯ï¼ˆæ•æ„Ÿåº¦åˆ†æžï¼‰ã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Black & Scholes (1973), Merton (1973) åŽŸå§‹è«–æ–‡*ã€‚\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch6*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "6.1 B2_Ch6_1.py",
        "filename": "B2_Ch6_1.py",
        "code": "# B2_Ch6_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef option_analytical(S0, vol, r, q, t, K, PutCall):\n    d1 = (np.log(S0 / K) + (r - q + 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    d2 = (np.log(S0 / K) + (r - q - 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    price =  PutCall*S0 * np.exp(-q * t) * norm.cdf(PutCall*d1, 0.0, 1.0) - PutCall* K * np.exp(-r * t) * norm.cdf(PutCall*d2, 0.0, 1.0)  \n        \n    return price\n\n    # Inputs\nr = 0.03  #risk-free interest rate\nq = 0.0   # dividend yield\nvol = 0.5 #volatility\nt_base = 2.0\nPutCall = 1 # 1 for call;-1 for put\nspot = 50\nK = np.arange(20,80,1)  #strike price\n\nplt.figure(1)\nbs_price_call = option_analytical(spot, vol, r, q, t_base, K, PutCall =  1)\nplt.plot(K, bs_price_call, label='price')\nplt.xlabel(\"Strike price, K (USD)\")\nplt.ylabel(\"Euro call option price, C (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.figure(2)\nbs_price_put = option_analytical(spot, vol, r, q, t_base, K, PutCall =  -1)\nplt.plot(K, bs_price_put, label='price')\nplt.xlabel(\"Strike price, K (USD)\")\nplt.ylabel(\"Euro put option price, P (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])"
      },
      {
        "id": "ex2",
        "title": "6.2 B2_Ch6_2.py",
        "filename": "B2_Ch6_2.py",
        "code": "# B2_Ch6_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef option_analytical(S0, vol, r, q, t, K, PutCall):\n    d1 = (np.log(S0 / K) + (r - q + 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    d2 = (np.log(S0 / K) + (r - q - 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    price =  PutCall*S0 * np.exp(-q * t) * norm.cdf(PutCall*d1, 0.0, 1.0) - PutCall* K * np.exp(-r * t) * norm.cdf(PutCall*d2, 0.0, 1.0)  \n        \n    return price\n\n    # Inputs\nr = 0.085  #risk-free interest rate\nq = 0.0 # dividend yield\nK = 55   #strike price\nvol = 0.45 #volatility\nt_base = 2.0\nPutCall = 1 # 1 for call;-1 for put\nspot = np.arange(0,100,1)  #initial underlying asset price\nt= np.arange(0.00001, 2, 0.25)\n\nNUM_COLORS = len(t)\ncm = plt.get_cmap('bwr')\ncm = plt.get_cmap('RdYlBu')\nfig1 = plt.figure(1)\nax = fig1.add_subplot(111)\n\nfor i in range(len(t)):\n    t_tmp = t[i]\n    bs_price_call = option_analytical(spot, vol, r, q, t_tmp, K, PutCall =  1)\n    lines = ax.plot(spot, bs_price_call, label='price')\n    lines[0].set_color(cm(i/NUM_COLORS))\n\nplt.xlabel(\"Stock price, S (USD)\")\nplt.ylabel(\"Euro call option price, C (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().legend(['T = 0.00 Yr','T = 0.25 Yr','T = 0.50 Yr','T = 0.75 Yr','T = 1.00 Yr','T = 1.25 Yr','T = 1.50 Yr','T = 1.75 Yr'],loc='upper left')\n\nfig2 = plt.figure(2)\nax = fig2.add_subplot(111)\nfor i in range(len(t)):\n    t_tmp = t[i]\n    bs_price_put = option_analytical(spot, vol, r, q, t_tmp, K, PutCall =  -1)\n    lines = ax.plot(spot, bs_price_put, label='price')\n    lines[0].set_color(cm(i/NUM_COLORS))\n\nplt.xlabel(\"Stock price, S (USD)\")\nplt.ylabel(\"Euro put option price, P (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().legend(['T = 0.00 Yr','T = 0.25 Yr','T = 0.50 Yr','T = 0.75 Yr','T = 1.00 Yr','T = 1.25 Yr','T = 1.50 Yr','T = 1.75 Yr'],loc='upper right')\n"
      },
      {
        "id": "ex3",
        "title": "6.3 B2_Ch6_3.py",
        "filename": "B2_Ch6_3.py",
        "code": "# B2_Ch6_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef Binomialtree(n, S0, K, r, q, vol, t, PutCall, EuropeanAmerican):  \n    deltaT = t/n \n    u = np.exp(vol*np.sqrt(deltaT))\n    d = 1./u\n    p = (np.exp((r-q)*deltaT)-d) / (u-d) \n    \n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]\n        \n    return optionvalue[0,0] \n\n    # Inputs\nn = 50\nr = 0.085  #risk-free interest rate\nq = 0.0 # dividend yield\nK = 55   #strike price\nvol = 0.45 #volatility\nt_base = 2.0\nPutCall = 1 # 1 for call;-1 for put\nspot = np.arange(0,100,1)  #initial underlying asset price\n\nt= np.arange(0.00001, 2, 0.25)\nprice_call = np.zeros(len(spot)) \nprice_put = np.zeros(len(spot)) \n\nNUM_COLORS = len(t)\ncm = plt.get_cmap('RdYlBu')\nfig1 = plt.figure(1)\nax = fig1.add_subplot(111)\n\nfor i in range(len(t)):\n    t_tmp = t[i]\n    price_put = np.array([Binomialtree(n, S0, K, r, q, vol, t_tmp, PutCall=\"Put\", EuropeanAmerican=\"American\") for S0 in spot])\n    lines = ax.plot(spot, price_put, label='price')\n    lines[0].set_color(cm(i/NUM_COLORS))\n\nplt.xlabel(\"Stock price, S (USD)\")\nplt.ylabel(\"Am. put option price, P (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().legend(['T = 0.00 Yr','T = 0.25 Yr','T = 0.50 Yr','T = 0.75 Yr','T = 1.00 Yr','T = 1.25 Yr','T = 1.50 Yr','T = 1.75 Yr'],loc='upper right')"
      },
      {
        "id": "ex4",
        "title": "6.4 B2_Ch6_3.py",
        "filename": "B2_Ch6_4.py",
        "code": "# B2_Ch6_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nfrom scipy.stats import norm\n\ndef option_analytical(S0, vol, r_d, r_f, t, K, PutCall):\n    d1 = (np.log(S0 / K) + (r_d - r_f + 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    d2 = (np.log(S0 / K) + (r_d - r_f - 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))  \n    price =  PutCall*S0 * np.exp(-r_f * t) * norm.cdf(PutCall*d1, 0.0, 1.0) - PutCall* K * np.exp(-r_d * t) * norm.cdf(PutCall*d2, 0.0, 1.0)  \n        \n    return price\n\n    # Inputs\nS0 = 1.6   # spot price, units of domestic currency of one unit of foreign currency\nr_d = 0.0606  # domestic risk-free interest rate\nr_f = 0.1168   # forieign risk-free interest rate \nK = 1.58    # strike price, units of domestic currency of one unit of foreign currency \nvol = 0.15    #volatility\nt = 90/365\nPutCall = -1 # 1 for call;-1 for put\n\nbs_price = option_analytical(S0, vol, r_d, r_f, t, K, PutCall)\nprint('analytical Price: %.4f' % bs_price)"
      },
      {
        "id": "ex5",
        "title": "6.5 B2_Ch6_5.py",
        "filename": "B2_Ch6_5.py",
        "code": "# B2_Ch6_5.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef cash_or_nothing_analytical(S0, vol, r, q, t, K, Q, PutCall):\n    if t == 0:\n        price =  Q*np.array(PutCall*(S0-K)>=0,dtype =bool)  \n    elif t > 0:\n        d2 = (np.log(S0 / K) + (r - q - 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n       \n        price =  Q*np.exp(-r * t) * norm.cdf(PutCall*d2, 0.0, 1.0)      \n    else:\n        print(\"time to maturity should be greater or equal to zero\")\n    return price\n\n    # Inputs\nr = 0.085  #risk-free interest rate\nq = 0.0 # dividend yield\nK = 55   #strike price\nvol = 0.45 #volatility\nPutCall = 1 # 1 for call;-1 for put\nspot = np.arange(10,105,1)  #initial underlying asset price\nQ = 1\nt = 0\n\nplt.figure(1)\nprice_call = cash_or_nothing_analytical(spot, vol, r, q, t, K, Q, PutCall =  1)\nplt.plot(spot, price_call, '.',label='price')\n\nplt.xlabel(\"Stock price, S (USD)\")\nplt.ylabel(\"Payoff at expiration\")\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.figure(2)\nprice_put = cash_or_nothing_analytical(spot, vol, r, q, t, K, Q, PutCall =  -1)\nplt.plot(spot, price_put, '.',label='price')\n\nplt.xlabel(\"Stock price, S (USD)\")\nplt.ylabel(\"Payoff at expiration\")\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)"
      },
      {
        "id": "ex6",
        "title": "6.6 B2_Ch6_6.py",
        "filename": "B2_Ch6_6.py",
        "code": "# B2_Ch6_6.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef option_analytical(S0, vol, r, q, t, K, PutCall):\n    d1 = (np.log(S0 / K) + (r - q + 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    d2 = (np.log(S0 / K) + (r - q - 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    price =  PutCall*S0 * np.exp(-q * t) * norm.cdf(PutCall*d1, 0.0, 1.0) - PutCall* K * np.exp(-r * t) * norm.cdf(PutCall*d2, 0.0, 1.0)  \n        \n    return price\n\n    # Inputs\nr = 0.085  #risk-free interest rate\nq = 0.0 # dividend yield\nK = 55   #strike price\nvol = 0.45 #volatility\nPutCall = 1 # 1 for call;-1 for put\nspot = np.arange(10,105,0.2)  #initial underlying asset price\nQ = 1\nt = 0\nEPSILO = 0.01*K\nN = 0.5*Q/EPSILO \nEPSILON = np.arange(0.005,0.2,0.025)*K\n\nNUM_COLORS = len(EPSILON )\ncm = plt.get_cmap('RdYlBu')\nfig1 = plt.figure(1)\nax = fig1.add_subplot(111)\n\nfor i in range(len(EPSILON)):\n    EPSILON_tmp = EPSILON[i]\n    european_call_K1 = option_analytical(spot, vol, r, q, t, K-EPSILON_tmp, PutCall =  1)\n    european_call_K2 = option_analytical(spot, vol, r, q, t, K+EPSILON_tmp, PutCall =  1)\n    N_tmp = 0.5*Q/EPSILON_tmp \n    lines = ax.plot(spot, N_tmp*european_call_K1-N_tmp*european_call_K2,label='price')\n    lines[0].set_color(cm(i/NUM_COLORS))\nplt.xlabel(\"Stock price, S (USD)\")\nplt.ylabel(\"Payoff at expiration\")\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().legend(['e = 0.275','e = 1.65','e = 3.025','e = 4.4','e = 5.775','e = 7.15','e = 8.525','e = 9.9'],loc='upper left')\n\nfig2 = plt.figure(2)\nax = fig2.add_subplot(111)\n\nfor i in range(len(EPSILON)):\n    EPSILON_tmp = EPSILON[i]\n    european_put_K1 = option_analytical(spot, vol, r, q, t, K+EPSILON_tmp, PutCall =  -1)\n    european_put_K2 = option_analytical(spot, vol, r, q, t, K-EPSILON_tmp, PutCall =  -1)\n    N_tmp = 0.5*Q/EPSILON_tmp \n    lines = ax.plot(spot, N_tmp*european_put_K1-N_tmp*european_put_K2,label='price')\n    lines[0].set_color(cm(i/NUM_COLORS))\nplt.xlabel(\"Stock price, S (USD)\")\nplt.ylabel(\"Payoff at expiration\")\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().legend(['e = 0.275','e = 1.65','e = 3.025','e = 4.4','e = 5.775','e = 7.15','e = 8.525','e = 9.9'],loc='upper right')"
      },
      {
        "id": "ex7",
        "title": "6.7 B2_Ch6_7.py",
        "filename": "B2_Ch6_7.py",
        "code": "# B2_Ch6_7.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef cash_or_nothing_analytical(S0, vol, r, q, t, K, Q, PutCall):\n    if t == 0:\n        price =  Q*np.array(S0>=K,dtype =bool)  \n    elif t > 0:\n        d2 = (np.log(S0 / K) + (r - q - 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n       \n        price =  Q*np.exp(-r * t) * norm.cdf(PutCall*d2, 0.0, 1.0)      \n    else:\n        print(\"time to maturity should be greater or equal to zero\")\n    return price\n\n    # Inputs\nr = 0.085  #risk-free interest rate\nq = 0.0 # dividend yield\nK = 55   #strike price\nvol = 0.45 #volatility\nt_base = 2.0\nPutCall = 1 # 1 for call;-1 for put\nspot = np.arange(20,95,1)  #initial underlying asset price\nQ = 10\nt= np.arange(1/12, 1, 1/12)\n\nNUM_COLORS = len(t)\ncm = plt.get_cmap('RdYlBu')\nfig1 = plt.figure(1)\nax = fig1.add_subplot(111)\n\nfor i in range(len(t)):\n    t_tmp = t[i]\n    price_call = cash_or_nothing_analytical(spot, vol, r, q, t_tmp, K, Q, PutCall =  1)\n    lines = ax.plot(spot, price_call, label='price')\n    lines[0].set_color(cm(i/NUM_COLORS))\n\nplt.xlabel(\"Asset price, S (USD)\")\nplt.ylabel(\"Cash-or-nothing call option price (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().legend(['T = 1/12 Yr','T = 2/12 Yr','T = 3/12 Yr','T = 4/12 Yr','T = 5/12 Yr','T = 6/12 Yr','T = 7/12 Yr','T = 8/12 Yr','T = 9/12 Yr','T = 10/12 Yr','T = 11/12 Yr'],loc='upper left')\n\nfig2 = plt.figure(2)\nax = fig2.add_subplot(111)\nfor i in range(len(t)):\n    t_tmp = t[i]\n    price_put = cash_or_nothing_analytical(spot, vol, r, q, t_tmp, K, Q, PutCall =  -1)\n    lines = ax.plot(spot, price_put, label='price')\n    lines[0].set_color(cm(i/NUM_COLORS))\n\nplt.xlabel(\"Asset price, S (USD)\")\nplt.ylabel(\"Cash-or-nothing put option price (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().legend(['T = 1/12 Yr','T = 2/12 Yr','T = 3/12 Yr','T = 4/12 Yr','T = 5/12 Yr','T = 6/12 Yr','T = 7/12 Yr','T = 8/12 Yr','T = 9/12 Yr','T = 10/12 Yr','T = 11/12 Yr'],loc='upper right')\n"
      },
      {
        "id": "ex8",
        "title": "6.8 B2_Ch6_8.py",
        "filename": "B2_Ch6_8.py",
        "code": "# B2_Ch6_8.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef cash_or_nothing_delta(S0, vol, r, q, t, K, Q, PutCall):\n    d2 = (np.log(S0 / K) + (r - q - 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    delta =  PutCall*Q*np.exp(-r * t) * norm.pdf(PutCall*d2, 0.0, 1.0) / (vol*S0*np.sqrt(t))    \n    return delta\n\n    # Inputs\nr = 0.01  #risk-free interest rate\nq = 0.0 # dividend yield\nK = 55   #strike price\nvol = 0.45 #volatility\nt_base = 2.0\nPutCall = 1 # 1 for call;-1 for put\nspot = np.arange(20,95,0.5)  #initial underlying asset price\nQ = 10\nt= np.arange(1/365, 1, 2/12)\n\nNUM_COLORS = len(t)\ncm = plt.get_cmap('RdYlBu')\nfig1 = plt.figure(1)\nax = fig1.add_subplot(111)\n\nfor i in range(len(t)):\n    t_tmp = t[i]\n    delta_call = cash_or_nothing_delta(spot, vol, r, q, t_tmp, K, Q, PutCall =  1)\n    lines = ax.plot(spot, delta_call,label='delta')\n    lines[0].set_color(cm(i/NUM_COLORS))\n\nplt.xlabel(\"Asset price, S (USD)\")\nplt.ylabel(\"Cash-or-nothing call option delta (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().legend(['T=1/365 Yr','T=2/12 Yr','T=4/12 Yr','T=6/12 Yr','T=8/12 Yr','T=10/12 Yr'],loc='upper left')\n\nfig2 = plt.figure(2)\nax = fig2.add_subplot(111)\nfor i in range(len(t)):\n    t_tmp = t[i]\n    delta_put = cash_or_nothing_delta(spot, vol, r, q, t_tmp, K, Q, PutCall =  -1)\n    lines = ax.plot(spot, delta_put, label='delta')\n    lines[0].set_color(cm(i/NUM_COLORS))\n\nplt.xlabel(\"Asset price, S (USD)\")\nplt.ylabel(\"Cash-or-nothing put option delta (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().legend(['T=1/365 Yr','T=2/12 Yr','T=4/12 Yr','T=6/12 Yr','T=8/12 Yr','T=10/12 Yr'],loc='lower left')"
      },
      {
        "id": "ex9",
        "title": "6.9 B2_Ch6_9.py",
        "filename": "B2_Ch6_9.py",
        "code": "# B2_Ch6_9.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef option_delta(S0, vol, r, q, t, K, PutCall):\n    d1 = (np.log(S0 / K) + (r - q + 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    if PutCall == 1:\n        delta = np.exp(-q * t) * norm.cdf(d1, 0.0, 1.0)\n    else:    \n        delta = np.exp(-q * t) * (norm.cdf(d1, 0.0, 1.0) -1 )\n        \n    return delta\n    # Inputs\nr = 0.01  #risk-free interest rate\nq = 0.0 # dividend yield\nK = 55   #strike price\nvol = 0.45 #volatility\nt_base = 2.0\nPutCall = 1 # 1 for call;-1 for put\nspot = np.arange(20,95,0.5)  #initial underlying asset price\nQ = 10\nt= np.arange(1/365, 1, 2/12)\n\nEPSILO = 0.05*K\nN = 0.5*Q/EPSILO \nNUM_COLORS = len(t)\ncm = plt.get_cmap('RdYlBu')\nfig1 = plt.figure(1)\nax = fig1.add_subplot(111)\n\nfor i in range(len(t)):\n    t_tmp = t[i]\n    delta_call_K1 = option_delta(spot, vol, r, q, t_tmp, K - EPSILO, PutCall =  1)\n    delta_call_K2 = option_delta(spot, vol, r, q, t_tmp, K + EPSILO, PutCall =  1)\n    lines = ax.plot(spot, N*(delta_call_K1 - delta_call_K2)  ,label='delta')\n    lines[0].set_color(cm(i/NUM_COLORS))\n\nplt.xlabel(\"Asset price, S (USD)\")\nplt.ylabel(\"replicating Cash-or-nothing call option delta (USD)\")\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().legend(['T=1/365 Yr','T=2/12 Yr','T=4/12 Yr','T=6/12 Yr','T=8/12 Yr','T=10/12 Yr'],loc='upper left')\n\nfig2 = plt.figure(2)\nax = fig2.add_subplot(111)\n\nfor i in range(len(t)):\n    t_tmp = t[i]\n    delta_put_K1 = option_delta(spot, vol, r, q, t_tmp, K + EPSILO, PutCall =  -1)\n    delta_put_K2 = option_delta(spot, vol, r, q, t_tmp, K - EPSILO, PutCall =  -1)\n    lines = ax.plot(spot, N*(delta_put_K1 - delta_put_K2), label='delta')\n    lines[0].set_color(cm(i/NUM_COLORS))\n\nplt.xlabel(\"Asset price, S (USD)\")\nplt.ylabel(\"replicating Cash-or-nothing put option delta (USD)\")\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().legend(['T=1/365 Yr','T=2/12 Yr','T=4/12 Yr','T=6/12 Yr','T=8/12 Yr','T=10/12 Yr'],loc='lower left')\n"
      },
      {
        "id": "ex10",
        "title": "6.10 B2_Ch6_10.py",
        "filename": "B2_Ch6_10.py",
        "code": "# B2_Ch6_10.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef asset_or_nothing_analytical(S0, vol, r, q, t, K, PutCall):\n    if t == 0:\n        price =  S0*np.array(PutCall*(S0-K)>=0,dtype =bool)  \n    elif t > 0:\n        d1 = (np.log(S0 / K) + (r - q + 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))       \n        price =  S0*np.exp(-q * t) * norm.cdf(PutCall*d1, 0.0, 1.0)      \n    else:\n        print(\"time to maturity should be greater or equal to zero\")\n    return price\n\n    # Inputs\nr = 0.085  #risk-free interest rate\nq = 0.0 # dividend yield\nK = 55   #strike price\nvol = 0.45 #volatility\nPutCall = 1 # 1 for call;-1 for put\nspot = np.arange(10,105,0.2)  #initial underlying asset price\nQ = K\nt = 0\n\nplt.figure(1)\nasset_or_nothing_call = asset_or_nothing_analytical(spot, vol, r, q, t, K, PutCall =  1)\nplt.plot(spot, asset_or_nothing_call, '.',label='price')\n\nplt.xlabel(\"Stock price, S (USD)\")\nplt.ylabel(\"Payoff at expiration\")\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.figure(2)\nasset_or_nothing_put = asset_or_nothing_analytical(spot, vol, r, q, t, K, PutCall =  -1)\nplt.plot(spot, asset_or_nothing_put, '.',label='price')\n\nplt.xlabel(\"Stock price, S (USD)\")\nplt.ylabel(\"Payoff at expiration\")\nplt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\n"
      }
    ]
  },
  {
    "id": "b2_ch7",
    "title": "ç¬¬7ç« ï¼šå¸Œè‡˜å­—æ¯",
    "number": 7,
    "content": {
      "intro": "# ç¬¬ 7 ç« ï¼šå¸Œè‡˜å­—æ¯ - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   7.1 å¸Œè‡˜å­—æ¯ (The Greeks) æ¦‚è«–\n*   7.2 Deltaï¼šåƒ¹æ ¼è®Šå‹•æ•æ„Ÿåº¦\n*   7.3 Gammaï¼šDelta çš„è®Šå‹•çŽ‡èˆ‡å‡¸æ€§ç›¸é—œ\n*   7.4 Thetaï¼šæ™‚é–“æµé€å°åƒ¹å€¼çš„å½±éŸ¿\n*   7.5 Vegaï¼šæ³¢å‹•çŽ‡æ•æ„Ÿåº¦åˆ†æž\n*   7.6 Rhoï¼šåˆ©çŽ‡é¢¨éšªåº¦é‡\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\nå¸Œè‡˜å­—æ¯è¡¡é‡çš„é¸æ“‡æ¬Šåƒ¹æ ¼å°å„ç¨®å¸‚å ´åƒæ•¸ï¼ˆæ¨™çš„åƒ¹æ ¼ã€æ™‚é–“ã€æ³¢å‹•çŽ‡ã€åˆ©çŽ‡ï¼‰çš„æ•æ„Ÿæ€§ã€‚å®ƒå€‘æ˜¯å‹•æ…‹é¿éšªï¼ˆDynamic Hedgingï¼‰èˆ‡è³‡ç”¢çµ„åˆé¢¨éšªç®¡ç†çš„éˆé­‚ã€‚æœ¬ç« é€éŽä¸‰ç¶­è¦–è¦ºåŒ–æŠ€è¡“ï¼Œæ­ç¤ºäº†å¸Œè‡˜å­—æ¯å¦‚ä½•åœ¨ä¸åŒå¸‚å ´ç¶­åº¦ä¸‹æ¼”åŒ–ã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   ç†è§£å„å¸Œè‡˜å­—æ¯çš„é‡‘èžæ„ç¾©èˆ‡è¨ˆç®—å…¬å¼ï¼ˆBSM è§£æžè§£ï¼‰ã€‚\n*   å­¸æœƒåˆ©ç”¨ Python çš„ `mpl_toolkits.mplot3d` ç¹ªè£½é¢¨éšªæ›²é¢ã€‚\n*   æŽŒæ¡å¸Œè‡˜å­—æ¯åœ¨å»ºæ§‹ Delta-Neutral æˆ– Gamma-Neutral çµ„åˆä¸­çš„å¯¦å‹™é‹ç”¨ã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šåœ¨æœŸæ¬Šåšå¸‚å•†ï¼ˆMarket Makerï¼‰æ¥­å‹™ä¸­ï¼Œç›£æŽ§ç¸½æŒå€‰çš„ Gamma æš´éœ²ä»¥é˜²æ­¢åƒ¹æ ¼å¤§å¹…è·³ç©ºå¸¶ä¾†çš„æå¤±ã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šç†è§£å¸Œè‡˜å­—æ¯ä¹‹é–“çš„é—œä¿‚ï¼Œä¾‹å¦‚ $Theta$ èˆ‡ $Gamma$ ä¹‹é–“çš„æ¬Šè¡¡ï¼ˆTrade-offï¼‰ã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch7_1.py** | **[ä¸‰ç¶­]** å¯¦ä½œ Black-Scholes Delta éš¨åƒæ•¸è®Šå‹•çš„ä¸‰ç¶­è¦–è¦ºåŒ–åˆ†æžã€‚ |\n| **B2_Ch7_2.py** | **[ä¸‰ç¶­]** å¯¦ä½œ Black-Scholes Gamma çš„ä¸‰ç¶­æ›²é¢ç¹ªè£½èˆ‡åˆ†æžã€‚ |\n| **B2_Ch7_3.py** | **[ä¸‰ç¶­]** å¯¦ä½œ Black-Scholes Theta æ™‚é–“è¡°æ¸›ç‰¹å¾µçš„ä¸‰ç¶­å‘ˆç¾ã€‚ |\n| **B2_Ch7_4.py** | **[ä¸‰ç¶­]** å¯¦ä½œ Black-Scholes Vega æ³¢å‹•çŽ‡æ•æ„Ÿåº¦åˆ†æžèˆ‡åœ–è¡¨ç¹ªè£½ã€‚ |\n| **B2_Ch7_5.py** | **[ä¸‰ç¶­]** å¯¦ä½œ Black-Scholes Rho åˆ©çŽ‡æ•æ„Ÿåº¦åˆ†æžï¼Œè¦–è¦ºåŒ–é¢¨éšªæ›²é¢ã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 7.2 Delta\nDelta ($\\Delta$) æ˜¯æœŸæ¬Šåƒ¹æ ¼å°æ¨™çš„è³‡ç”¢åƒ¹æ ¼çš„ä¸€éšŽå°Žæ•¸ã€‚å°æ–¼æ­å¼çœ‹æ¼²æœŸæ¬Šï¼Œ$\\Delta = N(d_1)$ã€‚å®ƒä»£è¡¨äº†å°æ²–ä¸€å€‹æœŸæ¬Šæ‰€éœ€çš„æ¨™çš„è³‡ç”¢é ­å¯¸ã€‚\n\n### 7.3 Gamma\nGamma ($\\Gamma$) æ˜¯ Delta å°æ¨™çš„åƒ¹æ ¼çš„è®Šå‹•çŽ‡ã€‚å®ƒåæ˜ äº†å°æ²–é ­å¯¸éœ€è¦èª¿æ•´çš„é »çŽ‡ã€‚Gamma åœ¨å¹³å€¼ï¼ˆATMï¼‰æœŸæ¬Šä¸”è‡¨è¿‘åˆ°æœŸæ™‚æœƒåŠ‡çƒˆå¢žåŠ ã€‚\n\n### 7.4-7.5 Theta èˆ‡ Vega\n- **Theta** ($\\Theta$)ï¼šè¡¡é‡æ™‚é–“åƒ¹å€¼çš„æµé€é€Ÿåº¦ï¼Œé€šå¸¸ç‚ºè² å€¼ã€‚\n- **Vega** ($\\nu$)ï¼šè¡¡é‡æ³¢å‹•çŽ‡è®Šå‹• 1% æ™‚æœŸæ¬Šåƒ¹æ ¼çš„è®ŠåŒ–ï¼Œåæ˜ äº†å°å¸‚å ´å‹•ç›ªçš„æ•æ„Ÿæ€§ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\n### ðŸ“„ B2_Ch7_1.py è‡³ B2_Ch7_5.py - å¸Œè‡˜å­—æ¯ä¸‰ç¶­åˆ†æž\n- **ä¸»è¦å‡½æ•¸**ï¼š`blsdelta()`, `blsgamma()`, `blstheta()`, `blsvega()`, `blsrho()`\n- **å¯¦ä½œé‡é»ž**ï¼šå¯¦ä½œ BSM è§£æžè§£å…¬å¼ã€‚åœ¨è¦–è¦ºåŒ–æ–¹é¢ï¼Œåˆ©ç”¨ `numpy.meshgrid` ç”Ÿæˆåƒæ•¸ç¶²æ ¼ï¼Œä¸¦ä½¿ç”¨ `plot_surface` ç¹ªè£½äº¤äº’å¼ä¸‰ç¶­æ›²é¢ã€‚\n- **æŠ€è¡“ç´°ç¯€**ï¼šä½¿ç”¨æ•¸å€¼å¾®åˆ†é©—è­‰è§£æžè§£ã€‚æ³¨æ„è¨ˆç®—æ­¥é•·å°ç²¾åº¦çš„å½±éŸ¿ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šæ•æ„Ÿæ€§åˆ†æžã€å‹•æ…‹é¿éšªã€é¢¨éšªç®¡ç†ã€éžç·šæ€§é¢¨éšªæš´éœ²ã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- å¸Œè‡˜å­—æ¯æä¾›äº†å°æœŸæ¬Šé¢¨éšªçš„å±€éƒ¨ç·šæ€§é€¼è¿‘ï¼ˆTaylor Series Expansionï¼‰ã€‚\n- è¦–è¦ºåŒ–ä¸‰ç¶­æ›²é¢èƒ½ç›´è§€åœ°å±•ç¤ºé¢¨éšªå› å­åœ¨ä¸åŒåƒ¹æ ¼èˆ‡æ™‚é–“å€é–“å…§çš„åŠ‡çƒˆè®Šå‹•ã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 6 ç«  BSM å®šåƒ¹ï¼ˆå…¬å¼ä¾†æºï¼‰ã€ç¬¬ 8 ç« å¸‚å ´é¢¨éšªï¼ˆæ•æ„Ÿåº¦æ³•è¨ˆç®— VaRï¼‰ã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Taleb (1997) Dynamic Hedging*.\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch7*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "7.1 B2_Ch7_1.py",
        "filename": "B2_Ch7_1.py",
        "code": "# B2_Ch7_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nfrom mpl_toolkits.mplot3d import axes3d\nimport matplotlib.tri as tri\nfrom matplotlib import cm\n\n# Delta of European option\n\ndef blsdelta(St, K, tau, r, vol, q):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r - q + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    d2 = d1 - vol*math.sqrt(tau);\n    Delta_call  = norm.cdf(d1, loc=0, scale=1)*math.exp(-q*tau)\n    Delta_put   = -norm.cdf(-d1, loc=0, scale=1)*math.exp(-q*tau)\n    return Delta_call, Delta_put\n    \n\n# Initialize\ntau_array = np.linspace(0.01,1,30);\nSt_array  = np.linspace(20,80,30);\ntau_Matrix,St_Matrix = np.meshgrid(tau_array,St_array)\n\nDelta_call_Matrix = np.empty(np.size(tau_Matrix))\nDelta_put_Matrix  = np.empty(np.size(tau_Matrix))\n\nK = 50;    # strike price\nr = 0.03;  # risk-free rate\nvol = 0.5; # volatility \nq = 0;     # continuously compounded yield of the underlying asset\n\nblsdelta_vec = np.vectorize(blsdelta)\nDelta_call_Matrix, Delta_put_Matrix = blsdelta_vec(St_Matrix, K, tau_Matrix, r, vol, q)\n\n#%% plot Delta surface of European call option\n\nplt.close('all')\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Delta_call_Matrix)\n\nplt.show()\nplt.tight_layout()\nax.set_xlabel('Time to maturity')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Call Delta')\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Delta_call_Matrix.min(),Delta_call_Matrix.max())\n\n#%% Call Delta surface projected to tau-Gamma\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Delta_call_Matrix, color = [0.5,0.5,0.5], linewidth=0.5)\n\nax.contour(tau_Matrix, St_Matrix, Delta_call_Matrix, levels = 20, zdir='y', \\\n            offset=St_array.max(), cmap=cm.coolwarm)\n\nax.set_label('Call Theta')\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Delta_call_Matrix.min(),Delta_call_Matrix.max())\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Call Delta')\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\nplt.tight_layout()\nplt.show()\n\n#%% Call Delta surface projected to tau-Gamma\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Delta_call_Matrix, color = [0.5,0.5,0.5], linewidth=0.5)\n\nax.contour(tau_Matrix, St_Matrix, Delta_call_Matrix, levels = 20, zdir='x', \\\n           offset=0, cmap=cm.coolwarm)\n# ax.contour(tau_Matrix, St_Matrix, Gamma_Matrix, levels = 20, zdir='x', \\\n#            cmap=cm.coolwarm)\n\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Delta_call_Matrix.min(),Delta_call_Matrix.max())\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Call Delta')\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\nplt.tight_layout()\nplt.show()\n\n#%% Call Delta surface projected to tau-S\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Delta_call_Matrix, color = [0.5,0.5,0.5], linewidth=0.5)\n\nax.contour(tau_Matrix, St_Matrix, Delta_call_Matrix, levels = 20, zdir='z', \\\n           offset=0, cmap=cm.coolwarm)\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Delta_call_Matrix.min(),Delta_call_Matrix.max())\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Call Delta')\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\nplt.tight_layout()\nplt.show()\n\n#%% contour map of Call Delta\n\nfig, ax = plt.subplots()\n\ncntr2 = ax.contourf(tau_Matrix, St_Matrix, Delta_call_Matrix, levels = np.linspace(0,1,21), cmap=\"RdBu_r\")\n\nfig.colorbar(cntr2, ax=ax)\n\nax.contour(tau_Matrix, St_Matrix, Delta_call_Matrix, levels = [0.5], colors='k', linewidths = 2)\n\nplt.subplots_adjust(hspace=0.5)\nplt.show()\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n#%% Compare Call vs Put Delta\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Delta_call_Matrix)\nax.plot_wireframe(tau_Matrix, St_Matrix, Delta_put_Matrix,color = 'r')\n\nplt.show()\nplt.tight_layout()\nax.set_xlabel('Time to maturity')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Delta')\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Delta_put_Matrix.min(),Delta_call_Matrix.max())\n"
      },
      {
        "id": "ex2",
        "title": "7.2 B2_Ch7_2.py",
        "filename": "B2_Ch7_2.py",
        "code": "# B2_Ch7_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nfrom mpl_toolkits.mplot3d import axes3d\nfrom matplotlib import cm\n\n# Gamma of European option\n\ndef blsgamma(St, K, tau, r, vol, q):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r - q + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n        \n    Gamma = math.exp(-q*tau)*norm.pdf(d1)/St/vol/math.sqrt(tau);\n\n    return Gamma\n    \n\n# Initialize\ntau_array = np.linspace(0.1,1,30);\nSt_array  = np.linspace(20,80,30);\ntau_Matrix,St_Matrix = np.meshgrid(tau_array,St_array)\n\nDelta_call_Matrix = np.empty(np.size(tau_Matrix))\nDelta_put_Matrix  = np.empty(np.size(tau_Matrix))\n\nK = 50;    # strike price\nr = 0.03;  # risk-free rate\nvol = 0.5; # volatility \nq = 0;     # continuously compounded yield of the underlying asset\n\nblsgamma_vec = np.vectorize(blsgamma)\nGamma_Matrix = blsgamma_vec(St_Matrix, K, tau_Matrix, r, vol, q)\n\n#%% plot Gamma surface of European call option\n\nplt.close('all')\n\n# Normalize to [0,1]\nnorm = plt.Normalize(Gamma_Matrix.min(), Gamma_Matrix.max())\ncolors = cm.coolwarm(norm(Gamma_Matrix))\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\nsurf = ax.plot_surface(tau_Matrix, St_Matrix, Gamma_Matrix,\n    facecolors=colors, shade=False)\nsurf.set_facecolor((0,0,0,0))\nplt.show()\n\nplt.tight_layout()\nax.set_xlabel('Time to maturity')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Gamma')\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Gamma_Matrix.min(),Gamma_Matrix.max())\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\n#%% Gamma surface projected to S-Gamma\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Gamma_Matrix, color = [0.5,0.5,0.5], linewidth=0.5)\n\nax.contour(tau_Matrix, St_Matrix, Gamma_Matrix, levels = 20, zdir='x', \\\n           offset=0, cmap=cm.coolwarm)\n# ax.contour(tau_Matrix, St_Matrix, Gamma_Matrix, levels = 20, zdir='x', \\\n#            cmap=cm.coolwarm)\n    \n# cbar = fig.colorbar(csetf, ax=ax,orientation='horizontal')\ncbar.set_label('Call Gamma')\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Gamma_Matrix.min(),Gamma_Matrix.max())\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Gamma')\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\nplt.tight_layout()\nplt.show()\n\n#%% Gamma surface projected to tau-Gamma\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Gamma_Matrix, color = [0.5,0.5,0.5], linewidth=0.5)\n\nax.contour(tau_Matrix, St_Matrix, Gamma_Matrix, levels = 20, zdir='y', \\\n            offset=St_array.max(), cmap=cm.coolwarm)\n\n# cbar = fig.colorbar(csetf, ax=ax,orientation='horizontal')\ncbar.set_label('Call Gamma')\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Gamma_Matrix.min(),Gamma_Matrix.max())\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Gamma')\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\nplt.tight_layout()\nplt.show()\n\n#%% Gamma surface projected to tau-S\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Gamma_Matrix, color = [0.5,0.5,0.5], linewidth=0.5)\n\nax.contour(tau_Matrix, St_Matrix, Gamma_Matrix, levels = 20, zdir='z', \\\n            offset=Gamma_Matrix.min(), cmap=cm.coolwarm)\n\n# cbar = fig.colorbar(csetf, ax=ax,orientation='horizontal')\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Gamma_Matrix.min(),Gamma_Matrix.max())\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Gamma')\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\nplt.tight_layout()\nplt.show()\n\n#%% contour map\n\nfig, ax = plt.subplots()\n\ncntr2 = ax.contourf(tau_Matrix, St_Matrix, Gamma_Matrix, levels = 20, cmap=\"RdBu_r\")\n\nfig.colorbar(cntr2, ax=ax)\n\nplt.show()\n\nax.set_xlabel('Time to maturity')\nax.set_ylabel('Underlying price')\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n"
      },
      {
        "id": "ex3",
        "title": "7.3 B2_Ch7_3.py",
        "filename": "B2_Ch7_3.py",
        "code": "# B2_Ch7_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nfrom mpl_toolkits.mplot3d import axes3d\nimport matplotlib.tri as tri\nfrom matplotlib import cm\n\n# Delta of European option\n\ndef blstheta(St, K, tau, r, vol, q):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r - q + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    d2 = d1 - vol*math.sqrt(tau);\n    \n    Theta_call = -math.exp(-q*tau)*St*norm.pdf(d1)*vol/2/math.sqrt(tau) - \\\n        r*K*math.exp(-r*tau)*norm.cdf(d2) + q*St*math.exp(-q*tau)*norm.cdf(d1)\n        \n    Theta_put = -math.exp(-q*tau)*St*norm.pdf(-d1)*vol/2/math.sqrt(tau) + \\\n        r*K*math.exp(-r*tau)*norm.cdf(-d2) - q*St*math.exp(-q*tau)*norm.cdf(-d1)\n    return Theta_call, Theta_put\n\n# Initialize\ntau_array = np.linspace(0.05,1,30);\nSt_array  = np.linspace(20,80,30);\ntau_Matrix,St_Matrix = np.meshgrid(tau_array,St_array)\n\nTheta_call_Matrix = np.empty(np.size(tau_Matrix))\nTheta_put_Matrix  = np.empty(np.size(tau_Matrix))\n\nK = 50;    # strike price\nr = 0.03;  # risk-free rate\nvol = 0.5; # volatility \nq = 0;     # continuously compounded yield of the underlying asset\n\nblstheta_vec = np.vectorize(blstheta)\nTheta_call_Matrix, Theta_put_Matrix = blstheta_vec(St_Matrix, K, tau_Matrix, r, vol, q)\n\n#%% plot Theta surface of European call option\n\nplt.close('all')\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Theta_call_Matrix, color = [0.5,0.5,0.5], linewidth=0.5)\ncsetf = ax.contourf(tau_Matrix, St_Matrix, Theta_call_Matrix, levels = 15, zdir='z', \\\n                    offset=Theta_call_Matrix.min(), cmap=cm.coolwarm)\nax.contour(tau_Matrix, St_Matrix, Theta_call_Matrix, levels = 15, zdir='x', \\\n           offset=0, cmap=cm.coolwarm)\nax.contour(tau_Matrix, St_Matrix, Theta_call_Matrix, levels = 15, zdir='y', \\\n           offset=St_array.max(), cmap=cm.coolwarm)\n\ncbar = fig.colorbar(csetf, ax=ax,orientation='horizontal')\ncbar.set_label('Call Theta')\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Theta_call_Matrix.min(),Theta_call_Matrix.max())\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Call Theta')\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\nplt.tight_layout()\nplt.show()\n\n\n#%% plot Theta surface of European put option\n\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Theta_put_Matrix, color = [0.5,0.5,0.5], linewidth=0.5)\ncsetf = ax.contourf(tau_Matrix, St_Matrix, Theta_put_Matrix, levels = 15, zdir='z', \\\n                    offset=Theta_put_Matrix.min(), cmap=cm.coolwarm)\nax.contour(tau_Matrix, St_Matrix, Theta_put_Matrix, levels = 15, zdir='x', \\\n           offset=0, cmap=cm.coolwarm)\nax.contour(tau_Matrix, St_Matrix, Theta_put_Matrix, levels = 15, zdir='y', \\\n           offset=St_array.max(), cmap=cm.coolwarm)\n\ncbar = fig.colorbar(csetf, ax=ax, orientation='horizontal')\n# cbar.set_label('Put Theta')\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Theta_put_Matrix.min(),Theta_put_Matrix.max())\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Put Theta')\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\nplt.tight_layout()\nplt.show()\n\nfig, ax = plt.subplots()\n\ncntr2 = ax.contourf(tau_Matrix, St_Matrix, Theta_put_Matrix, levels = 20, cmap=\"RdBu_r\")\nax.contour(tau_Matrix, St_Matrix, Theta_put_Matrix, levels = 0,colors='k', linewidths = 2)\n\nfig.colorbar(cntr2, ax=ax)\nplt.show()\n\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\nax.set_ylim(St_array.min(), St_array.max())\n\n#%% Compare Call vs Put Theta\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Theta_call_Matrix)\nax.plot_wireframe(tau_Matrix, St_Matrix, Theta_put_Matrix,color = 'r')\n\nplt.show()\nplt.tight_layout()\nax.set_xlabel('Time to maturity')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Theta')\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Theta_call_Matrix.min(),Theta_put_Matrix.max())\n\n"
      },
      {
        "id": "ex4",
        "title": "7.4 B2_Ch7_4.py",
        "filename": "B2_Ch7_4.py",
        "code": "# B2_Ch7_4.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nfrom mpl_toolkits.mplot3d import axes3d\nimport matplotlib.tri as tri\nfrom matplotlib import cm\n\n# Vega of European option\n\ndef blsvega(St, K, tau, r, vol, q):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r - q + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    \n    Vega = St*math.exp(-q*tau)*norm.pdf(d1)*math.sqrt(tau)\n    return Vega\n\n# Initialize\ntau_array = np.linspace(0.1,1,30);\nSt_array  = np.linspace(20,80,30);\ntau_Matrix,St_Matrix = np.meshgrid(tau_array,St_array)\n\nDelta_call_Matrix = np.empty(np.size(tau_Matrix))\nDelta_put_Matrix  = np.empty(np.size(tau_Matrix))\n\nK = 50;    # strike price\nr = 0.03;  # risk-free rate\nvol = 0.5; # volatility \nq = 0;     # continuously compounded yield of the underlying asset\n\nblsvega_vec = np.vectorize(blsvega)\nVega_Matrix = blsvega_vec(St_Matrix, K, tau_Matrix, r, vol, q)\n\n#%% plot Vega surface of European call/put option\n\nplt.close('all')\n\n# Normalize to [0,1]\nnorm = plt.Normalize(Vega_Matrix.min(), Vega_Matrix.max())\ncolors = cm.coolwarm(norm(Vega_Matrix))\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\nsurf = ax.plot_surface(tau_Matrix, St_Matrix, Vega_Matrix,\n    facecolors=colors, shade=False)\nsurf.set_facecolor((0,0,0,0))\nplt.show()\n\nplt.tight_layout()\nax.set_xlabel('Time to maturity')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Call/Put Vega')\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\n\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\ncset = ax.contour(tau_Matrix, St_Matrix, Vega_Matrix, cmap=cm.coolwarm,levels = 20)\nax.clabel(cset, fontsize=9, inline=1)\n\nplt.show()\nplt.tight_layout()\nax.set_xlabel('Time to maturity')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Call/Put Vega')\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\n\n# contour map\n\nfig, ax = plt.subplots()\n\ncntr2 = ax.contourf(tau_Matrix, St_Matrix, Vega_Matrix, levels = 20, cmap=\"RdBu_r\")\n\nfig.colorbar(cntr2, ax=ax)\n# ax.set(xlim=(-2, 2), ylim=(-2, 2))\n# plt.subplots_adjust(hspace=0.5)\nplt.show()\n\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\nax.set_ylim(St_array.min(), St_array.max())\n"
      },
      {
        "id": "ex5",
        "title": "7.5 B2_Ch7_5.py",
        "filename": "B2_Ch7_5.py",
        "code": "# B2_Ch7_5.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nfrom mpl_toolkits.mplot3d import axes3d\nfrom matplotlib import cm\n\n# Gamma of European option\n\ndef blsrho(St, K, tau, r, vol, q):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r - q + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    d2 = d1 - vol*math.sqrt(tau);\n        \n    Rho_call = K*tau*math.exp(-r*tau)*norm.cdf(d2);\n    Rho_put = -K*tau*math.exp(-r*tau)*norm.cdf(-d2);\n    \n    return Rho_call, Rho_put\n    \n\n# Initialize\ntau_array = np.linspace(0.1,1,30);\nSt_array  = np.linspace(20,80,30);\ntau_Matrix,St_Matrix = np.meshgrid(tau_array,St_array)\n\nVega_call_Matrix = np.empty(np.size(tau_Matrix))\nVega_put_Matrix  = np.empty(np.size(tau_Matrix))\n\nK = 50;    # strike price\nr = 0.03;  # risk-free rate\nvol = 0.5; # volatility \nq = 0;     # continuously compounded yield of the underlying asset\n\nblsrho_vec = np.vectorize(blsrho)\nRho_call_Matrix, Rho_put_Matrix = blsrho_vec(St_Matrix, K, tau_Matrix, r, vol, q)\n\n#%% plot Rho surface of European call option\n\nplt.close('all')\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Rho_call_Matrix)\ncset = ax.contour(tau_Matrix, St_Matrix, Rho_call_Matrix, zdir='z',\\\n                  offset=Rho_call_Matrix.min(), cmap=cm.coolwarm)\ncset = ax.contour(tau_Matrix, St_Matrix, Rho_call_Matrix, zdir='x',\\\n                  offset=0, cmap=cm.coolwarm)\ncset = ax.contour(tau_Matrix, St_Matrix, Rho_call_Matrix, zdir='y',\\\n                  offset=St_array.max(), cmap=cm.coolwarm)\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Rho_call_Matrix.min(),Rho_call_Matrix.max())\n\n\nplt.tight_layout()\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Call Rho')\nax.set_facecolor('white')\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\nplt.show()\n\n#%% plot Rho surface of European put option\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\nax.plot_wireframe(tau_Matrix, St_Matrix, Rho_put_Matrix)\ncset = ax.contour(tau_Matrix, St_Matrix, Rho_put_Matrix, zdir='z', \\\n                  offset=Rho_put_Matrix.min(), cmap=cm.coolwarm)\ncset = ax.contour(tau_Matrix, St_Matrix, Rho_put_Matrix, zdir='x', \\\n                  offset=0, cmap=cm.coolwarm)\ncset = ax.contour(tau_Matrix, St_Matrix, Rho_put_Matrix, zdir='y', \\\n                  offset=St_array.max(), cmap=cm.coolwarm)\n\nax.set_xlim(0, 1)\nax.set_ylim(St_array.min(), St_array.max())\nax.set_zlim(Rho_put_Matrix.min(),Rho_put_Matrix.max())\n\nplt.tight_layout()\nax.set_xlabel('Time to maturity (year)')\nax.set_ylabel('Underlying price')\nax.set_zlabel('Put Rho')\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\nplt.show()\n"
      }
    ]
  },
  {
    "id": "b2_ch8",
    "title": "ç¬¬8ç« ï¼šå¸‚å ´é¢¨éšª",
    "number": 8,
    "content": {
      "intro": "# ç¬¬ 8 ç« ï¼šå¸‚å ´é¢¨éšª - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   8.1 å¸‚å ´é¢¨éšª (Market Risk) åŠå…¶åˆ†é¡ž\n*   8.2 å¸‚å ´é¢¨éšªåº¦é‡ï¼šå¾žæ¨™æº–å·®åˆ° VaR\n*   8.3 é¢¨éšªåƒ¹å€¼ (VaR) èˆ‡é æœŸæå¤± (Expected Shortfall)\n*   8.4 åƒæ•¸æ³• (Parametric Method) è¨ˆç®— VaR\n*   8.5 æ­·å²æ³• (Historical Simulation) è¨ˆç®— VaR\n*   8.6 è’™åœ°å¡ç¾…æ³• (Monte Carlo Method) è¨ˆç®— VaR\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\nå¸‚å ´é¢¨éšªæ˜¯æŒ‡é‡‘èžæ©Ÿæ§‹ç”±æ–¼å¸‚å ´åƒ¹æ ¼ï¼ˆè‚¡åƒ¹ã€åˆ©çŽ‡ã€åŒ¯çŽ‡ã€å•†å“åƒ¹æ ¼ï¼‰çš„ä¸åˆ©è®Šå‹•è€Œé­å—æå¤±çš„é¢¨éšªã€‚æœ¬ç« èšç„¦æ–¼é¢¨éšªåƒ¹å€¼ï¼ˆValue at Risk, VaRï¼‰çš„ç†è«–èˆ‡å¯¦å‹™ï¼Œä»‹ç´¹äº†é‡‘èžæ©Ÿæ§‹å¦‚ä½•é‡åŒ–ã€Œåœ¨ç‰¹å®šç½®ä¿¡æ°´å¹³ä¸‹å¯èƒ½çš„æ¥µå¤§æå¤±ã€ã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   ç†è§£ VaR çš„å®šç¾©ï¼š$\\text{Prob}(\\Delta P < -\\text{VaR}) = 1 - c$ã€‚\n*   æŽŒæ¡ VaR è¨ˆç®—çš„ä¸‰å¤§ä¸»æµæ–¹æ³•åŠå…¶å„ªç¼ºé»žèˆ‡é©ç”¨å ´æ™¯ã€‚\n*   ç†è§£ç‚ºä½• ES (Expected Shortfall)æ¯” VaR æ›´å…·å‚™ã€Œå‡èšæ€§ã€ï¼ˆCoherenceï¼‰ï¼Œç‰¹åˆ¥æ˜¯åœ¨å°¾éƒ¨é¢¨éšªåº¦é‡ä¸Šã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šæ¯æ—¥è¨ˆç®—è­‰åˆ¸æŒå€‰çš„ VaR å€¼ï¼Œä¸¦èˆ‡é å…ˆè¨­å®šçš„é¢¨éšªé™é¡ï¼ˆRisk Limitsï¼‰é€²è¡Œå°æ¯”ã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šç†è§£æ­·å²æ¨¡æ“¬æ³•ä¸éœ€è¦åˆ†ä½ˆå‡è¨­ï¼Œè€Œåƒæ•¸æ³•å‰‡å¼·çƒˆä¾è³´å¸¸æ…‹æ€§å‡è¨­ã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch8_1.py** | å¯¦ä½œåŸºç¤Ž VaR è¨ˆç®—ï¼Œæ¼”ç¤ºä½¿ç”¨ `PrettyTable` é€²è¡Œé¢¨éšªå ±å‘Šæ ¼å¼åŒ–ã€‚ |\n| **B2_Ch8_2.py** | æ¼”ç¤ºå¤šç¨®ç½®ä¿¡æ°´å¹³ï¼ˆ95%, 99%ï¼‰ä¸‹çš„ VaR è¨ˆç®—èˆ‡çµ±è¨ˆå°æ¯”ã€‚ |\n| **B2_Ch8_3.py** | **[é€²éšŽ]** å¯¦ä½œæ»¾å‹•çª—å£æ³¢å‹•çŽ‡è¨ˆç®—èˆ‡ VaR ä¿¡è³´å€é–“çš„å‹•æ…‹è¦–è¦ºåŒ–ã€‚ |\n| **B2_Ch8_4.py** | åˆ†æžæ”¶ç›ŠçŽ‡åˆ†ä½ˆç‰¹å¾µï¼Œæ¼”ç¤º VaR è¨ˆç®—ä¸­çš„çµ±è¨ˆæŽ¨æ–·èˆ‡åˆ†ä½æ•¸åˆ†æžã€‚ |\n| **B2_Ch8_5.py** | **[æ ¸å¿ƒ]** åˆ©ç”¨è’™åœ°å¡ç¾…æ¨¡æ“¬ç”Ÿæˆéš¨æ©Ÿè·¯å¾‘ï¼Œè¨ˆç®—éžç·šæ€§è³‡ç”¢çµ„åˆçš„ VaRã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 8.3 é¢¨éšªåƒ¹å€¼ VaR\nVaR æ˜¯ç›®å‰é‡‘èžç›£ç®¡ï¼ˆå¦‚å·´å¡žçˆ¾å”å®šï¼‰è¦æ±‚çš„æ ¸å¿ƒæŒ‡æ¨™ã€‚\n- **1 å¤© 99% VaR**ï¼šè¡¨ç¤ºæœ‰ 99% çš„æ©ŸçŽ‡ï¼Œæ˜Žå¤©çš„æå¤±ä¸æœƒè¶…éŽè©²æ•¸å€¼ã€‚\n- **å„ªé»ž**ï¼šç°¡å–®æ˜“æ‡‚ï¼Œå°‡é¢¨éšªå£“ç¸®ç‚ºä¸€å€‹å–®ä¸€é‡‘é¡ã€‚\n- **ç¼ºé»ž**ï¼šç„¡æ³•å‘Šè¨´æˆ‘å€‘ã€Œè¶…éŽ VaR æ™‚çš„æå¤±å…·é«”æ˜¯å¤šå°‘ã€ï¼Œé€™æ­£æ˜¯ ES è§£æ±ºçš„å•é¡Œã€‚\n\n### 8.4-8.6 è¨ˆç®—æ–¹æ³•å°æ¯”\n- **åƒæ•¸æ³•**ï¼šå‡è¨­å›žå ±çŽ‡æœå¾žæ­£æ…‹åˆ†ä½ˆã€‚$VaR = \\mu - z \\sigma$ã€‚è¨ˆç®—æ¥µå¿«ï¼Œä½†ä¸é©æ–¼åŽšå°¾åˆ†ä½ˆã€‚\n- **æ­·å²æ³•**ï¼šåˆ©ç”¨éŽåŽ» $N$ å¤©çš„å¯¦éš›æ•¸æ“šé‡æ–°ä¼°å€¼ã€‚èƒ½æ•æ‰åŽšå°¾ï¼Œä½†å—é™æ–¼æ­·å²æ¨£æœ¬ã€‚\n- **è’™åœ°å¡ç¾…æ³•**ï¼šæ¨¡æ“¬ä¸Šè¬ç¨®å¯èƒ½è·¯å¾‘ã€‚æœ€éˆæ´»ï¼Œé©ç”¨æ–¼è¤‡é›œè¡ç”Ÿå“ï¼Œä½†è¨ˆç®—è¼ƒæ…¢ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\n### ðŸ“„ B2_Ch8_1.py & B2_Ch8_2.py - å ±å‘Šç”Ÿæˆ\n- **å¯¦ä½œé‡é»ž**ï¼šä½¿ç”¨ `prettytable` å¥—ä»¶å»ºç«‹å°ˆæ¥­çš„é¢¨éšªå ±å‘Šã€‚\n- **æŠ€è¡“ç´°ç¯€**ï¼šç¢ºä¿é¢¨éšªåº¦é‡çš„ä¸€è‡´æ€§ï¼Œä¸¦è€ƒæ…®æ¥µç«¯å¸‚å ´æƒ…æ³ä¸‹çš„æ•¸æ“šå®Œæ•´æ€§ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šé¢¨éšªåƒ¹å€¼ã€é æœŸæå¤±ã€é¢¨éšªé™é¡ã€‚\n\n### ðŸ“„ B2_Ch8_3.py - æ»¾å‹• VaR åˆ†æž\n- **å¯¦ä½œé‡é»ž**ï¼šå¯¦ä½œå‹•æ…‹æ³¢å‹•çŽ‡ä¼°ç®—ï¼ˆå¦‚ EWMA æ€æƒ³çš„å‰èº«ï¼‰ï¼Œåˆ†æž VaR å¦‚ä½•éš¨å¸‚å ´æ³¢å‹•è€Œã€Œè‡ªæˆ‘èª¿æ•´ã€ã€‚\n- **è¦–è¦ºåŒ–ç´°ç¯€**ï¼šåœ¨åƒ¹æ ¼æ›²ç·šä¸‹æ–¹ç¹ªè£½å‹•æ…‹ VaR é‚Šç•Œã€‚\n\n### ðŸ“„ B2_Ch8_5.py - è’™åœ°å¡ç¾… VaR\n- **å¯¦ä½œé‡é»ž**ï¼šç”Ÿæˆ $N$ æ¢éš¨æ©Ÿè·¯å¾‘ï¼Œè¨ˆç®—æŠ•è³‡çµ„åˆåœ¨åˆ°æœŸæ—¥çš„ P&Lï¼Œå–å…¶æŒ‡å®šç™¾åˆ†ä½æ•¸ (`np.percentile`)ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šéš¨æ©ŸéŽç¨‹ã€éžç·šæ€§é¢¨éšªã€åŽšå°¾é¢¨éšªã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- VaR æ˜¯é¢¨éšªç®¡ç†çš„èµ·é»žè€Œéžçµ‚é»žï¼›æ¨¡åž‹å¿…é ˆé…åˆã€Œå›žæ¸¬ã€ï¼ˆBacktestingï¼‰ä¾†é©—è­‰æ­£ç¢ºæ€§ã€‚\n- ã€Œå£“åŠ›æ¸¬è©¦ã€ï¼ˆStress Testingï¼‰æ˜¯è¼”åŠ© VaRã€æ‡‰å° VaR ç„¡æ³•é‡åŒ–çš„æ¥µç«¯é¢¨éšªçš„é‡è¦æ‰‹æ®µã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 1 ç« æ³¢å‹•æ€§ï¼ˆVaR çš„é—œéµè¼¸å…¥ï¼‰ã€ç¬¬ 3 ç« è’™åœ°å¡ç¾…ï¼ˆè¨ˆç®—æ–¹æ³•ï¼‰ã€ç¬¬ 11 ç« æŠ•è³‡çµ„åˆã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Jorion (2006) Value at Risk*.\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch8*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "8.1 B2_Ch8_1.py",
        "filename": "B2_Ch8_1.py",
        "code": "# B2_Ch8_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom prettytable import PrettyTable\n   \n# position R1\nx = PrettyTable([\"Payout\", \"Probability\"])\nx.add_row([-50, 0.02])\nx.add_row([0, 0.98])\nx.add_row(['97% VaR', 0])\nprint(x.get_string(title=\"Position R1\"))\n\n# position R2\nx = PrettyTable([\"Payout\", \"Probability\"])\nx.add_row([-50, 0.02])\nx.add_row([0, 0.98])\nx.add_row(['97% VaR', 0])\nprint(x.get_string(title=\"Position R2\"))"
      },
      {
        "id": "ex2",
        "title": "8.2 B2_Ch8_2.py",
        "filename": "B2_Ch8_2.py",
        "code": "# B2_Ch8_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom prettytable import PrettyTable\n   \n# combination of R1 and R2\n# probability of 3 possible payouts\np1 = 0.02*0.02\np2 = 2*0.02*0.98\np3 = round(0.98*0.98, 4)\n\nx = PrettyTable([\"Payout\", \"Probability\"])\nx.add_row([-100, p1])\nx.add_row([-50, p2])\nx.add_row([0, p3])\nprint(x.get_string(title=\"Combination of positions R1 and R2\"))\nx.add_row(['97% VaR', 50])\n"
      },
      {
        "id": "ex3",
        "title": "8.3 B2_Ch8_3.py",
        "filename": "B2_Ch8_3.py",
        "code": "# B2_Ch8_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch8_3_A.py\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport pandas_datareader\nimport scipy.stats as stats\nfrom mpl_toolkits import mplot3d\nfrom matplotlib import cm\n    \ntickers = ['GOOGL','FB','AAPL','NFLX','AMZN']\nticker_num = len(tickers)\nprice_data = []\nfor ticker in range(ticker_num):   \n    prices = pandas_datareader.DataReader(tickers[ticker], start='2015-11-30', end = '2020-11-30', data_source='yahoo')   \n    price_data.append(prices[['Adj Close']])\n    df_stocks = pd.concat(price_data, axis=1)\n    \n# stock log returns\nlogreturns = np.log(df_stocks/df_stocks.shift(1))[1:]  \nlogreturns.columns = tickers \nlogreturns.head() \n\n# B2_Ch8_3_B.py\n# plot log return distribution for GOOGL\nplt.style.use('ggplot')\nmu, std = stats.norm.fit(logreturns['GOOGL'])\nx = np.linspace(mu-5*std, mu+5*std, 500)\nlogreturns['GOOGL'].hist(bins=60, density=True, histtype=\"stepfilled\", alpha=0.5)\nx = np.linspace(mu - 3*std, mu+3*std, 500)\nplt.plot(x, stats.norm.pdf(x, mu, std))\nplt.title(\"Log return distribution for GOOGL\")\nplt.xlabel(\"Return\")\nplt.ylabel(\"Density\")\n\n# B2_Ch8_3_C.py\n# plot log return distribution\nrows = 2\ncols = 2\nfig, axs = plt.subplots(rows, cols, figsize=(12,6))\nticker_n = 1\nfor i in range(rows):\n    for j in range(cols):\n        mu, std = stats.norm.fit(logreturns[tickers[ticker_n]])\n        x = np.linspace(mu-5*std, mu+5*std, 500)\n        axs[i,j].hist(logreturns[tickers[ticker_n]], bins=60, density=True, histtype=\"stepfilled\", alpha=0.5)\n        axs[i,j].plot(x, stats.norm.pdf(x, mu, std))\n        axs[i,j].set_title(\"Log return distribution for \"+tickers[ticker_n])\n        axs[i,j].set_xlabel(\"Return\")\n        axs[i,j].set_ylabel(\"Density\")\n        ticker_n = ticker_n + 1\nplt.tight_layout()\n\n\n# B2_Ch8_3_D.py\n# covariance matrix\ncov_logreturns = logreturns.cov() \n# mean returns for each stock\nmean_logreturns = logreturns.mean() \n# weights for stocks in the portfolio\nstock_weight = np.array([0.2, 0.3, 0.1, 0.15, 0.25]) \n# mean returns and volitality for portfolio  \nportfolio_mean_log = mean_logreturns.dot(stock_weight) \nportfolio_vol_log = np.sqrt(np.dot(stock_weight.T, np.dot(cov_logreturns, stock_weight)))\nprint('The mean and volatility of the portfolio are {:.6f} and {:.6f}, respectively.'.format(portfolio_mean_log, portfolio_vol_log))\n\n\n# B2_Ch8_3_E.py\n# confidence level\nconfidence_level = 0.99\n# VaR calculation: initial investment value and holding period\ninitial_investment = 1000000\nn = 1\nVaR_norm = initial_investment*(portfolio_vol_log*abs(stats.norm.ppf(q=1-confidence_level))-portfolio_mean_log)*np.sqrt(n)\nVaR_lognorm = initial_investment*(1-np.exp(portfolio_mean_log-portfolio_vol_log*abs(stats.norm.ppf(q=1-confidence_level))))*np.sqrt(n)\nprint('The normal VaR and lognormal VaR of the portfolio in 1 day holding period are {:.0f} and {:.0f}, respectively.'.format(VaR_norm, VaR_lognorm))\n\n\n\n# B2_Ch8_3_F.py\n# confidence level list\nconfidence_level_list = np.arange(0.90, 0.99, 0.001)\n# initial investment value\ninitial_investment = 1000000\nn = 1\nVaR_norm_list = []\nVaR_lognorm_list = []\nfor confidence_level in confidence_level_list:\n    VaR_norm = initial_investment*(portfolio_vol_log*abs(stats.norm.ppf(q=1-confidence_level))-portfolio_mean_log)*np.sqrt(n)\n    VaR_norm_list.append(VaR_norm)\n    VaR_lognorm = initial_investment*(1-np.exp(portfolio_mean_log-portfolio_vol_log*abs(stats.norm.ppf(q=1-confidence_level))))*np.sqrt(n)\n    VaR_lognorm_list.append(VaR_lognorm)\nplt.plot(confidence_level_list, VaR_norm_list, label='Normal VaR')\nplt.plot(confidence_level_list, VaR_lognorm_list, label='Lognormal VaR')\nplt.legend()\nplt.xlabel('Confidence level')\nplt.ylabel('1-day VaR')\n\n\n\n# B2_Ch8_3_G.py\n# 3D display \nholding_period_list = np.arange(1,91,1)\nfig = plt.figure()\nax = plt.axes(projection='3d')\nxdata = confidence_level_list\nydata = holding_period_list\nx3d, y3d = np.meshgrid(xdata, ydata)\nz3d = initial_investment*(portfolio_vol_log*abs(stats.norm.ppf(q=1-x3d))-portfolio_mean_log)*np.sqrt(y3d)\nax.plot_wireframe(x3d, y3d, z3d, rstride=4, cstride=4, linewidth=1, color='black')\nax.plot_surface(x3d, y3d, z3d, rstride=4, cstride=4, alpha=0.4,cmap=plt.cm.summer)\nax.set_xlabel('\\nConfidence level')\nax.set_ylabel('\\nHolding period')\nax.set_zlabel('\\nVaR')"
      },
      {
        "id": "ex4",
        "title": "8.4 B2_Ch8_4.py",
        "filename": "B2_Ch8_4.py",
        "code": "# B2_Ch8_4.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch8_4_A.py\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas_datareader\nimport scipy.stats as stats\nimport tabulate    \n \nprices = pandas_datareader.DataReader('AAPL', start='2015-11-30', end = '2020-11-30', data_source='yahoo')   \ndf_stocks = prices[['Adj Close']]\n    \n# stock returns\nreturns = np.log(df_stocks/df_stocks.shift(1))\nreturns = returns.dropna()\n\n\n\n# B2_Ch8_4_B.py\n# historical VaR\nreturns.sort_values('Adj Close', ascending=True, inplace=True)\nHistVaR_90 = returns.quantile(0.1, interpolation='lower')[0]\nHistVaR_95 = returns.quantile(0.05, interpolation='lower')[0]\nHistVaR_99 = returns.quantile(0.01, interpolation='lower')[0]\nprint(tabulate.tabulate([['90%', HistVaR_90], ['95%', HistVaR_95], ['99%', HistVaR_99]], headers=['Confidence level', 'Value at Risk']))\n\n\n# B2_Ch8_4_C.py\n# parameteric VaR\nmu = np.mean(returns['Adj Close'])\nstd = np.std(returns['Adj Close'])\nParaVaR_90 = stats.norm.ppf(0.1, mu, std)\nParaVaR_95 = stats.norm.ppf(0.05, mu, std)\nParaVaR_99 = stats.norm.ppf(0.01, mu, std)\nprint(tabulate.tabulate([['90%', ParaVaR_90], ['95%', ParaVaR_95], ['99%', ParaVaR_99]], headers=['Confidence level', 'Value at Risk']))\n\n\n\n# B2_Ch8_4_D.py\n# plot distribution \nplt.style.use('ggplot')\nfig, ax = plt.subplots(1,1, figsize=(12,6))\nx = np.linspace(mu-5*std, mu+5*std, 500)\nax.hist(returns['Adj Close'], bins=100, density=True, histtype=\"stepfilled\", alpha=0.5)\nax.axvline(HistVaR_95, ymin=0, ymax=0.2, color='g', ls=':', alpha=0.7, label='95% historical VaR')\nax.axvline(ParaVaR_95, ymin=0, ymax=0.2, color='b', ls=':', alpha=0.7, label='95% parametric VaR')\nax.plot(x, stats.norm.pdf(x, mu, std))\nax.legend()\nax.set_title(\"Return distribution\")\nax.set_xlabel(\"Return\")\nax.set_ylabel(\"Frequency\")\n"
      },
      {
        "id": "ex5",
        "title": "8.5 B2_Ch8_5.py",
        "filename": "B2_Ch8_5.py",
        "code": "# B2_Ch8_5.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch8_5_A.py\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport pandas_datareader\nimport seaborn as sns\n\ntickers = ['GOOGL','FB','AAPL','NFLX','AMZN']\nticker_num = len(tickers)\nprice_data = []\nfor ticker in range(ticker_num):   \n    prices = pandas_datareader.DataReader(tickers[ticker], start='2015-11-30', end = '2020-11-30', data_source='yahoo')   \n    price_data.append(prices[['Adj Close']])\n    df_stocks = pd.concat(price_data, axis=1)\ndf_stocks.columns = tickers\n\n\n\n# B2_Ch8_5_B.py\n# cumulative returns\nstock_return = []\nfor i in range(ticker_num):  \n    return_tmp = np.log(df_stocks[[tickers[i]]]/df_stocks[[tickers[i]]].shift(1))[1:]  \n    return_tmp = (return_tmp+1).cumprod()\n    stock_return.append(return_tmp[[tickers[i]]])\n    return_all = pd.concat(stock_return,axis=1)\nreturn_all.head()\n\n\n\n# B2_Ch8_5_C.py\n# plot cumulative returns of all stocks\nplt.style.use('ggplot')\nfor i, col in enumerate(return_all.columns):\n    return_all[col].plot()\nplt.title('Cumulative returns')\nplt.xlabel('Date')\nplt.ylabel('Return')\nplt.xticks(rotation=30)\nplt.legend(return_all.columns)\n\n\n\n# B2_Ch8_5_D.py\n# lastest return and price values\nlatest_return = return_all.iloc[-1,:]\nlatest_price = df_stocks.iloc[-1,:]\nsigma = latest_return.std()\n\n# weights for stocks in the portfolio\nstock_weight = [0.2, 0.3, 0.1, 0.15, 0.25] \n\n# calculate expected return\nexpected_return = latest_return.dot(stock_weight)\nprint('The weighted expected portfolio return: %.2f' % expected_return)\n\n# calculate weighted price\nprice = latest_price.dot(stock_weight)\nprint('The weighted price of the portfolio: %.0f' % price)\n\n\n\n# B2_Ch8_5_E.py\n# monte carlo simulation\nMC_num = 500\nconfidence_level = 0.95\ntime_step = 1440\nfor i in range(MC_num):  \n  daily_returns = np.random.normal(expected_return/time_step, sigma/np.sqrt(time_step), time_step)\n  plt.plot(daily_returns)\nplt.axhline(np.percentile(daily_returns,(1.0-confidence_level)*100), color='r', linestyle='dashed')\nplt.axhline(np.percentile(daily_returns,confidence_level*100), color='g', linestyle='dashed')\nplt.axhline(np.mean(daily_returns), color='b', linestyle='solid')\nplt.xlabel('Time')\nplt.ylabel('Return')\n\n\n\n# B2_Ch8_5_F.py\n# plot return distribution\nsns.distplot(daily_returns, kde=True, color='lightblue')\nplt.axvline(np.percentile(daily_returns,(1.0-confidence_level)*100), color='red', linestyle='dashed', linewidth=2)\nplt.title(\"Return distribution\")\nplt.xlabel('Return')\nplt.ylabel('Frequency')\nplt.show()\n\n\n# B2_Ch8_5_G.py\ninitial_investment  = 1000000\nVaR = initial_investment*np.percentile(daily_returns,(1.0-confidence_level)*100)\nprint('The value at risk is %.0f' % VaR)\n"
      }
    ]
  },
  {
    "id": "b2_ch9",
    "title": "ç¬¬9ç« ï¼šä¿¡ç”¨é¢¨éšª",
    "number": 9,
    "content": {
      "intro": "# ç¬¬ 9 ç« ï¼šä¿¡ç”¨é¢¨éšª - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   9.1 ä¿¡ç”¨é¢¨éšªçš„å®šç¾©èˆ‡åˆ†é¡ž\n*   9.2 ä¿¡ç”¨é¢¨éšªåº¦é‡æŒ‡æ¨™ (PD, LGD, EAD)\n*   9.3 ä¿¡ç”¨é¢¨éšªè³‡æ–™åˆ†æžèˆ‡å‰è™•ç†\n*   9.4 ä¿¡ç”¨é¢¨éšªè©•åˆ†å¡æ¨¡åž‹ (Scorecard Model)\n*   9.5 ä¿¡ç”¨è©•ç´šèˆ‡è½‰ç§»çŸ©é™£\n*   9.6 è‡ªå±•æ³• (Bootstrapping) æ±‚ç”Ÿå­˜çŽ‡\n*   9.7 å¥§ç‰¹æ›¼ Z åˆ†æ¨¡åž‹ (Altman Z-score)\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\nä¿¡ç”¨é¢¨éšªæ˜¯æŒ‡äº¤æ˜“å°æ‰‹ç„¡æ³•å±¥è¡Œåˆç´„ç¾©å‹™è€Œé€ æˆæå¤±çš„é¢¨éšªã€‚æœ¬ç« å¾žåŸºç¤Žçš„ä¿¡ç”¨åº¦é‡å‡ºç™¼ï¼Œé‡é»žä»‹ç´¹äº†é‡‘èžæ©Ÿæ§‹å¦‚ä½•åˆ©ç”¨è¡Œç‚ºæ•¸æ“šå»ºæ§‹è©•åˆ†å¡æ¨¡åž‹ï¼Œä¸¦é€éŽå‚³çµ±çš„ Z-score æ¨¡åž‹é€²è¡Œä¼æ¥­è²¡å‹™å¥åº·è¨ºæ–·ã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   ç†è§£ä¿¡ç”¨é¢¨éšªçš„æ ¸å¿ƒè¦ç´ ï¼šé•ç´„æ©ŸçŽ‡ (PD)ã€é•ç´„æå¤±çŽ‡ (LGD) èˆ‡é•ç´„é¢¨éšªæ›éœ² (EAD)ã€‚\n*   æŽŒæ¡è­‰æ“šæ¬Šé‡ (WOE) è½‰æ›èˆ‡è³‡è¨Šåƒ¹å€¼ (IV) åœ¨ç‰¹å¾µç¯©é¸ä¸­çš„æ‡‰ç”¨ã€‚\n*   å­¸æœƒåˆ©ç”¨å›žæ­¸æ¨¡åž‹å°‡é•ç´„æ©ŸçŽ‡è½‰æ›ç‚ºæ¨™æº–ä¿¡ç”¨åˆ†æ•¸ã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šåœ¨é›¶å”®éŠ€è¡Œæ¥­å‹™ä¸­ï¼Œæ ¹æ“šç”³è«‹äººçš„æ”¶å…¥ã€å¹´é½¡ã€æ­·å²ä¿¡ç”¨ç´€éŒ„è‡ªå‹•ç”¢å‡ºä¿¡ç”¨è©•åˆ†ã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šæŽŒæ¡ Altman Z-score çš„å…¬å¼çµ„æˆåŠå…¶åœ¨ä¸åŒç”¢æ¥­ä¸‹çš„è‡¨ç•Œå€¼ï¼ˆCut-off pointsï¼‰ã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch9_1.py** | **[æ ¸å¿ƒ]** å¯¦ä½œä¿¡ç”¨è©•åˆ†å¡æ¨¡åž‹ï¼Œæ¶µè“‹å–®è®Šæ•¸åˆ†ç®±ã€WOE è½‰æ›èˆ‡éš¨æ©Ÿæ£®æž—ç‰¹å¾µè©•ä¼°ã€‚ |\n| **B2_Ch9_2.py** | æ¼”ç¤ºä¿¡ç”¨è³‡ç”¢æ•¸æ“šçš„åŸºç¤Žçµ±è¨ˆåˆ†æžèˆ‡åœ–è¡¨è¦–è¦ºåŒ–ã€‚ |\n| **B2_Ch9_3.py** | **[å·¥å…·]** å¯¦ä½œ Altman Z-score ç ´ç”¢é æ¸¬æ¨¡åž‹ï¼Œè¨ˆç®—è²¡å‹™å¥åº·æŒ‡æ¨™ã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 9.4 ä¿¡ç”¨é¢¨éšªè©•åˆ†å¡æ¨¡åž‹\nè©•åˆ†å¡æ¨¡åž‹æ˜¯å°‡é‚è¼¯å›žæ­¸ç”¢å‡ºçš„é•ç´„æ©ŸçŽ‡ $p$ ç·šæ€§æ˜ å°„ç‚ºåˆ†æ•¸çš„éŽç¨‹ï¼š\n$$\\text{Score} = \\text{Offset} + \\text{Factor} \\times \\ln(\\text{odds})$$\nå…¶ä¸­ $\\text{odds} = \\frac{p}{1-p}$ã€‚é€éŽ WOE (Weight of Evidence) è½‰æ›ï¼Œå¯ä»¥è§£æ±ºè®Šæ•¸éžç·šæ€§èˆ‡é›¢ç¾¤å€¼å•é¡Œã€‚\n\n### 9.7 å¥§ç‰¹æ›¼ Z åˆ†æ¨¡åž‹\nZ-score æ˜¯é æ¸¬ä¼æ¥­ç ´ç”¢çš„ç¶“å…¸å¤šè®Šé‡æ¨¡åž‹ï¼Œçµåˆäº†æµå‹•æ€§ã€ç²åˆ©èƒ½åŠ›ã€è²¡å‹™æ§“æ¡¿ç­‰å¤šé …æŒ‡æ¨™ã€‚å®ƒæ˜¯ç›®å‰ä¿¡ç”¨é¢¨éšªåˆ†æžã€ä¾›æ‡‰éˆç®¡ç†ä¸­å¿…å‚™çš„å¿«é€Ÿç¯©é¸å·¥å…·ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\n### ðŸ“„ B2_Ch9_1.py - è©•åˆ†å¡å»ºæ¨¡å…¨æµç¨‹\n- **ä¸»è¦å‡½æ•¸**ï¼š`monotone_optimal_binning()`, `woe_conversion()`, `score_addon()`\n- **å¯¦ä½œé‡é»ž**ï¼šå¯¦ä½œå–®è®Šæ•¸å–®èª¿åˆ†ç®±ï¼ˆMonotone Binningï¼‰ä»¥ç¢ºä¿æ¨¡åž‹ç©©å®šæ€§ã€é€²è¡Œ WOE è½‰æ›ã€‚\n- **æŠ€è¡“ç´°ç¯€**ï¼šåˆ©ç”¨ `sklearn` é€²è¡Œè³‡æ–™åˆ†å‰²èˆ‡æ¨¡åž‹è¨“ç·´ï¼Œä½¿ç”¨ `RandomForestRegressor` è©•ä¼°ç‰¹å¾µé‡è¦æ€§ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šé•ç´„æ©ŸçŽ‡ (PD)ã€ä¿¡ç”¨è©•ç´šã€å›žæ”¶çŽ‡ (Recovery Rate)ã€‚\n\n### ðŸ“„ B2_Ch9_3.py - Altman Z-score å¯¦ä½œ\n- **ä¸»è¦å‡½æ•¸**ï¼š`Altman_Z_scorec()`\n- **å¯¦ä½œé‡é»ž**ï¼šå¯¦ä½œå„è²¡å‹™æ¯”çŽ‡çš„æ¬Šé‡è¨ˆç®—ã€‚æ·»åŠ é©ç•¶çš„éŒ¯èª¤è™•ç†æ©Ÿåˆ¶ï¼Œç¢ºä¿è¼¸å…¥æ•¸æ“šï¼ˆå¦‚è³‡ç”¢ã€è² å‚µã€ç‡Ÿæ”¶ï¼‰çš„ä¸€è‡´æ€§ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šä¼æ¥­ä¿¡ç”¨è©•ç´šã€è²¡å‹™é è­¦ã€é•ç´„æ©ŸçŽ‡ã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- ä¿¡ç”¨é¢¨éšªç®¡ç†çš„æ ¸å¿ƒæ˜¯æ•¸æ“šåˆ†æžèˆ‡æ¨¡åž‹å›žæ¸¬ï¼Œæ—¨åœ¨å€åˆ†ã€Œå¥½å®¢æˆ¶ã€èˆ‡ã€Œå£žå®¢æˆ¶ã€ã€‚\n- PD æ¨¡åž‹çš„æº–ç¢ºæ€§ç›´æŽ¥å½±éŸ¿éŠ€è¡Œçš„è³‡æœ¬ç•™å­˜ï¼ˆEconomic Capitalï¼‰èˆ‡å®šåƒ¹ç­–ç•¥ã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 4 ç« å›žæ­¸åˆ†æžï¼ˆå»ºæ¨¡åŸºç¤Žï¼‰ã€ç¬¬ 10 ç« äº¤æ˜“å°æ‰‹ä¿¡ç”¨é¢¨éšªï¼ˆè¡ç”Ÿå“å ´æ™¯ï¼‰ã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Altman (1968) åŽŸå§‹è«–æ–‡*.\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch9*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "9.1 B2_Ch9_1.py",
        "filename": "B2_Ch9_1.py",
        "code": "# B2_Ch9_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch9_1_A.py \n#import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.ensemble import RandomForestRegressor\nimport plotly.io as pio\nimport chart_studio.plotly\nfrom plotly.offline import plot\nimport plotly.graph_objects as go\nfrom  matplotlib.ticker import FuncFormatter\n\ndata = pd.read_csv(r'C:\\FRM Book\\CreditRisk\\cs-training.csv')\ndata = data.iloc[:,1:]\n\ndata.shape\ndata.info()\n\n\n# B2_Ch9_1_B.py \n# make a fancy table for the corresponding Chinese translation of the column names\ntranslation_map = {'SeriousDlqin2yrs':'ä¸¤å¹´å†…æ˜¯å¦è¿çº¦',\n                   'RevolvingUtilizationOfUnsecuredLines':'å¯ç”¨é¢åº¦æ¯”å€¼',\n                   'age':'å¹´é¾„',\n                   'NumberOfTime30-59DaysPastDueNotWorse':'å€Ÿè´·é€¾æœŸ30-59å¤©æ•°ç›®',\n                   'DebtRatio':'è´Ÿå€ºçŽ‡',\n                   'MonthlyIncome':'æœˆæ”¶å…¥',\n                   'NumberOfOpenCreditLinesAndLoans':'å€Ÿè´·æ•°é‡',\n                   'NumberOfTimes90DaysLate':'å€Ÿè´·é€¾æœŸ90å¤©æ•°ç›®',\n                   'NumberRealEstateLoansOrLines':'å›ºå®šèµ„äº§è´·æ¬¾é‡',\n                   'NumberOfTime60-89DaysPastDueNotWorse':'å€Ÿè´·é€¾æœŸ60-89å¤©æ•°ç›®',\n                   'NumberOfDependents':'å®¶å±žäººæ•°'}\n\npio.renderers.default = \"browser\"\ndf_transmap = pd.DataFrame.from_dict(translation_map, orient='index').reset_index()\ndf_transmap.columns = ['English', 'Chinese']\npio.renderers.default = \"browser\"\nfig = go.Figure(data=[go.Table(\n                                header = dict(values=list(df_transmap.columns),\n                                            fill_color = 'paleturquoise',\n                                            align='left'),\n                                cells = dict(values=[df_transmap.English, df_transmap.Chinese],\n                                           fill_color='lavender',\n                                           align='left'))\n])\n\nfig.show()\n\n\n\n# B2_Ch9_1_C.py \n# fill NA by random forest\ndata_process = data.iloc[:,[5,0,1,2,3,4,6,7,8,9]]\n# split to known and unknown\nknown = data_process[data_process.MonthlyIncome.notnull()].values\nunknown = data_process[data_process.MonthlyIncome.isnull()].values\n# training set\nX = known[:,1:]\ny = known[:,0]\n# fitting model\nmodel = RandomForestRegressor(random_state=0, n_estimators=200, max_depth=3, n_jobs=-1)\nmodel.fit(X,y)\n# pridict missing data\npred = model.predict(unknown[:,1:]).round(0)\n# fill missing data\ndata.loc[data['MonthlyIncome'].isnull(),'MonthlyIncome'] = pred\n\n\n# B2_Ch9_1_D.py\n# distribution of number of dependents\nsns.set(style=\"darkgrid\")\nax = sns.countplot(x='NumberOfDependents', data = data)\ntotal = float(len(data))\nfor p in ax.patches:\n    height = p.get_height()\n    ax.text(p.get_x()+p.get_width()/2.,\n            height + 3,\n            '{:.0f}%'.format(100 * p.get_height()/total),\n            ha=\"center\") \nax.set_title('Number of dependents count')    \nax.xaxis.set_major_formatter(FuncFormatter(lambda x, _: int(x)))\n\n\n\n# B2_Ch9_1_E.py \n# fill missing values of NumberOfDependents\nnum_Dependents = pd.Series([0,1,2,3,4]).copy()\nfor i in data['NumberOfDependents'][data['NumberOfDependents'].isnull()].index:\n    data['NumberOfDependents'][i] = num_Dependents.sample(1)\n\n# missing value and duplicate value deletion\ndata=data.dropna()\ndata=data.drop_duplicates()\n\n\n\n# B2_Ch9_1_F.py \n# age analysis\nfig = plt.figure()\nax = plt.subplot()\nax.boxplot(data['age'])\nax.set_xticklabels(['age'])\nax.set_ylabel('age (years old)')\n\n# remove outlier of age\ndata = data[data['age']>18]\ndata = data[data['age']<100]\n\n\n\n# B2_Ch9_1_G.py \n# analysis for RevolvingUtilizationOfUnsecuredLines and DebtRatio\nfig, (ax1, ax2) = plt.subplots(1,2)\nx1 = data['RevolvingUtilizationOfUnsecuredLines'].astype('float') \nx2 = data['DebtRatio'].astype('float')\nax1.boxplot(x1)\nax2.boxplot(x2)\nax1.set_xticklabels(['RevolvingUtilizationOfUnsecuredLines'])\nax2.set_xticklabels(['DebtRatio'])\nax1.set_ylabel('ratio')\n\n# remove outlier of RevolvingUtilizationOfUnsecuredLines and DebtRatio                    \ndata = data[(data['RevolvingUtilizationOfUnsecuredLines']>=0)&(data['RevolvingUtilizationOfUnsecuredLines']<=1)]\ndata = data[(data['DebtRatio']>=0)&(data['DebtRatio']<=1)]\n\n\n\n# B2_Ch9_1_K.py \n# analysis for number of time of default/past due\nfig, (ax1, ax2, ax3) = plt.subplots(1,3)\nx1 = data['NumberOfTime30-59DaysPastDueNotWorse']\nx2 = data['NumberOfTime60-89DaysPastDueNotWorse']\nx3 = data['NumberOfTimes90DaysLate']\nax1.boxplot(x1)\nax2.boxplot(x2)\nax3.boxplot(x3)\nax1.set_xticklabels(['NumberOfTime30-59DaysPastDueNotWorse'])\nax2.set_xticklabels(['NumberOfTime60-89DaysPastDueNotWorse'])\nax3.set_xticklabels(['NumberOfTimes90DaysLate'])\nax1.set_ylabel('Number of times of past due')\n\n# remove outlier of number of times past due                    \ndata = data[data['NumberOfTime30-59DaysPastDueNotWorse']<20]\ndata = data[data['NumberOfTime60-89DaysPastDueNotWorse']<20]\ndata = data[data['NumberOfTimes90DaysLate']<20]\n\n\n\n# B2_Ch9_1_L.py \n# client with good credit: 1; client with bad credit: 0\ndata['SeriousDlqin2yrs'] = 1-data['SeriousDlqin2yrs'] \nclient_group = data['SeriousDlqin2yrs'].groupby(data['SeriousDlqin2yrs']).count()\ngood_client_percentage = client_group[1]/(client_group[0]+client_group[1])\nbad_client_percentage = client_group[0]/(client_group[0]+client_group[1])\nax = client_group.plot(kind='bar')\nfor p in ax.patches:\n    width = p.get_width()\n    height = p.get_height()\n    x, y = p.get_xy() \n    ax.annotate(f'{height}', (x + width/2, y + height*1.02), ha='center')    \nax.set_ylabel('Client number')\nprint(\"percentage of good clients: \", format(good_client_percentage*100, '.2f'),\"%\")\nprint(\"percentage of bad clients: \", format(bad_client_percentage*100, '.2f'),\"%\")\n\n\n\n# B2_Ch9_1_M.py\n# age distribution\nax = sns.distplot(data['age'])\nax.set(xlabel='Age', ylabel='Distribution', title='Age distribution')\n\n\n\n# B2_Ch9_1_N.py \n# monthly income distribution\nax = sns.distplot(data[data['MonthlyIncome']<30000]['MonthlyIncome'])\nax.set(xlabel='Monthly income', ylabel='Distribution', title='Monthly income distribution')\n\n\n\n# B2_Ch9_1_O.py \n# heatmap: correlation of columns\ncorr = data.corr()\nfig = plt.figure(figsize=(14, 12))\nsns.heatmap(corr,annot = True, cmap=\"YlGnBu\")\nfig.tight_layout()\n\n\n\n# B2_Ch9_1_P.py \nfrom sklearn.model_selection import train_test_split\n\nY = data['SeriousDlqin2yrs']\nX = data.iloc[:,1:]\nX_train, X_test, Y_train, Y_test = train_test_split(X, Y, train_size = 0.8, random_state=0)\ntrain = pd.concat([Y_train,X_train], axis =1)\ntest = pd.concat([Y_test,X_test], axis =1)\ntrain = train.reset_index(drop=True)\ntest = test.reset_index(drop=True)\n# save test data to a file\ntest.to_csv('test.csv', index=False)\n\n\n\n# B2_Ch9_1_Q.py \nimport scipy.stats as stats\nimport numpy as np\ndef monotone_optimal_binning(X, Y, n):\n    r = 0\n    total_good = Y.sum()\n    total_bad = Y.count() - total_good\n    while np.abs(r) < 1:\n        d1 = pd.DataFrame({\"X\": X, \"Y\": Y, \"Bucket\": pd.qcut(X, n)})\n        d2 = d1.groupby('Bucket', as_index = True)\n        r, p = stats.spearmanr(d2.mean().X, d2.mean().Y)\n        n = n - 1\n    d3 = pd.DataFrame(d2.min().X, columns = ['min_' + X.name])\n    d3['min_' + X.name] = d2.min().X\n    d3['max_' + X.name] = d2.max().X\n    d3[Y.name] = d2.sum().Y\n    d3['total'] = d2.count().Y\n    # calculate WOE\n    d3['Goodattribute']=d3[Y.name]/total_good\n    d3['badattribute']=(d3['total']-d3[Y.name])/total_bad\n    d3['woe'] = np.log(d3['Goodattribute']/d3['badattribute'])\n    # calculate IV\n    iv = ((d3['Goodattribute']-d3['badattribute'])*d3['woe']).sum()\n    d4 = (d3.sort_values(by = 'min_' + X.name)).reset_index(drop = True)\n    print (\"=\" * 80)\n    print (d4)\n    cut = []\n    cut.append(float('-inf'))\n    for i in range(1,n+1):\n        qua =X.quantile(i/(n+1))\n        cut.append(round(qua,4))\n    cut.append(float('inf'))\n    woe = list(d4['woe'].round(3))\n    return d4, iv, cut, woe\n\ndfx1, ivx1, cutx1, woex1 = monotone_optimal_binning(data['RevolvingUtilizationOfUnsecuredLines'], data['SeriousDlqin2yrs'], n = 10)\ndfx2, ivx2, cutx2, woex2 = monotone_optimal_binning(data['age'], data['SeriousDlqin2yrs'], n = 10)\ndfx4, ivx4, cutx4, woex4 = monotone_optimal_binning(data['DebtRatio'], data['SeriousDlqin2yrs'], n = 20)\n\n\n\n# B2_Ch9_1_R.py \ndef self_binning(Y, X, cat):\n    good = Y.sum()\n    bad = Y.count()-good\n    d1 = pd.DataFrame({'X':X,'Y':Y,'Bucket':pd.cut(X,cat)})\n    d2 = d1.groupby('Bucket', as_index = True)\n    d3 = pd.DataFrame(d2.X.min(), columns=['min'])\n    d3['min'] = d2.min().X\n    d3['max'] = d2.max().X\n    d3['sum'] = d2.sum().Y\n    d3['total'] = d2.count().Y\n    d3['rate'] = d2.mean().Y\n    d3['woe'] = np.log((d3['rate'] / (1 - d3['rate'])) / (good / bad))\n    d3['goodattribute'] = d3['sum'] / good\n    d3['badattribute'] = (d3['total'] - d3['sum']) / bad\n    iv = ((d3['goodattribute'] - d3['badattribute']) * d3['woe']).sum()\n    d4 = d3.sort_values(by='min')\n    print(\"=\" * 60)\n    print(d4)\n    woe = list(d4['woe'].round(3))\n    return d4, iv,woe\n\npinf = float('inf')\nninf = float('-inf')\ncutx3 = [ninf, 0, 1, 3, 5, pinf]\ncutx5 = [ninf,1000,2000,3000,4000,5000,6000,7500,9500,12000,pinf]\ncutx6 = [ninf, 1, 2, 3, 5, pinf]\ncutx7 = [ninf, 0, 1, 3, 5, pinf]\ncutx8 = [ninf, 0,1,2, 3, pinf]\ncutx9 = [ninf, 0, 1, 3, pinf]\ncutx10 = [ninf, 0, 1, 2, 3, 5, pinf]\ndfx3, ivx3,woex3 = self_binning(data['SeriousDlqin2yrs'],data['NumberOfTime30-59DaysPastDueNotWorse'],cutx3)\ndfx5, ivx5,woex5 = self_binning(data['SeriousDlqin2yrs'],data['MonthlyIncome'],cutx5)\ndfx6, ivx6,woex6 = self_binning(data['SeriousDlqin2yrs'],data['NumberOfOpenCreditLinesAndLoans'],cutx6) \ndfx7, ivx7,woex7 = self_binning(data['SeriousDlqin2yrs'],data['NumberOfTimes90DaysLate'],cutx7)\ndfx8, ivx8,woex8 = self_binning(data['SeriousDlqin2yrs'],data['NumberRealEstateLoansOrLines'],cutx8) \ndfx9, ivx9,woex9 = self_binning(data['SeriousDlqin2yrs'],data['NumberOfTime60-89DaysPastDueNotWorse'],cutx9)\ndfx10, ivx10,woex10 = self_binning(data['SeriousDlqin2yrs'],data['NumberOfDependents'],cutx10)\n\n\n\n# B2_Ch9_1_S.py \nivlist=[ivx1,ivx2,ivx3,ivx4,ivx5,ivx6,ivx7,ivx8,ivx9,ivx10]\nindex=['x1','x2','x3','x4','x5','x6','x7','x8','x9','x10']\nsns.set(style=\"darkgrid\")\nfig, ax = plt.subplots(1)\nx = np.arange(len(index))+1\nax.bar(x, ivlist, width=0.4)\nax.set_xticks(x)\nax.set_xticklabels(index, rotation=0, fontsize=12)\nax.set_xlabel('Variable', fontsize=14)\nax.set_ylabel('Information value', fontsize=14)\n\nfor a, b in zip(x, ivlist):\n    plt.text(a, b+0.01, '%.2f'%b, ha='center', va='bottom', fontsize=10)\n\n\n\n# B2_Ch9_1_T.py \n# woe conversion\ndef woe_conversion(series,cut,woe):\n    list=[]\n    i=0\n    while i<len(series):\n        try:\n            value=series[i]\n        except:\n            i += 1\n            continue\n        j=len(cut)-2\n        m=len(cut)-2\n        while j>=0:\n            if value>=cut[j]:\n                j=-1\n            else:\n                j -=1\n                m -= 1\n        list.append(woe[m])\n        i += 1\n    return list\n\ntrain['RevolvingUtilizationOfUnsecuredLines'] = pd.Series(woe_conversion(train['RevolvingUtilizationOfUnsecuredLines'], cutx1, woex1))\ntrain['age'] = pd.Series(woe_conversion(train['age'], cutx2, woex2))\ntrain['NumberOfTime30-59DaysPastDueNotWorse'] = pd.Series(woe_conversion(train['NumberOfTime30-59DaysPastDueNotWorse'], cutx3, woex3))\ntrain['DebtRatio'] = pd.Series(woe_conversion(train['DebtRatio'], cutx4, woex4))\ntrain['MonthlyIncome'] = pd.Series(woe_conversion(train['MonthlyIncome'], cutx5, woex5))\ntrain['NumberOfOpenCreditLinesAndLoans'] = pd.Series(woe_conversion(train['NumberOfOpenCreditLinesAndLoans'], cutx6, woex6))\ntrain['NumberOfTimes90DaysLate'] = pd.Series(woe_conversion(train['NumberOfTimes90DaysLate'], cutx7, woex7))\ntrain['NumberRealEstateLoansOrLines'] = pd.Series(woe_conversion(train['NumberRealEstateLoansOrLines'], cutx8, woex8))\ntrain['NumberOfTime60-89DaysPastDueNotWorse'] = pd.Series(woe_conversion(train['NumberOfTime60-89DaysPastDueNotWorse'], cutx9, woex9))\ntrain['NumberOfDependents'] = pd.Series(woe_conversion(train['NumberOfDependents'], cutx10, woex10))\ntrain.dropna(how = 'any')\ntrain.to_csv('WoeData.csv', index=False)\n\ntest['RevolvingUtilizationOfUnsecuredLines'] = pd.Series(woe_conversion(test['RevolvingUtilizationOfUnsecuredLines'], cutx1, woex1))\ntest['age'] = pd.Series(woe_conversion(test['age'], cutx2, woex2))\ntest['NumberOfTime30-59DaysPastDueNotWorse'] = pd.Series(woe_conversion(test['NumberOfTime30-59DaysPastDueNotWorse'], cutx3, woex3))\ntest['DebtRatio'] = pd.Series(woe_conversion(test['DebtRatio'], cutx4, woex4))\ntest['MonthlyIncome'] = pd.Series(woe_conversion(test['MonthlyIncome'], cutx5, woex5))\ntest['NumberOfOpenCreditLinesAndLoans'] = pd.Series(woe_conversion(test['NumberOfOpenCreditLinesAndLoans'], cutx6, woex6))\ntest['NumberOfTimes90DaysLate'] = pd.Series(woe_conversion(test['NumberOfTimes90DaysLate'], cutx7, woex7))\ntest['NumberRealEstateLoansOrLines'] = pd.Series(woe_conversion(test['NumberRealEstateLoansOrLines'], cutx8, woex8))\ntest['NumberOfTime60-89DaysPastDueNotWorse'] = pd.Series(woe_conversion(test['NumberOfTime60-89DaysPastDueNotWorse'], cutx9, woex9))\ntest['NumberOfDependents'] = pd.Series(woe_conversion(test['NumberOfDependents'], cutx10, woex10))\ntest.dropna(how = 'any')\n\ntrain_X =train.drop(['NumberRealEstateLoansOrLines','NumberOfDependents','NumberOfOpenCreditLinesAndLoans','DebtRatio','MonthlyIncome'],axis=1)\ntest_X =test.drop(['NumberRealEstateLoansOrLines','NumberOfDependents','NumberOfOpenCreditLinesAndLoans','DebtRatio','MonthlyIncome'],axis=1)\n\n\n\n# B2_Ch9_1_U.py \nfrom sklearn.metrics import roc_curve, auc\nimport statsmodels.api as sm\n\nX_train =train_X.drop(['SeriousDlqin2yrs'],axis =1)\ny_train =train_X['SeriousDlqin2yrs']\ny_test = test_X['SeriousDlqin2yrs']\nX_test = test_X.drop(['SeriousDlqin2yrs'],axis =1)\nX_train = sm.add_constant(X_train)\nmodel = sm.Logit(y_train,X_train)\nresult = model.fit()\nprint(result.summary2())\n\n\n\n# B2_Ch9_1_V.py \nfrom sklearn.metrics import roc_curve, auc\n\nX2 = sm.add_constant(X_test)\nresu = result.predict(X2)\nFPR,TPR,threshold = roc_curve(y_test,resu)\nROC_AUC = auc(FPR,TPR)\nplt.plot(FPR, TPR, 'b', label='AUC = %0.2f' % ROC_AUC)\nplt.legend(loc='lower right')\nplt.plot([0, 1], [0, 1], 'r--')\nplt.xlim([0, 1])\nplt.ylim([0, 1])\nplt.ylabel('TPR')\nplt.xlabel('FPR')\n\n\n\n# B2_Ch9_1_W.py \n# regression coeficients\ncoe = result.params\n\nimport numpy as np\n# set benchmark score as 600; PDO as 10; Odds as 10\nbenchmark = 600\npdo = 10\nodds = 10\nfactor = pdo/np.log(2)\noffset = benchmark-factor*np.log(odds)\nbaseScore = round(offset + factor * coe[0], 0)\n\n\n\n# B2_Ch9_1_X.py \n# function to calculate addon score for a single variable\ndef score_addon(coe,woe,factor):\n    addon = []\n    for w in woe:\n        score = round(coe*w*factor,0)\n        addon.append(score)\n    return addon\n\n# calculate addon score \nx1 = score_addon(coe[1], woex1, factor)\nx2 = score_addon(coe[2], woex2, factor)\nx3 = score_addon(coe[3], woex3, factor)\nx7 = score_addon(coe[4], woex7, factor)\nx9 = score_addon(coe[5], woex9, factor)\nprint('x1: ', x1)\nprint('x2: ', x2)\nprint('x3: ', x3)\nprint('x7: ', x7)\nprint('x9: ', x9)\n\n\n# B2_Ch9_1_Y.py \n# compute score for single variable\ndef single_variable_score(series,cut,score):\n    list = []\n    i = 0\n    while i < len(series):\n        value = series[i]\n        j = len(cut) - 2\n        m = len(cut) - 2\n        while j >= 0:\n            if value >= cut[j]:\n                j = -1\n            else:\n                j -= 1\n                m -= 1\n        list.append(score[m])\n        i += 1\n    return list\n\n\n\n# B2_Ch9_1_Z.py \nfrom pandas import Series\n\ntest = pd.read_csv('test.csv')\ntest['BaseScore']=Series(np.zeros(len(test))) + baseScore\ntest['x1'] = Series(single_variable_score(test['RevolvingUtilizationOfUnsecuredLines'], cutx1, x1))\ntest['x2'] = Series(single_variable_score(test['age'], cutx2, x2))\ntest['x3'] = Series(single_variable_score(test['NumberOfTime30-59DaysPastDueNotWorse'], cutx3, x3))\ntest['x7'] = Series(single_variable_score(test['NumberOfTimes90DaysLate'], cutx7, x7))\ntest['x9'] = Series(single_variable_score(test['NumberOfTime60-89DaysPastDueNotWorse'], cutx9, x9))\ntest['Score'] = test['x1'] + test['x2'] + test['x3'] + test['x7'] +test['x9']  + baseScore\ntest.to_csv('ScoreData.csv', index=False)\n\nfiltered_columns = ['SeriousDlqin2yrs','BaseScore', 'x1', 'x2', 'x3', 'x7', 'x9', 'Score']\ndisplaytable = test.reindex(columns = filtered_columns)\ndisplaytable.head()\n\n\n\n"
      },
      {
        "id": "ex2",
        "title": "9.2 B2_Ch9_2.py",
        "filename": "B2_Ch9_2.py",
        "code": "# B2_Ch9_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nCDS_spreads = pd.read_csv(\"C:\\\\Dropbox\\\\FRM Book\\\\CreditRisk\\\\CDS_spreads.csv\")\ndf = pd.DataFrame(CDS_spreads)\n\ndf['Survival'] = 0.0\nnumerator1 = 0.0\nnumerator2 = 0.0\ndenominator1 = 0.0\ndenominator2 = 0.0\nterm_final = 0.0\n\ndf['Spread'] = df['Spread']/10000\n\nRR = df.at[0,'Recovery']\nL = 1.0 - RR\n\nt1 = df.at[0, 'Maturity']\nt2 = df.at[1, 'Maturity']\ndelta_t = t2-t1\n\nfor row_index,row in df.iterrows():\n    if(row_index == 0):\n        df.at[0,'Survival'] = 1\n    if(row_index==1):\n        df.at[1,'Survival'] = L / (L + (delta_t * df.at[1,'Spread']))\n    if(row_index>1):\n        temp_counter = row_index\n        term1 = 0.0\n        term2 = 0.0\n        j = 1\n        while(j > row_index-1):\n            numerator1_temp = df.at[row_index,'DF'] * ((L * df.at[row_index - 1,'Survival']) - ((L + (delta_t * df.at[row_index,'Spread']))*(df.at[row_index,'Survival'])))\n            numerator1 = numerator1 + numerator1_temp\n            row_index = row_index - 1\n        row_index = temp_counter\n        denominator1 = ((df.at[row_index,'DF']) * (L + (delta_t * df.at[row_index,'Spread'])))\n        term1_temp = numerator1/denominator1\n        term1 = term1 + term1_temp\n\n        numerator2 = (L * df.at[row_index - 1,'Survival'])\n        denominator2 = (L + (delta_t * df.at[row_index,'Spread']))\n        term2_temp = numerator2/denominator2\n        term2 = term2 + term2_temp\n        term_final = term1 + term2\n        df.at[row_index, 'Survival'] = term_final\n            \nplt.plot(df['Maturity'], df['Survival'])\nplt.title('Survival probability')\nplt.xlabel('Maturity')\nplt.ylabel('Survival probability')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')  \n"
      },
      {
        "id": "ex3",
        "title": "9.3 B2_Ch9_3.py",
        "filename": "B2_Ch9_3.py",
        "code": "# B2_Ch9_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# calculate Altman Z-Score fore public corporation\ndef Altman_Z_scorec(WC,TA,RE,EBIT,MVE,TL,S):\n    # WC: Working Capital\n    # TA: Total Assests\n    # RE: Retained Earnings\n    # EBIT: Earnings Before Interest and Tax\n    # MVE: Market Value of Equity\n    # TL: Total Liabilities\n    # S: Net Sales\n    \n    X1 = WC/TA;\n    X2 = RE/TA;\n    X3 = EBIT/TA;\n    X4 = MVE/TL;\n    X5 = S/TA;\n     \n    # calculate z-score\n    Z_score = 1.2*X1 + 1.4*X2 + 3.3*X3 + .6*X4 + X5;\n    print('Altman value is ', round(Z_score, 2))\n    \n    # display results\n    if Z_score > 3.0:    \n        print('Business is healthy.')\n    elif Z_score < 1.8:\n        print('Business is bankrupt.')\n    else: \n        print('Business is intermediate.')\n"
      }
    ]
  },
  {
    "id": "b2_ch10",
    "title": "ç¬¬10ç« ï¼šäº¤æ˜“å°æ‰‹ä¿¡ç”¨é¢¨éšª",
    "number": 10,
    "content": {
      "intro": "# ç¬¬ 10 ç« ï¼šäº¤æ˜“å°æ‰‹ä¿¡ç”¨é¢¨éšª - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   10.1 äº¤æ˜“å°æ‰‹ä¿¡ç”¨é¢¨éšª (CCR) æ ¸å¿ƒæ¦‚å¿µ\n*   10.2 äº¤æ˜“å°æ‰‹ä¿¡ç”¨é¢¨éšªåº¦é‡èˆ‡æ¨¡åž‹\n*   10.3 é æœŸæ­£æ›éœ² (EE) èˆ‡æœ€å¤§æ½›åœ¨æœªä¾†é¢¨éšªæ›éœ² (PFE)\n*   10.4 é æœŸåˆç´„ (Forwards) çš„äº¤æ˜“å°æ‰‹ä¿¡ç”¨é¢¨éšª\n*   10.5 åˆ©çŽ‡äº’æ› (IRS) çš„äº¤æ˜“å°æ‰‹ä¿¡ç”¨é¢¨éšª\n*   10.6 è²¨å¹£äº’æ› (CIRS) çš„äº¤æ˜“å°æ‰‹ä¿¡ç”¨é¢¨éšª\n*   10.7 ä¿¡ç”¨é¢¨éšªç·©é‡‹ (Mitigation)ï¼šæ·¨é¡çµç®—èˆ‡æŠµæŠ¼å“\n*   10.8 ä¿¡ç”¨ä¼°å€¼èª¿æ•´ (CVA) èˆ‡å®šåƒ¹\n*   10.9 éŒ¯å‘é¢¨éšª (Wrong-Way Risk) åˆ†æž\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\näº¤æ˜“å°æ‰‹ä¿¡ç”¨é¢¨éšªï¼ˆCCRï¼‰æ˜¯è¡ç”Ÿå“å¸‚å ´ä¸­ç‰¹æœ‰çš„é¢¨éšªã€‚èˆ‡å‚³çµ±å‚µåˆ¸ä¿¡ç”¨é¢¨éšªä¸åŒï¼ŒCCR çš„é¢¨éšªæ›éœ²ï¼ˆExposureï¼‰å…·æœ‰éš¨æ©Ÿæ€§ä¸”é›™å‘è®Šå‹•ã€‚æœ¬ç« æ·±å…¥æŽ¢è¨Žå¦‚ä½•åˆ©ç”¨è’™åœ°å¡ç¾…æ¨¡æ“¬èˆ‡é‡‘èžå·¥ç¨‹æ¨¡åž‹ï¼Œé‡åŒ–äº¤æ˜“å°æ‰‹é•ç´„å¸¶ä¾†çš„æ½›åœ¨éš¨æ©Ÿæå¤±ï¼Œä¸¦ä»‹ç´¹äº†ç¾ä»£é‡‘èžæ ¸å¿ƒæŒ‡æ¨™ CVA çš„è¨ˆç®—ã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   ç†è§£ç‚ºä½•è¡ç”Ÿå“çš„ä¿¡ç”¨æ›éœ²æ˜¯é›™å‘ä¸”éš¨æ©Ÿçš„ã€‚\n*   æŽŒæ¡é æœŸæ›éœ² (EE) èˆ‡æ½›åœ¨æœªä¾†æ›éœ² (PFE) çš„è¨ˆç®—é‚è¼¯èˆ‡ç½®ä¿¡æ°´å¹³ã€‚\n*   æŽŒæ¡ CVA çš„å®šåƒ¹å…¬å¼åŠå…¶åœ¨ç„¡é¢¨éšªä¸­æ€§ä¸‹çš„å°æ²–æ„ç¾©ã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šè¨ˆç®—åˆ©çŽ‡äº’æ› (IRS) çš„ CVA è²»ç”¨ï¼Œå°‡ä¿¡ç”¨æº¢åƒ¹åŒ…å«åœ¨åˆç´„å®šåƒ¹ä¸­ï¼ˆXVA ç®¡ç†ï¼‰ã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šç†è§£ EE æ›²ç·šçš„å½¢ç‹€å¦‚ä½•å—åˆç´„åˆ°æœŸæ™‚é–“èˆ‡å‡å€¼å›žæ­¸ç‰¹æ€§çš„å½±éŸ¿ã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch10_1.py** | å®šç¾©æ©ŸçŽ‡å¯†åº¦å‡½æ•¸ (PDF) åœ–è¡¨ç¹ªè£½èˆ‡çµ±è¨ˆç‰¹å¾µåˆ†æžã€‚ |\n| **B2_Ch10_2.py** | æ¼”ç¤ºå¤šå­åœ–ä½ˆå±€åœ¨é¢¨éšªæ•¸æ“šåˆ†ä½ˆå°æ¯”ä¸­çš„æ‡‰ç”¨ã€‚ |\n| **B2_Ch10_3.py** | è¦–è¦ºåŒ–å‘ˆç¾çµ±è¨ˆåˆ†ä½ˆå‡½æ•¸æ›²ç·šï¼Œæè¿°åŸºç¤Žé¢¨éšªå› å­ç‰¹å¾µã€‚ |\n| **B2_Ch10_4.py** | æ¼”ç¤ºæ•¸æ“šç›´æ–¹åœ–èˆ‡æ©ŸçŽ‡å¯†åº¦æ›²ç·šçš„æ“¬åˆå„ªåº¦è¦–è¦ºåŒ–ã€‚ |\n| **B2_Ch10_5.py** | **[æ ¸å¿ƒ]** åˆ©ç”¨ QuantLib é€²è¡Œè’™åœ°å¡ç¾…æ¨¡æ“¬ï¼Œåˆ†æžéš¨æ©ŸéŽç¨‹çš„è·¯å¾‘æ¼”åŒ–èˆ‡ EE/PFE æŒ‡æ¨™ã€‚ |\n| **B2_Ch10_6.py** | æ¼”ç¤ºåæ…‹èˆ‡å³°æ…‹å°é¢¨éšªåˆ†ä½ˆåœ–å½¢çš„å½±éŸ¿åŠå…¶çµ±è¨ˆæ„ç¾©ã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 10.3 æ›éœ²æŒ‡æ¨™ï¼šEE èˆ‡ PFE\n- **é æœŸæ­£æ›éœ² (Expected Exposure, EE)**ï¼šåœ¨çµ¦å®šæ™‚é–“é»žæ›éœ²çš„å¹³å‡å€¼ã€‚ç”¨æ–¼è¨ˆç®— CVAã€‚\n- **æ½›åœ¨æœªä¾†é¢¨éšªæ›éœ² (Potential Future Exposure, PFE)**ï¼šåœ¨ç‰¹å®šç½®ä¿¡æ°´å¹³ï¼ˆå¦‚ 95% æˆ– 99%ï¼‰ä¸‹çš„æœ€å¤§å¯èƒ½æ›éœ²ã€‚ç”¨æ–¼ä¿¡ç”¨é¡åº¦ç®¡ç†ï¼ˆCredit Limitsï¼‰ã€‚\n\n### 10.8 ä¿¡ç”¨ä¼°å€¼èª¿æ•´ (CVA)\nCVA æ˜¯è¡ç”Ÿå“å…¬å¹³åƒ¹å€¼èˆ‡ç„¡é•ç´„åƒ¹å€¼ä¹‹é–“çš„å·®é¡ã€‚å…¬å¼ç°¡åŒ–ç‚ºï¼š\n$$\\text{CVA} \\approx (1-R) \\sum \\text{EE}(t) \\times \\text{Prob}(\\text{Default between } t_{i-1}, t_i)$$\nå…¶ä¸­ $R$ ç‚ºå›žæ”¶çŽ‡ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\n### ðŸ“„ B2_Ch10_5.py - éš¨æ©Ÿè·¯å¾‘èˆ‡æ›éœ²æ¨¡æ“¬\n- **ä¸»è¦å¥—ä»¶**ï¼š`QuantLib`, `numpy`\n- **å¯¦ä½œé‡é»ž**ï¼šä½¿ç”¨éš¨æ©Ÿæ•¸ç”Ÿæˆå™¨é€²è¡Œæ¨¡æ“¬ï¼ˆMonte Carloï¼‰ã€‚ç”Ÿæˆè¬æ¬¡è·¯å¾‘å¾Œï¼Œåœ¨æ¯å€‹æ™‚é–“é»žè¨ˆç®—åˆ†ä½æ•¸ï¼ˆPercentileï¼‰ä»¥å¾—åˆ° PFE æ›²ç·šã€‚\n- **æŠ€è¡“ç´°ç¯€**ï¼šæ³¨æ„æ¨¡æ“¬æ¬¡æ•¸å°çµæžœç²¾åº¦çš„å½±éŸ¿ï¼Œé©ç•¶è¨­å®šéš¨æ©Ÿç¨®å­ä»¥ç¢ºä¿çµæžœå¯é‡ç¾ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šé æœŸæ­£æ›éœ² (EE)ã€æœ€å¤§æ½›åœ¨æœªä¾†é¢¨éšªæ›éœ² (PFE)ã€ä¿¡ç”¨åˆ©å·®ã€‚\n\n### ðŸ“„ B2_Ch10_1.py è‡³ B2_Ch10_6.py - çµ±è¨ˆæ•¸æ“šè™•ç†\n- **å¯¦ä½œé‡é»ž**ï¼šç¢ºä¿é¢¨éšªåº¦é‡çš„ä¸€è‡´æ€§ï¼Œè€ƒæ…®æ¥µç«¯å¸‚å ´æƒ…æ³çš„å½±éŸ¿ã€‚å®šæœŸå›žæ¸¬æ¨¡åž‹çš„æœ‰æ•ˆæ€§ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šæ©ŸçŽ‡åˆ†ä½ˆã€é¢¨éšªæŒ‡æ¨™åˆ†ä½ˆã€ä¿¡ç”¨è©•ç´šã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- CCR çš„ç®¡ç†ä¸åƒ…æ˜¯ç®—ä¸€å€‹åˆ†æ•¸ï¼Œæ›´æ˜¯ç®¡ç†ä¸€æ¢éš¨æ™‚é–“å‹•æ…‹è®ŠåŒ–çš„æ›éœ²æ›²ç·šã€‚\n- CVA çš„å¼•å…¥å°‡ä¿¡ç”¨é¢¨éšªå¾žã€Œé™é¡æŽ§åˆ¶ã€æå‡åˆ°äº†ã€Œè³‡æœ¬æˆæœ¬ã€èˆ‡ã€Œå¸‚åƒ¹åŒ–ã€çš„å±¤æ¬¡ã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 3 ç« è’™åœ°å¡ç¾…ï¼ˆæŠ€è¡“åŸºç¤Žï¼‰ã€ç¬¬ 9 ç« ä¿¡ç”¨é¢¨éšªï¼ˆé•ç´„æ©ŸçŽ‡ä¾†æºï¼‰ã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Gregory (2012) Counterparty Credit Risk and Credit Value Adjustment*.\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch10*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "10.1 B2_Ch10_1.py",
        "filename": "B2_Ch10_1.py",
        "code": "# B2_Ch10_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nimport scipy.stats as stats\n\n# parameters\nmu = 3.0 \nsigma = 5.0\nalpha = 0.97\n\n# generate normal distribution\nx1 = mu-20\nx2 = mu+20\nx = np.arange(x1, x2, 0.001)\ny = norm.pdf(x, mu, sigma)\n\n# calculate EE and PFE\nEE = mu*stats.norm.cdf(mu/sigma) + sigma*stats.norm.pdf(mu/sigma)\nPFE = mu + sigma*stats.norm.ppf(alpha)\nprint(' EE: ', round(EE,2)) \nprint(' PFE: ', round(PFE,2))\n\n# plot and identify EE PFE\nfig, ax = plt.subplots(figsize=(9, 6))\nax.plot(x, y)\n\n# fill exposure area\nx0 = np.arange(0, x2, 0.001)\ny0 = norm.pdf(x0, mu, sigma)\nax.fill_between(x0, y0, 0, color='moccasin')\nax.fill_between(x, y, 0, alpha=0.5, color='palegreen')\n\n# draw vertical line to identify mu, EE and PFE\nax.vlines(mu, 0, norm.pdf(mu, mu, sigma), linestyles =\"dashed\", colors =\"#B7DEE8\", label='$\\\\mu$')\nax.vlines(EE, 0, norm.pdf(EE, mu, sigma), linestyles =\"dashed\", colors =\"#0070C0\", label='EE')\nax.vlines(PFE, 0, norm.pdf(PFE, mu, sigma), linestyles =\"dashed\", colors =\"#3C9DFF\", label='PFE')\n\n# add x ticks to mu, EE and PFE\nfig.canvas.draw()\nlabels = [w.get_text() for w in ax.get_xticklabels()]\nlocs = list(ax.get_xticks())\nlabels += ['$\\\\mu$', '$EE$', '$PFE$']\nlocs += [mu, EE, PFE]\nax.set_xticks(locs) \nax.set_xticklabels(labels)\n\n# add lables and title\nax.set_xlabel('MtM')\nax.set_ylabel('Probability')\nax.set_title('EE and PFE for a Normal Distribution')\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.yaxis.set_ticks_position('left')\nax.xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex2",
        "title": "10.2 B2_Ch10_2.py",
        "filename": "B2_Ch10_2.py",
        "code": "# B2_Ch10_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf = pd.read_csv(r'C:\\Users\\anran\\Dropbox\\FRM Book\\CCR\\EE.csv')\n\neffective_ee = []\neffective_ee.append(df['EE'].iloc[0]) \nfor i in range(1, len(df.index)):\n    effective_ee.append(max(effective_ee[i-1], df['EE'].iloc[i]))\n\n# Effective EE    \ndf['Effective EE'] = effective_ee\n# calculate EPE\nepe = np.mean(df['EE'])\n# calculate Effective EPE\neffective_epe = np.mean(df['Effective EE'])\n\n# plot\nfig, ax = plt.subplots(figsize=(10, 6))\nax.plot(df['Time'], df['EE'], '-o', label='EE')\nax.plot(df['Time'], df['Effective EE'], '-o', label='Effective EE')\nax.hlines(epe, 0, 1, linestyles =\"dashed\", colors =\"#0070C0\", label='EPE')\nax.hlines(effective_epe, 0, 1, linestyles =\"dashed\", colors =\"#3C9DFF\", label='Effective EPE')\nax.legend()\n\n# add lables and title\nax.set_xlabel('Time')\nax.set_ylabel('Exposure')\nax.set_xlim([0.0, 1.0])\nax.set_ylim([0.0, 1.0])\nax.set_title('EE, Effective EE, EPE and Effective EPE')\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.yaxis.set_ticks_position('left')\nax.xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex3",
        "title": "10.3 B2_Ch10_3.py",
        "filename": "B2_Ch10_3.py",
        "code": "# B2_Ch10_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# parameters\ndrift = 0.05\nvol = 0.10\nconfidence_level = 0.99\nT = 5\n\n# calculate pfe\nt = np.arange(0.0, T, 0.01)\nforward_pfe = drift*t+vol*np.sqrt(t)*norm.ppf(confidence_level)\n\n# plot\nplt.style.use('fast')\nplt.plot(t, forward_pfe)\nplt.grid(True)\nplt.xlabel(\"Time in years\")\nplt.ylabel(\"PFE\")\nplt.title(\"PFE Evolution -- Forward\")\nplt.grid(None)  \nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex4",
        "title": "10.4 B2_Ch10_4.py",
        "filename": "B2_Ch10_4.py",
        "code": "# B2_Ch10_4.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# parameters\ninterest_rate_vol = 0.005\nconfidence_level = 0.99\nT = 25.0\n\n# calcualte pfe\nt = np.arange(0.0, T, 0.05)\nirs_pfe = interest_rate_vol*np.sqrt(t)*(T-t)*norm.ppf(confidence_level)\n\n# plot\nplt.style.use('fast')\nplt.plot(t, irs_pfe)\nplt.xlabel(\"Time in years\")\nplt.ylabel(\"PFE\")\nplt.title(\"PFE Evolution -- Interest Rate Swap\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex5",
        "title": "10.5 B2_Ch10_5.py",
        "filename": "B2_Ch10_5.py",
        "code": "# B2_Ch10_5.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch10_5_A.py \n# import libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport QuantLib as ql\n\n# set evaluation date\ntoday = ql.Date(15,10,2020)\nql.Settings.instance().setEvaluationDate = today\n\n# set Marketdata\nrate = ql.SimpleQuote(0.025)\nrate_handle = ql.QuoteHandle(rate)\ndc = ql.Actual365Fixed()\ncrv = ql.FlatForward(today, rate_handle, dc)\ncrv.enableExtrapolation()\nyts = ql.YieldTermStructureHandle(crv)\nhyts = ql.RelinkableYieldTermStructureHandle(crv)\nindex = ql.Euribor6M(hyts)\n\n\n\n# B2_Ch10_5_B.py\n# set a swap\nstart = today + ql.Period(\"2d\")\nmaturity = ql.Period(\"4Y\")\nend = ql.TARGET().advance(start, maturity)\nnominal = 3e8\nfixedRate = 0.025\ntyp = ql.VanillaSwap.Receiver\nspread = 0.0\n\nfixedSchedule = ql.Schedule(start,\n                            end, \n                            ql.Period(\"1y\"), \n                            index.fixingCalendar(), \n                            ql.ModifiedFollowing,\n                            ql.ModifiedFollowing, \n                            ql.DateGeneration.Backward,\n                            False)\nfloatSchedule = ql.Schedule(start,\n                            end,\n                            index.tenor(),\n                            index.fixingCalendar(),\n                            index.businessDayConvention(),\n                            index.businessDayConvention(),\n                            ql.DateGeneration.Backward,\n                            False)\nswap = ql.VanillaSwap(typ, \n                      nominal,\n                      fixedSchedule,\n                      fixedRate,\n                      ql.Thirty360(ql.Thirty360.BondBasis),\n                      floatSchedule,\n                      index,\n                      spread,\n                      index.dayCounter())\n\n# pricing engine and npv\nengine = ql.DiscountingSwapEngine(hyts)\nswap.setPricingEngine(engine)\nswap.NPV()\nprint(swap.NPV())\n\n\n\n# B2_Ch10_5_C.py \n# model parameters\nvol = [ql.QuoteHandle(ql.SimpleQuote(0.008)),\n         ql.QuoteHandle(ql.SimpleQuote(0.008))]\nmeanRev = [ql.QuoteHandle(ql.SimpleQuote(0.04)),\n           ql.QuoteHandle(ql.SimpleQuote(0.04))]\nmodel = ql.Gsr(yts, [today+365], vol, meanRev) \nprocess = model.stateProcess()\n\n\n\n# B2_Ch10_5_D.py \n# evaluation time grid\ndate_grid = [today + ql.Period(i,ql.Months) for i in range(0,12*5)]\nfixingDate = [index.fixingDate(x) for x in floatSchedule][:-1]\ndate_grid += fixingDate\ndate_grid = np.unique(np.sort(date_grid))\ntime_grid = np.vectorize(lambda x: ql.ActualActual().yearFraction(today, x))(date_grid)\ndt = time_grid[1:] - time_grid[:-1]\n\n\n\n# B2_Ch10_5_E.py \n# random number generator\nseed = 666\nurng = ql.MersenneTwisterUniformRng(seed)\nusrg = ql.MersenneTwisterUniformRsg(len(time_grid)-1,urng)\nrn_generator = ql.InvCumulativeMersenneTwisterGaussianRsg(usrg)\n\n# MC simulations\nsim_num = 1000\nx = np.zeros((sim_num, len(time_grid)))\ny = np.zeros((sim_num, len(time_grid)))\npillars = np.array([0.0, 0.5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\nzero_bonds = np.zeros((sim_num, len(time_grid), len(pillars)))\n\nfor j in range(len(pillars)):\n    zero_bonds[:, 0, j] = model.zerobond(pillars[j],0,0)\n    \nfor n in range(0,sim_num):\n    dWs = rn_generator.nextSequence().value()\n    for i in range(1, len(time_grid)):\n        t0 = time_grid[i-1]\n        t1 = time_grid[i]\n        x[n,i] = process.expectation(t0,x[n,i-1],dt[i-1]) + dWs[i-1] * process.stdDeviation(t0,x[n,i-1],dt[i-1])\n        y[n,i] = (x[n,i] - process.expectation(0,0,t1)) / process.stdDeviation(0,0,t1)\n        for j in range(len(pillars)):\n            zero_bonds[n, i, j] = model.zerobond(t1+pillars[j],t1,y[n, i])\n\n# plot the paths\nplt.style.use('ggplot')\nfor i in range(0,sim_num):\n    plt.plot(time_grid, x[i,:])\nplt.xlabel(\"Time in years\")\nplt.ylabel(\"Zero rate\")\nplt.title(\"Monte Carlo simulation\")    \n\n\n\n# B2_Ch10_5_F.py \n# swap pricing\nnpv_cube = np.zeros((sim_num,len(date_grid)))\nfor p in range(0,sim_num):\n    for t in range(0, len(date_grid)):\n        date = date_grid[t]\n        ql.Settings.instance().setEvaluationDate(date)\n        ycDates = [date,date + ql.Period(6, ql.Months)] \n        ycDates += [date + ql.Period(i,ql.Years) for i in range(1,11)]\n        yc = ql.DiscountCurve(ycDates, \n                              zero_bonds[p, t, :], \n                              ql.Actual365Fixed())\n        yc.enableExtrapolation()\n        hyts.linkTo(yc)\n        if index.isValidFixingDate(date):\n            fixing = index.fixing(date)\n            index.addFixing(date, fixing)\n        npv_cube[p, t] = swap.NPV()\n    ql.IndexManager.instance().clearHistories()\nql.Settings.instance().setEvaluationDate(today)\nhyts.linkTo(crv)\n\n# alculate credit exposure\nexposure = npv_cube.copy()\nexposure[exposure<0]=0\n\n# plot first 15 NPV and exposure paths\nfig, (ax1, ax2) = plt.subplots(2, 1)\nfor i in range(0,15):\n    ax1.plot(time_grid, npv_cube[i,:])\nfor i in range(0,15):\n    ax2.plot(time_grid, exposure[i,:])\nax1.set_xlabel(\"Time in years\")\nax1.set_ylabel(\"NPV\")\nax1.set_title(\"(a) First 15 simulated npv paths\")\nax2.set_xlabel(\"Time in years\")\nax2.set_ylabel(\"Exposure\")\nax2.set_title(\"(b) First 15 simulated exposure paths\")\nplt.tight_layout()\n\n\n\n# B2_Ch10_5_G.py \n# Calculate expected exposure\nee = np.sum(exposure, axis=0)/sim_num\n# Calculate PFE curve (95% quantile)\nPFE_curve = np.apply_along_axis(lambda x: np.sort(x)[int(0.95*sim_num)],0,exposure)\n# plot expected exposure and PFE\nfig, (ax1, ax2) = plt.subplots(2, 1)\nax1.plot(time_grid, ee)\nax1.set_xlabel(\"Time in years\")\nax1.set_ylabel(\"Expected Exposure\")\nax1.set_title(\"(a) Expected Exposure\")\nax2.plot(time_grid,PFE_curve)\nax2.set_xlabel(\"Time in years\")\nax2.set_ylabel(\"PFE\")\nax2.set_title(\"(b) PFE\")\nplt.tight_layout()\n\n\n\n# B2_Ch10_5_H.py \n# generate the discount factors\ndiscount_factors = np.vectorize(yts.discount)(time_grid)\n# calculate discounted npvs\ndiscounted_cube = np.zeros(npv_cube.shape)\ndiscounted_cube = npv_cube * discount_factors\n# calculate discounted exposure\ndiscounted_exposure = discounted_cube.copy()\ndiscounted_exposure[discounted_exposure<0] = 0\n# calculate discounted expected exposure\ndiscounted_ee = np.sum(discounted_exposure, axis=0)/sim_num\n\n# plot discounted npv and exposure\nfig, (ax1, ax2) = plt.subplots(2, 1)\nfor i in range(0,15):\n    ax1.plot(time_grid, discounted_cube[i,:])\nfor i in range(0,15):\n    ax2.plot(time_grid, discounted_exposure[i,:])\nax1.set_xlabel(\"Time in years\")\nax1.set_ylabel(\"Discounted npv\")\nax1.set_title(\"(a) First 15 simulated discounted npv paths\")\nax2.plot(time_grid,discounted_ee)\nax2.set_xlabel(\"Time in years\")\nax2.set_ylabel(\"Discounted exposure\")\nax2.set_title(\"(b) First 15 simulated discounted exposure paths\")\nplt.tight_layout()\n\n\n\n# B2_Ch10_5_I.py \n# plot discounted expected exposure\nfig, ax1 = plt.subplots(1, 1)\nax1.plot(time_grid,discounted_ee)\nax1.set_xlabel(\"Time in years\")\nax1.set_ylabel(\"Discounted expected exposure\")\nax1.set_title(\"(b) Discounted expected exposure\")\n\n\n\n# B2_Ch10_5_J.py \n# build default curve \npd_dates =  [today + ql.Period(i, ql.Years) for i in range(11)]\nhzrates = [0.03 * i for i in range(11)]\npd_curve = ql.HazardRateCurve(pd_dates,hzrates,ql.Actual365Fixed())\npd_curve.enableExtrapolation()\n# calculate default probs on grid and plot curve\ntimes = np.linspace(0,25,100)\ndp = np.vectorize(pd_curve.defaultProbability)(times)\nsp = np.vectorize(pd_curve.survivalProbability)(times)\ndd = np.vectorize(pd_curve.defaultDensity)(times)\nhr = np.vectorize(pd_curve.hazardRate)(times)\nf, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nax1.plot(times, dp)\nax2.plot(times, sp)\nax3.plot(times, dd)\nax4.plot(times, hr)\nax1.set_xlabel(\"Time in years\")\nax2.set_xlabel(\"Time in years\")\nax3.set_xlabel(\"Time in years\")\nax4.set_xlabel(\"Time in years\")\nax1.set_ylabel(\"Probability\")\nax2.set_ylabel(\"Probability\")\nax3.set_ylabel(\"Density\")\nax4.set_ylabel(\"Hazard rate\")\nax1.set_title(\"Default probability\")\nax2.set_title(\"Survival probability\")\nax3.set_title(\"Default density\")\nax4.set_title(\"Hazard rate\")\n\n\n\n# B2_Ch10_5_K.py \n# calculate default probs\nPD_vec = np.vectorize(pd_curve.defaultProbability)\ndPD = PD_vec(time_grid[:-1], time_grid[1:])\n# calculate CVA\nRR = 0.4\nCVA = (1-RR) * np.sum(discounted_ee[1:] * dPD)\nprint (\"CVA value: %.2f\" % CVA)\n"
      },
      {
        "id": "ex6",
        "title": "10.6 B2_Ch10_6.py",
        "filename": "B2_Ch10_6.py",
        "code": "# B2_Ch10_6.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\nir_vol = 0.005\nfx_vol = 0.05\ncorrelation = 0.20\nconfidence_level = 0.99\nT = 5\n\nt = np.arange(0.0, T, 0.01)\nirs_pfe = ir_vol*np.sqrt(t)*(T-t)*norm.ppf(confidence_level)\nforward_pfe = fx_vol*np.sqrt(t)*norm.ppf(confidence_level)\nccs_pfe = np.sqrt(irs_pfe*irs_pfe+forward_pfe*forward_pfe+2.0*correlation*irs_pfe*forward_pfe)\n\nplt.style.use('fast')\nplt.plot(t, irs_pfe, c='lightblue', label='IRS')\nplt.plot(t, forward_pfe, c='dodgerblue', label='FX Forward')\nplt.plot(t, ccs_pfe, c='red', label='CCS')\n\nplt.xlabel(\"Time in years\")\nplt.ylabel(\"PFE\")\nplt.title(\"PFE Evolution\")\nplt.legend()\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      }
    ]
  },
  {
    "id": "b2_ch11",
    "title": "ç¬¬11ç« ï¼šæŠ•è³‡çµ„åˆç†è«–â… ",
    "number": 11,
    "content": {
      "intro": "# ç¬¬ 11 ç« ï¼šæŠ•è³‡çµ„åˆç†è«– I - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   11.1 å¹³å‡å€¼-æ–¹å·®ç†è«– (Mean-Variance Theory)\n*   11.2 æ‹‰æ ¼æœ—æ—¥ä¹˜æ•¸æ³• (Lagrange Multipliers) æ±‚è§£\n*   11.3 å…¨çƒæœ€å°è®Šç•°æ•¸æŠ•è³‡çµ„åˆ (GMVP)\n*   11.4 æœ‰æ•ˆå‰ç·£ (Efficient Frontier) çš„å¹¾ä½•æ„ç¾©\n*   11.5 æœ‰æ•ˆå‰ç·£å¯¦ä¾‹åˆ†æžèˆ‡æ•¸æ“šè§£æž\n*   11.6 ä¸å¯è³£ç©º (No-Shorting) ç´„æŸä¸‹çš„æœ‰æ•ˆå‰ç·£\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\næœ¬ç« ä»‹ç´¹ç¾ä»£æŠ•è³‡çµ„åˆç†è«–ï¼ˆMPTï¼‰çš„æ ¸å¿ƒæž¶æ§‹ã€‚ç”±é¦¬å¯ç¶­èŒ¨ï¼ˆHarry Markowitzï¼‰æå‡ºçš„å¹³å‡å€¼-æ–¹å·®æ¨¡åž‹ï¼Œç‚ºå¦‚ä½•åœ¨çµ¦å®šé¢¨éšªä¸‹æœ€å¤§åŒ–å›žå ±ï¼Œæˆ–åœ¨çµ¦å®šå›žå ±ä¸‹æœ€å°åŒ–é¢¨éšªæä¾›äº†æ•¸å­¸åŸºç¤Žã€‚æœ¬ç« é‡é»žåœ¨æ–¼åˆ©ç”¨çŸ©é™£é‹ç®—èˆ‡äºŒæ¬¡è¦åŠƒï¼ˆQPï¼‰æ±‚è§£æœ€ä½³åŒ–å•é¡Œã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   ç†è§£é›™è³‡ç”¢èˆ‡å¤šè³‡ç”¢æŠ•è³‡çµ„åˆçš„æ”¶ç›ŠçŽ‡èˆ‡é¢¨éšªï¼ˆæ–¹å·®ï¼‰è¨ˆç®—ã€‚\n*   æŽŒæ¡æ‹‰æ ¼æœ—æ—¥æ±‚è§£æ³•åœ¨ç­‰å¼ç´„æŸï¼ˆå¦‚ç¸½æ¬Šé‡ç­‰æ–¼ 1ï¼‰ä¸‹çš„æ‡‰ç”¨ã€‚\n*   å­¸æœƒåˆ©ç”¨äºŒæ¬¡è¦åŠƒæ±‚è§£å™¨è™•ç†ä¸ç­‰å¼ç´„æŸï¼ˆå¦‚ä¸å¯è³£ç©ºï¼‰ã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šæ ¹æ“šæ­·å²å ±é…¬èˆ‡å…±è®Šç•°æ•¸çŸ©é™£ï¼Œç‚ºå®¢æˆ¶å»ºæ§‹ä¸€å€‹é¢¨éšªæœ€å°åŒ–çš„é˜²ç¦¦åž‹çµ„åˆã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šæŽŒæ¡ç•¶ç›¸é—œä¿‚æ•¸ $\\rho < 1$ æ™‚ï¼Œé¢¨éšªåˆ†æ•£æ•ˆæ‡‰ï¼ˆDiversificationï¼‰å¦‚ä½•é™ä½Žçµ„åˆæ³¢å‹•çŽ‡ã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch11_1.py** | **[æ ¸å¿ƒ]** å¯¦ä½œé›™è³‡ç”¢æŠ•è³‡çµ„åˆæ”¶ç›ŠçŽ‡èˆ‡æ³¢å‹•çŽ‡è¨ˆç®—ï¼Œåˆ†æžç›¸é—œä¿‚æ•¸å°é¢¨éšªçš„å½±éŸ¿ã€‚ |\n| **B2_Ch11_2.py** | **[çŸ©é™£]** å¯¦ä½œæœ€å°è®Šç•°æ•¸æŠ•è³‡çµ„åˆ (GMVP) çŸ©é™£é‹ç®—èˆ‡è§£æžè§£æ±‚è§£ã€‚ |\n| **B2_Ch11_3.py** | **[æœ€ä½³åŒ–]** åˆ©ç”¨äºŒæ¬¡è¦åŠƒ (Quadratic Programming) æ±‚è§£å¤šè³‡ç”¢æœ‰æ•ˆå‰ç·£ã€‚ |\n| **B2_Ch11_4.py** | æ¼”ç¤ºå¤šè³‡ç”¢æŠ•è³‡çµ„åˆæ•ˆçŽ‡å‰ç·£çš„é€£çºŒè¦–è¦ºåŒ–åˆ†æžã€‚ |\n| **B2_Ch11_5.py** | **[ç´„æŸ]** å¯¦ä½œåŒ…å«ã€Œä¸å¯è³£ç©ºã€ç´„æŸçš„æŠ•è³‡çµ„åˆæœ€ä½³åŒ–ã€‚ |\n| **B2_Ch11_6.py** | åˆ©ç”¨ SciPy `minimize` å‡½æ•¸æ•¸å€¼æ±‚è§£è¤‡é›œç´„æŸä¸‹çš„æœ€ä½³é…ç½®ã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 11.1 å¹³å‡å€¼-æ–¹å·®ç†è«–\næŠ•è³‡çµ„åˆçš„é æœŸå›žå ±ç‚ºæ¬Šé‡èˆ‡å–®è³‡ç”¢å›žå ±çš„å…§ç©ï¼Œè€Œé¢¨éšªï¼ˆæ–¹å·®ï¼‰å‰‡ç‚ºï¼š\n$$\\sigma_p^2 = w^T \\Sigma w$$\nå…¶ä¸­ $\\Sigma$ æ˜¯è³‡ç”¢é–“çš„å…±è®Šç•°æ•¸çŸ©é™£ã€‚\n\n### 11.3 å…¨çƒæœ€å°è®Šç•°æ•¸æŠ•è³‡çµ„åˆ (GMVP)\nGMVP æ˜¯æœ‰æ•ˆå‰ç·£ä¸Šæœ€å·¦å´çš„é»žï¼Œä»£è¡¨ä¸è€ƒæ…®é æœŸå›žå ±çš„æƒ…æ³ä¸‹ï¼Œåƒ…é€éŽåˆ†æ•£æŠ•è³‡èƒ½é”åˆ°çš„æœ€ä½Žé¢¨éšªæ°´å¹³ã€‚\n\n### 11.6 ä¸å¯è³£ç©ºç´„æŸ\nåœ¨å¯¦å‹™ä¸­ï¼Œè¨±å¤šå…¬å‹ŸåŸºé‡‘å—åˆ°ã€Œä¸å¯è³£ç©ºã€çš„é™åˆ¶ï¼ˆæ¬Šé‡ $w_i \\ge 0$ï¼‰ã€‚é€™ä½¿å¾—æ±‚è§£éŽç¨‹å¾žç°¡å–®çš„çŸ©é™£è§£æžè§£è½‰è®Šç‚ºäºŒæ¬¡è¦åŠƒå•é¡Œï¼Œæœ‰æ•ˆå‰ç·£çš„å½¢ç‹€ä¹Ÿæœƒç™¼ç”Ÿç¸®æ¸›ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\n### ðŸ“„ B2_Ch11_1.py - é›™è³‡ç”¢é¢¨éšªåˆ†æž\n- **ä¸»è¦å‡½æ•¸**ï¼š`TwoAssetPort()`, `GMVP_TwoAssetPort()`\n- **å¯¦ä½œé‡é»ž**ï¼šå¯¦ä½œé›™è³‡ç”¢æ”¶ç›Šèˆ‡é¢¨éšªå…¬å¼ã€‚åˆ†æžä¸åŒçš„ç›¸é—œä¿‚æ•¸å¦‚ä½•æ”¹è®Š Return-Volatility æ›²ç·šçš„å½¢ç‹€ï¼ˆå¾žç›´ç·šåˆ°æŠ˜ç·šï¼‰ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šé‚Šéš›é¢¨éšªè²¢ç»ã€æœ‰æ•ˆå‰ç·£ã€é¢¨éšªåˆ†æ•£ã€‚\n\n### ðŸ“„ B2_Ch11_3.py è‡³ B2_Ch11_5.py - äºŒæ¬¡è¦åŠƒæ±‚è§£\n- **ä¸»è¦å¥—ä»¶**ï¼š`qpsolvers`, `numpy`\n- **å¯¦ä½œé‡é»ž**ï¼šå°‡æŠ•è³‡çµ„åˆå•é¡Œè½‰åŒ–ç‚ºæ¨™æº– QP å½¢å¼ï¼š$\\min \\frac{1}{2} x^T P x + q^T x$ã€‚\n- **æŠ€è¡“ç´°ç¯€**ï¼šç¢ºä¿é¢¨éšªåº¦é‡çš„ä¸€è‡´æ€§ï¼Œè™•ç†å…±è®Šç•°æ•¸çŸ©é™£çš„æ­£å®šæ€§æª¢æŸ¥ã€‚è€ƒæ…®æ¥µç«¯å¸‚å ´ä¸‹çš„å…±è®Šç•°æ•¸çŸ©é™£ä¸ç©©å®šå•é¡Œã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šè³‡ç”¢é…ç½®ã€é¢¨éšªåˆ†æ•£ã€è³‡æœ¬è³‡ç”¢å®šåƒ¹æ¨¡åž‹åŸºç¤Žã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- é¢¨éšªåˆ†æ•£çš„æ ¸å¿ƒåœ¨æ–¼å°‹æ‰¾ç›¸é—œæ€§ä½Žçš„è³‡ç”¢ã€‚\n- åªæœ‰ç•¶æˆ‘å€‘è€ƒæ…®äº†æ‰€æœ‰å¯èƒ½çš„æ¬Šé‡çµ„åˆæ™‚ï¼Œæ‰èƒ½å‹¾å‹’å‡ºä»£è¡¨æœ€å„ªæ•ˆçŽ‡çš„ã€Œæœ‰æ•ˆå‰ç·£ã€ã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 12 ç« æŠ•è³‡çµ„åˆç†è«– IIï¼ˆåŠ å…¥ç„¡é¢¨éšªè³‡ç”¢ï¼‰ã€ç¬¬ 4 ç« å›žæ­¸åˆ†æžï¼ˆä¼°è¨ˆ Betaï¼‰ã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Markowitz (1952) åŽŸå§‹è«–æ–‡*ã€‚\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch11*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "11.1 Editor-in-chief: Weisheng Jiang, and Sheng Tu",
        "filename": "B2_Ch11_1.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import sqrt, linspace\nimport matplotlib.pyplot as plt\n\n#%%  Specify Individual Assets' Returns, Volatilities, and Correlation\n\nr1 = 0.11\nr2 = 0.16\nvol1 = 0.25\nvol2 = 0.38\n\nrho_range = [-1., -0.5, 0., 0.5, 1.]\n\n#%%  Two Assets Mean-Variance Framework\ndef TwoAssetPort(w1,w2,r1,r2,sigma1,sigma2,rho):\n    PortReturn = w1*r1 + w2*r2\n    PortVol = sqrt((w1*sigma1)**2+(w2*sigma2)**2+2*w1*w2*sigma1*sigma2*rho)\n    return PortReturn,PortVol\n\n#%% Plot Return-Volatility\nw1 = linspace(-0.3,1.5,190)\nw2 = 1- w1\n\nfig,ax=plt.subplots()\n\nfor rho in linspace(-1,1,17):\n    TwoAssetPort_Return,TwoAssetPort_Vol = TwoAssetPort(w1,w2,r1,r2,vol1,vol2,rho)\n    #ax.plot(TwoAssetPort_Vol,TwoAssetPort_Return,label='rho = '+str(int(rho*100))+'%')\n    ax.plot(TwoAssetPort_Vol,TwoAssetPort_Return)\n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% find GMVP of a Two-asset portfolio\ndef GMVP_TwoAssetPort(r1,r2,sigma1,sigma2,rho):\n    w1_star = (sigma2**2-rho*sigma1*sigma2)/(sigma1**2-2*rho*sigma1*sigma2+sigma2**2)\n    w2_star = 1-w1_star\n    PortReturn = w1_star*r1 + w2_star*r2\n    PortVol = sqrt((w1_star*sigma1)**2+(w2_star*sigma2)**2+2*w1_star*w2_star*sigma1*sigma2*rho)\n    return PortReturn,PortVol,w1_star,w2_star\n\nfor rho in rho_range:\n    GMVP_return,GMVP_Vol,w1_star,w2_star = GMVP_TwoAssetPort(r1,r2,vol1,vol2,rho)\n    print(rho,GMVP_return,GMVP_Vol,w1_star,w2_star)\n\n#%% \nfig,ax=plt.subplots()\n\nfor rho in rho_range[0:4]:\n\n    GMVP_return,GMVP_Vol,w1_star,w2_star = GMVP_TwoAssetPort(r1,r2,vol1,vol2,rho)\n    \n    if r1 < r2:\n        w1_under = linspace(w1_star,1.5,100)\n        w2_under = 1 - w1_under\n        w1 = linspace(-0.3,w1_star,100)\n        w2 = 1 - w1\n    else:\n        w1 = linspace(w1_star,1.5,100)\n        w2 = 1 - w1\n        w1_under = linspace(-0.3,w1_star,100)\n        w2_under = 1 - w1_under    \n    \n    TwoAssetPort_Return_under,TwoAssetPort_Vol_under = TwoAssetPort(w1_under,w2_under,r1,r2,vol1,vol2,rho)\n    TwoAssetPort_Return,TwoAssetPort_Vol = TwoAssetPort(w1,w2,r1,r2,vol1,vol2,rho)\n    \n    ax.plot(TwoAssetPort_Vol,TwoAssetPort_Return,'-', \n            TwoAssetPort_Vol_under,TwoAssetPort_Return_under,'--',\n            #label='rho = '+str(int(rho*100))+'%')\n            )\n    ax.plot(GMVP_Vol,GMVP_return,'o')\n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% Plot Weight 1 vs Return & Volatility\nw1 = linspace(-1.0,2.8,190)\nw2 = 1- w1\n\nfig,ax=plt.subplots()\n\nfor rho in rho_range:\n    TwoAssetPort_Return,TwoAssetPort_Vol = TwoAssetPort(w1,w2,r1,r2,vol1,vol2,rho)\n    ax.plot(w1,TwoAssetPort_Vol,label='rho = '+str(int(rho*100))+'%')\n\nax.set(xlabel='Weight 1',ylabel='Portfolio Volatility')\nplt.legend()\n\n\nfig,ax=plt.subplots()\nax.plot(w1,TwoAssetPort_Return)\nax.set(xlabel='Weight 1',ylabel='Portfolio Return')\nplt.legend()\n\n\n#%% Plot Two-Asset GMVP\nfrom numpy import matrix, dot, ones, array, linspace, append, sqrt\nfrom numpy.linalg import inv\nimport matplotlib.pyplot as plt\n\nr1 = 0.11\nr2 = 0.16\nvol1 = 0.25\nvol2 = 0.38\n\nrho_range = linspace(-1,1,500)\nVol_GMVP_range = array([])\nR_GMVP_range = array([])\n\nfor rho in rho_range:    \n    CovM = matrix([[vol1**2, rho*vol1*vol2],[rho*vol1*vol2, vol2**2]])\n    Var_GMVP = 1/dot(dot(ones(2),inv(CovM)),ones((2,1)))\n    \n    Vol_GMVP = sqrt(Var_GMVP)\n    R_GMVP = Var_GMVP*dot(dot(ones(2),inv(CovM)),array([[r1],[r2]]))\n    \n    Vol_GMVP_range = append(Vol_GMVP_range,Vol_GMVP)\n    R_GMVP_range = append(R_GMVP_range,R_GMVP)\n    \nfig,ax=plt.subplots()\nax.plot(rho_range,R_GMVP_range)\nax.set(xlabel='Correlation',ylabel='Portfolio Return')\n\nfig,ax=plt.subplots()\nax.plot(rho_range,Vol_GMVP_range)\nax.set(xlabel='Correlation',ylabel='Portfolio Vol')\n\nfig,ax=plt.subplots()\nax.plot(Vol_GMVP_range,R_GMVP_range,'o')\nax.set(xlabel='Portfolio Vol',ylabel='Portfolio Return')\n    "
      },
      {
        "id": "ex2",
        "title": "11.2 Editor-in-chief: Weisheng Jiang, and Sheng Tu",
        "filename": "B2_Ch11_2.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, ones, zeros, size, append\nfrom pandas import read_excel, DataFrame\nfrom numpy.linalg import inv\n\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nCalMat = ones((size(Singlename_Mean)+1,size(Singlename_Mean)+1))\nCalMat[0:-1,0:-1] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-1,-1] = - CalMat[0:-1,-1]\nCalMat[-1,-1] = 0.0\n\nVec1 = zeros((size(Singlename_Mean)+1))\nVec1[-1] = 1\n\nSolutionVec1 = dot(inv(CalMat),Vec1)\n\nWeight_GMVP = SolutionVec1[0:-1]\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.30\nCalMat = ones((size(Singlename_Mean)+2,size(Singlename_Mean)+2))\nCalMat[0:-2,0:-2] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-2,-2] = - CalMat[0:-2,-2]\nCalMat[0:-2,-1] = - Singlename_Mean.to_numpy()\nCalMat[-1,0:-2] = Singlename_Mean.to_numpy()\nCalMat[-2:,-2:] = zeros((2,2))\n\nVec2 = zeros((size(Singlename_Mean)+2))\nVec2[-2] = 1\nVec2[-1] = Port_Return\n\nSolutionVec2 = dot(inv(CalMat),Vec2)\n\nWeight_MVP = SolutionVec2[0:-2]\n\n#%% Efficient Frontier\n\nCalMat = ones((size(Singlename_Mean)+2,size(Singlename_Mean)+2))\nCalMat[0:-2,0:-2] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-2,-2] = - CalMat[0:-2,-2]\nCalMat[0:-2,-1] = - Singlename_Mean.to_numpy()\nCalMat[-1,0:-2] = Singlename_Mean.to_numpy()\nCalMat[-2:,-2:] = zeros((2,2))\nVec2 = zeros((size(Singlename_Mean)+2))\nVec2[-2] = 1\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,0.3, num=25)\n\nfor Rp in Rp_range:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(0.0,Port_Return_GMVP, num=10)\n\nfor Rp in Rp_range_inEF:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(0.0,0.3, num=100)\n\nfor Rp in Rp_range_Hcurve:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='^')\nax.scatter(InEF_vol,Rp_range_inEF)\nax.scatter(EF_vol,Rp_range)\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n\n\n\n\n\n"
      },
      {
        "id": "ex3",
        "title": "11.3 Editor-in-chief: Weisheng Jiang, and Sheng Tu",
        "filename": "B2_Ch11_3.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, append, zeros_like, ones_like\nfrom pandas import read_excel, DataFrame\nfrom qpsolvers import solve_qp\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nWeight_GMVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    None,None,\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.30\nWeight_MVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean), \n    None,None,\n    array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n    array([1.,Port_Return]).reshape(2,))\n\nfig,ax=plt.subplots()\ntickers = Singlename_Mean.index.tolist()\nax.barh(tickers,Weight_MVP)\nax.set(xlabel='Weight',ylabel='Names')\n\n\n#%% Efficient Frontier\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,0.3, num=25)\n\nfor Rp in Rp_range:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))\n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(0.0,Port_Return_GMVP, num=10)\n\nfor Rp in Rp_range_inEF:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(0.001,0.3, num=100)\n\nfor Rp in Rp_range_Hcurve:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))      \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='^')\nax.scatter(InEF_vol,Rp_range_inEF)\nax.scatter(EF_vol,Rp_range)\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n    \nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n"
      },
      {
        "id": "ex4",
        "title": "11.4 Editor-in-chief: Weisheng Jiang, and Sheng Tu",
        "filename": "B2_Ch11_4.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, append, zeros_like, ones_like, size, identity\nfrom pandas import read_excel, DataFrame\nfrom qpsolvers import solve_qp\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nWeight_GMVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.1\nWeight_MVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean), \n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n    array([1.,Port_Return]).reshape(2,))\n\n\n#%% Efficient Frontier\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,max(Singlename_Mean), num=15)\n\nfor Rp in Rp_range:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))\n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(min(Singlename_Mean),Port_Return_GMVP, num=8)\n\nfor Rp in Rp_range_inEF:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))  \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(min(Singlename_Mean),max(Singlename_Mean), num=50)\n\nfor Rp in Rp_range_Hcurve:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))  \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='^')\nax.scatter(InEF_vol,Rp_range_inEF)\nax.scatter(EF_vol,Rp_range)\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n    \nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n\n"
      },
      {
        "id": "ex5",
        "title": "11.5 Editor-in-chief: Weisheng Jiang, and Sheng Tu",
        "filename": "B2_Ch11_5.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, append, zeros_like, ones_like, size, identity\nfrom pandas import read_excel, DataFrame\nfrom qpsolvers import solve_qp\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% GMVP portfolio w short\nWeight_GMVP_wShort=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    None,None,\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP_wShort = sqrt(dot(dot(Weight_GMVP_wShort,CovarianceMatrix.to_numpy()),Weight_GMVP_wShort))\nPort_Return_GMVP_wShort = dot(Weight_GMVP_wShort,Singlename_Mean.to_numpy())\n\n#%% GMVP portfolio wo short\nWeight_GMVP_woShort=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP_woShort = sqrt(dot(dot(Weight_GMVP_woShort,CovarianceMatrix.to_numpy()),Weight_GMVP_woShort))\nPort_Return_GMVP_woShort = dot(Weight_GMVP_woShort,Singlename_Mean.to_numpy())\n\n#%% Efficient Frontier\n# =============================================================================\n# Hyperbola curve \n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(0.00,0.2, num=200)\n\nfor Rp in Rp_range_Hcurve:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))      \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve - wo short\n# =============================================================================\nHcurve_vol_woshort = array([])\nRp_range_Hcurve_woshort =  linspace(min(Singlename_Mean),max(Singlename_Mean), num=100)\n\nfor Rp in Rp_range_Hcurve_woshort:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))  \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol_woshort = append(Hcurve_vol_woshort,array(Port_vol))\n\n#%% plot Efficient Frontier portfolios\ntickers = Singlename_Mean.index.tolist()\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.plot(Hcurve_vol_woshort,Rp_range_Hcurve_woshort)\n#ax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='^')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.plot(Port_Vol_GMVP_wShort,Port_Return_GMVP_wShort,'^',label='GMVP w/ Short')\nax.plot(Port_Vol_GMVP_woShort,Port_Return_GMVP_woShort,'^',label='GMVP w/o Short')\n\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\nplt.legend()\n\n\n#%% MVP portfolio, fixed return, w/o short\nPort_Return = 0.30\nWeight_MVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean), \n    None,None,\n    array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n    array([1.,Port_Return]).reshape(2,))\n\nfig,ax=plt.subplots()\nax.barh(tickers,Weight_MVP)\nax.set(xlabel='Weight',ylabel='Names')\n\n"
      },
      {
        "id": "ex6",
        "title": "11.6 Editor-in-chief: Weisheng Jiang, and Sheng Tu",
        "filename": "B2_Ch11_6.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import sqrt, dot, zeros_like, ones_like\nfrom pandas import read_excel, DataFrame\nfrom scipy.optimize import minimize, LinearConstraint, Bounds\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% define portfolio variance\nw0= zeros_like(Singlename_Vol)\nw0[1]=1\n\ndef MinVar(weight, *args):        \n    CovMatrix = args\n    \n    obj = dot(dot(weight,CovMatrix),weight)\n    return obj\n\n#%% GMVP portfolio\nlinear_constraint = LinearConstraint(ones_like(Singlename_Vol),[1],[1])\n\nres = minimize(MinVar, w0,\n               args=(CovarianceMatrix.to_numpy()),\n               method='trust-constr',\n               constraints=[linear_constraint])\n\nWeight_GMVP = res.x\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n\n#%% GMVP portfolio w/o short\nlinear_constraint = LinearConstraint(ones_like(Singlename_Vol),[1],[1])\nbounds = Bounds(zeros_like(Singlename_Vol), ones_like(Singlename_Vol))\nres = minimize(MinVar, w0,\n               args=(CovarianceMatrix.to_numpy()),\n               method='trust-constr',\n               bounds = bounds,\n               constraints=[linear_constraint])\n\nWeight_GMVP = res.x\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight w/o short\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation (w/o Short)',ylabel='Names')"
      }
    ]
  },
  {
    "id": "b2_ch12",
    "title": "ç¬¬12ç« ï¼šæŠ•è³‡çµ„åˆç†è«–â…¡",
    "number": 12,
    "content": {
      "intro": "# ç¬¬ 12 ç« ï¼šæŠ•è³‡çµ„åˆç†è«– II - é‡é»žè©³è§£ (Detail)\n\n## ðŸ“‹ ç« ç¯€é‡é»žåˆ†æ˜Ž\n\n*   12.1 åŒ…å«ç„¡é¢¨éšªç”¢å“çš„æŠ•è³‡çµ„åˆ (Risk-free Asset)\n*   12.2 æœ€ä½³é¢¨éšªæŠ•è³‡çµ„åˆ (Optimal Risky Portfolio) åŠå¯¦ä¾‹åˆ†æž\n*   12.3 ç„¡å·®åˆ¥æ•ˆç”¨æ›²ç·š (Indifference Utility Curves)\n*   12.4 æœ€ä½³å®Œå…¨æŠ•è³‡çµ„åˆ (Optimal Complete Portfolio) å¯¦ä¾‹åˆ†æž\n*   12.5 è³‡ç”¢å®šåƒ¹ç†è«– (Asset Pricing Theory) èˆ‡ CAPM æ¨¡åž‹\n\n## ðŸ“Œ ç« ç¯€å°Žè¦½\næœ¬ç« åœ¨ç¬¬ 11 ç« çš„åŸºç¡€ä¸Šï¼Œå¼•å…¥äº†ã€Œç„¡é¢¨éšªè³‡ç”¢ã€çš„æ¦‚å¿µï¼Œä¸¦å°‡é¦¬å¯ç¶­èŒ¨æ¨¡åž‹æŽ¨å»£è‡³è³‡æœ¬é…ç½®ç·šï¼ˆCALï¼‰èˆ‡è­‰åˆ¸å¸‚å ´ç·šï¼ˆSMLï¼‰ã€‚æœ¬ç« ç¯€æœ€æ ¸å¿ƒçš„ç›®æ¨™æ˜¯å¹«åŠ©æŠ•è³‡è€…åœ¨å…·å‚™å€‹äººé¢¨éšªåå¥½ï¼ˆæ•ˆç”¨å‡½æ•¸ï¼‰çš„æƒ…æ³ä¸‹ï¼Œæ‰¾åˆ°æœ€å„ªçš„é¢¨éšªèˆ‡ç„¡é¢¨éšªè³‡ç”¢é…å°ã€‚\n\n## ðŸŽ¯ å­¸ç¿’ç›®æ¨™\n*   æŽŒæ¡è³‡æœ¬é…ç½®ç·š (CAL) çš„æ–œçŽ‡ï¼ˆå¤æ™®æ¯”çŽ‡ Sharpe Ratioï¼‰åŠå…¶æ„ç¾©ã€‚\n*   æŽŒæ¡åˆ‡é»žæŠ•è³‡çµ„åˆ (Tangency Portfolio) çš„æ•¸å­¸æ±‚è§£ã€‚\n*   ç†è§£å¦‚ä½•çµåˆå€‹äººçš„é¢¨éšªåŽ­æƒ¡ä¿‚æ•¸ $A$ èˆ‡ç„¡å·®åˆ¥æ›²ç·šå°‹æ‰¾æœ€å„ªæ•ˆç”¨é»žã€‚\n*   ç†è§£ CAPM æ¨¡åž‹ä¸­ç³»çµ±æ€§é¢¨éšª ($\\beta$) èˆ‡é æœŸå ±é…¬çš„ç·šæ€§é—œä¿‚ã€‚\n\n## ðŸ’¼ å¯¦å‹™æ‡‰ç”¨èªªæ˜Ž\n*   **å¯¦å‹™å ´æ™¯**ï¼šæ ¹æ“šå®¢æˆ¶çš„é¢¨éšªåŽ­æƒ¡ç¨‹åº¦ï¼Œæ±ºå®šåœ¨æ¨™æ™® 500 æŒ‡æ•¸åŸºé‡‘èˆ‡åœ‹å‚µä¹‹é–“çš„è³‡é‡‘åˆ†é…æ¯”ä¾‹ã€‚\n*   **è€ƒè©¦é‡é»ž**ï¼šæŽŒæ¡åˆ†é›¢å®šç†ï¼ˆSeparation Theoremï¼‰ï¼šè³‡ç”¢é…ç½®æ±ºç­–å¯ä»¥åˆ†ç‚ºã€Œæ‰¾å°‹æœ€ä½³é¢¨éšªçµ„åˆã€èˆ‡ã€Œæ ¹æ“šå¿ƒç†åå¥½åˆ†é…æ¬Šé‡ã€å…©å€‹ç¨ç«‹æ­¥é©Ÿã€‚\n\n## ðŸ’» æ‡‰ç”¨å ´æ™¯æ¸…å–®\n\n| è…³æœ¬åç¨± | æ ¸å¿ƒä½¿å‘½ |\n| :--- | :--- |\n| **B2_Ch12_1.py** | **[æ ¸å¿ƒ]** å¯¦ä½œé¦¬å¯ç¶­èŒ¨ (Markowitz) å‡å€¼-è®Šç•°æ•¸æ¨¡åž‹ï¼Œæ±‚è§£æœ€ä½³æŠ•è³‡çµ„åˆã€‚ |\n| **B2_Ch12_2.py** | åˆ©ç”¨ QP æ±‚è§£å™¨åˆ†æžä¸åŒé æœŸæ”¶ç›ŠçŽ‡ä¸‹çš„çµ„åˆé¢¨éšªæœ€å°åŒ–èˆ‡ CAL ç·šã€‚ |\n| **B2_Ch12_3.py** | **[é€²éšŽ]** å¯¦ä½œå¤šç¶­è³‡ç”¢æ¬Šé‡åˆ†é…èˆ‡é¢¨éšªé‚Šéš›è²¢ç»ï¼ˆMarginal Risk Contributionï¼‰åˆ†æžã€‚ |\n| **B2_Ch12_4.py** | **[ç†è«–]** è¨ˆç®—è³‡ç”¢è²å¡”ä¿‚æ•¸ (Beta) èˆ‡ç³»çµ±æ€§é¢¨éšªï¼Œæ¼”ç¤º CAPM æ¨¡åž‹åŸºç¤Žæ‡‰ç”¨ã€‚ |\n\n## ðŸ“ ç« ç¯€é‡é»žè©³ç´°è§£èªª\n\n### 12.1-12.2 å¤æ™®æ¯”çŽ‡èˆ‡ CAL\nç•¶å¼•å…¥ç„¡é¢¨éšªè³‡ç”¢ $R_f$ å¾Œï¼ŒæŠ•è³‡è€…çš„é¸æ“‡ç¯„åœè®Šæˆäº†å¾ž $R_f$ å‡ºç™¼ä¸¦åˆ‡æ–¼æœ‰æ•ˆå‰ç·£çš„ç›´ç·šï¼Œé€™æ¢ç·šç¨±ç‚ºè³‡æœ¬é…ç½®ç·š (CAL)ã€‚åˆ‡é»žå³ç‚ºå¤æ™®æ¯”çŽ‡æœ€é«˜çš„ã€Œæœ€ä½³é¢¨éšªæŠ•è³‡çµ„åˆã€ã€‚\n\n### 12.3 ç„¡å·®åˆ¥æ•ˆç”¨æ›²ç·š\næ•ˆç”¨å‡½æ•¸é€šå¸¸è¡¨ç¤ºç‚ºï¼š\n$$U = E(R) - \\frac{1}{2} A \\sigma^2$$\nå…¶ä¸­ $A$ æ˜¯æŠ•è³‡è€…çš„é¢¨éšªåŽ­æƒ¡ä¿‚æ•¸ã€‚$A$ è¶Šå¤§ï¼Œæ›²ç·šè¶Šé™¡ï¼ŒæŠ•è³‡è€…è¶Šåå‘ä¿ç•™æ›´å¤šç„¡é¢¨éšªè³‡ç”¢ã€‚\n\n### 12.5 CAPM æ¨¡åž‹\nè³‡æœ¬è³‡ç”¢å®šåƒ¹æ¨¡åž‹å°‡è³‡ç”¢çš„é æœŸå›žå ±èˆ‡å…¶å°å¸‚å ´çµ„åˆçš„æ•æ„Ÿåº¦ $\\beta$ è¯ç¹«èµ·ä¾†ï¼š\n$$E(R_i) = R_f + \\beta_i [E(R_m) - R_f]$$\né€™æ¨™èªŒè‘—é¢¨éšªç®¡ç†å¾žé—œæ³¨ã€Œç¸½é¢¨éšªã€è½‰å‘é—œæ³¨ã€Œä¸å¯åˆ†æ•£çš„ç³»çµ±æ€§é¢¨éšªã€ã€‚\n\n---\n\n## ðŸ› ï¸ è…³æœ¬å¯¦ä½œæ·±åº¦è§£æž (PRESERVED)\n\n### ðŸ“„ B2_Ch12_1.py è‡³ B2_Ch12_3.py - æŠ•è³‡çµ„åˆæœ€ä½³åŒ–å¯¦å‹™\n- **ä¸»è¦å¥—ä»¶**ï¼š`qpsolvers`, `numpy`, `read_excel`\n- **å¯¦ä½œé‡é»ž**ï¼šå¾ž Excel è®€å–æ­·å²æ•¸æ“šï¼Œè¨ˆç®—æœŸæœ›å›žå ±å‘é‡èˆ‡å…±è®Šç•°æ•¸çŸ©é™£ã€‚åˆ©ç”¨äºŒæ¬¡è¦åŠƒæ±‚è§£åœ¨ä¸åŒç´„æŸä¸‹çš„æ¬Šé‡åˆ†é…ã€‚\n- **æŠ€è¡“ç´°ç¯€**ï¼šç¢ºä¿é¢¨éšªåº¦é‡çš„ä¸€è‡´æ€§ï¼Œè™•ç†æ•¸æ“šç¼ºå¤±å€¼ï¼Œé©—è­‰çŸ©é™£é‹ç®—çš„æ•¸å€¼ç©©å®šæ€§ã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šè³‡ç”¢é…ç½®ã€æœ‰æ•ˆå‰ç·£ã€é¢¨éšªåˆ†æ•£ã€åˆ†é›¢å®šç†ã€‚\n\n### ðŸ“„ B2_Ch12_4.py - CAPM èˆ‡ Beta\n- **å¯¦ä½œé‡é»ž**ï¼šè¨ˆç®—è³‡ç”¢èˆ‡å¸‚å ´å›žå ±çš„å”æ–¹å·®ï¼Œé™¤ä»¥å¸‚å ´æ–¹å·®å¾—åˆ° $\\beta$ã€‚\n- **æ¼”ç®—æ³•ç´°ç¯€**ï¼šä½¿ç”¨ `numpy` æˆ– `statsmodels` é€²è¡Œç·šæ€§æ“¬åˆã€‚\n- **ç›¸é—œé‡‘èžæ¦‚å¿µ**ï¼šç³»çµ±æ€§é¢¨éšªã€è³‡ç”¢å®šåƒ¹ã€è³‡æœ¬å¸‚å ´ç·šã€‚\n\n---\n\n## ðŸ”‘ é‡è¦æ¦‚å¿µç¸½çµ\n- æŠ•è³‡çµ„åˆç†è«–ä¸åƒ…æ˜¯æ•¸å­¸éŠæˆ²ï¼Œæ›´æ˜¯å¿ƒç†åå¥½èˆ‡å¸‚å ´æ•ˆçŽ‡çš„çµåˆã€‚\n- åˆ†é›¢å®šç†ç°¡åŒ–äº†æŠ•é¡§å¯¦å‹™ï¼šå…ˆæ‰¾æœ€å¥½çš„è›‹ç³•ï¼ˆåˆ‡é»žçµ„åˆï¼‰ï¼Œå†æ±ºå®šåˆ‡çµ¦å®¢æˆ¶å¤šå°‘ï¼ˆæ•ˆç”¨åŒ¹é…ï¼‰ã€‚\n\n## ðŸ“– å»¶ä¼¸å­¸ç¿’\n- **ç›¸é—œç« ç¯€**ï¼šç¬¬ 11 ç« æŠ•è³‡çµ„åˆç†è«– Iï¼ˆåŸºç¤Žï¼‰ã€ç¬¬ 4 ç« å›žæ­¸åˆ†æžï¼ˆBeta çš„çµ±è¨ˆä¼°è¨ˆï¼‰ã€‚\n- **åƒè€ƒè³‡æ–™**ï¼š*Sharpe (1964) ç¶“å…¸æ–‡ç»*ã€‚\n\n---\n*æœ¬æ–‡æª”åƒè€ƒ Book 1 æ ¼å¼æ›´æ–°ï¼Œä¸¦å®Œæ•´ä¿ç•™ Book 2 åŽŸå§‹æŠ€è¡“ç´°ç¯€*\n*ç« ç¯€ID: B2_Ch12*\n"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "12.1 Editor-in-chief: Weisheng Jiang, and Sheng Tu",
        "filename": "B2_Ch12_1.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n\nfrom numpy import array, sqrt, dot, linspace, ones, zeros, size, append\nfrom pandas import read_excel, DataFrame\nfrom numpy.linalg import inv\n\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Define Risk Free asset\nRF = 0.02\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\nax.scatter(0,RF,color=\"red\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nCalMat = ones((size(Singlename_Mean)+1,size(Singlename_Mean)+1))\nCalMat[0:-1,0:-1] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-1,-1] = - CalMat[0:-1,-1]\nCalMat[-1,-1] = 0.0\n\nVec1 = zeros((size(Singlename_Mean)+1))\nVec1[-1] = 1\n\nSolutionVec1 = dot(inv(CalMat),Vec1)\n\nWeight_GMVP = SolutionVec1[0:-1]\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.30\nCalMat = ones((size(Singlename_Mean)+2,size(Singlename_Mean)+2))\nCalMat[0:-2,0:-2] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-2,-2] = - CalMat[0:-2,-2]\nCalMat[0:-2,-1] = - Singlename_Mean.to_numpy()\nCalMat[-1,0:-2] = Singlename_Mean.to_numpy()\nCalMat[-2:,-2:] = zeros((2,2))\n\nVec2 = zeros((size(Singlename_Mean)+2))\nVec2[-2] = 1\nVec2[-1] = Port_Return\n\nSolutionVec2 = dot(inv(CalMat),Vec2)\n\nWeight_MVP = SolutionVec2[0:-2]\n\n#%% Efficient Frontier\n\nCalMat = ones((size(Singlename_Mean)+2,size(Singlename_Mean)+2))\nCalMat[0:-2,0:-2] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-2,-2] = - CalMat[0:-2,-2]\nCalMat[0:-2,-1] = - Singlename_Mean.to_numpy()\nCalMat[-1,0:-2] = Singlename_Mean.to_numpy()\nCalMat[-2:,-2:] = zeros((2,2))\nVec2 = zeros((size(Singlename_Mean)+2))\nVec2[-2] = 1\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,0.3, num=25)\n\nfor Rp in Rp_range:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(0.0,Port_Return_GMVP, num=10)\n\nfor Rp in Rp_range_inEF:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(0.0,0.3, num=100)\n\nfor Rp in Rp_range_Hcurve:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% Optimal Risky portfolio\nEr_initial = 0.15\nCalMat = zeros((size(Singlename_Mean)+1,size(Singlename_Mean)+1))\nCalMat[0:-1,0:-1] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-1,-1] = -(Singlename_Mean.to_numpy()-RF)\nCalMat[-1,0:-1] = Singlename_Mean.to_numpy()-RF\n\nVec3 = zeros((size(Singlename_Mean)+1))\nVec3[-1] = Er_initial-RF\n\nSolutionVec3 = dot(inv(CalMat),Vec3)\n\nWeight_ORP = SolutionVec3[0:-1]/sum(SolutionVec3[0:-1])\n\nPort_Vol_ORP = sqrt(dot(dot(Weight_ORP,CovarianceMatrix.to_numpy()),Weight_ORP))\nPort_Return_ORP = dot(Weight_ORP,Singlename_Mean.to_numpy())\n\nSR = (Port_Return_ORP-RF)/Port_Vol_ORP\n\n#%% bar chart ORP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation',ylabel='Names')\n\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='x')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.scatter(0,RF,color=\"red\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D')\nax.plot([0,Port_Vol_ORP],[RF,Port_Return_ORP])\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n\n\n\n\n\n"
      },
      {
        "id": "ex2",
        "title": "12.2 Editor-in-chief: Weisheng Jiang, and Sheng Tu",
        "filename": "B2_Ch12_2.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, append, zeros_like, ones_like\nfrom pandas import read_excel, DataFrame\nfrom qpsolvers import solve_qp\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Define Risk Free asset\nRF = 0.02\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\nax.scatter(0,RF,color=\"red\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nWeight_GMVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    None,None,\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.30\nWeight_MVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean), \n    None,None,\n    array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n    array([1.,Port_Return]).reshape(2,))\n\nfig,ax=plt.subplots()\ntickers = Singlename_Mean.index.tolist()\nax.barh(tickers,Weight_MVP)\nax.set(xlabel='Weight',ylabel='Names')\n\n\n#%% Efficient Frontier\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,0.3, num=25)\n\nfor Rp in Rp_range:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))\n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(0.0,Port_Return_GMVP, num=10)\n\nfor Rp in Rp_range_inEF:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(0.001,0.3, num=100)\n\nfor Rp in Rp_range_Hcurve:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))      \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% Optimal Risky portfolio\nEr_initial = 0.15\nSolution=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    None,None,\n    array([Singlename_Mean.to_numpy()-RF]),\n    array([Er_initial-RF]))\n\nWeight_ORP = Solution/sum(Solution)\n\nPort_Vol_ORP = sqrt(dot(dot(Weight_ORP,CovarianceMatrix.to_numpy()),Weight_ORP))\nPort_Return_ORP = dot(Weight_ORP,Singlename_Mean.to_numpy())\n\nSR = (Port_Return_ORP-RF)/Port_Vol_ORP\n\n#%% bar chart ORP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation',ylabel='Names')\n\n\n#%% Capital Market Line\nvol_range = linspace(0,0.35,100)\nCML = RF + SR*vol_range\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='x')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.scatter(0,RF,color=\"red\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D',color=\"red\")\nax.plot(vol_range,CML)\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% Optimal Indifference Utility Curve 1\nA1 = 3\nU_max_1 = RF + SR**2/(2*A1) \nWeight_P_1 = SR/(A1*Port_Vol_ORP) \n\nR1 = 1/2*A1*(vol_range**2) + U_max_1\n\nE_c1 = RF+SR**2/A1\nVol_c1 = Weight_P_1*Port_Vol_ORP\n\n#%% bar chart OCP1 weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP*Weight_P_1)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation with A = '+ str(A1),ylabel='Names')\n\n#%% Optimal Indifference Utility Curve 2\nA2 = 5\nU_max_2 = RF + SR**2/(2*A2)\nWeight_P_2 = SR/(A2*Port_Vol_ORP) \n\nR2 = 1/2*A2*(vol_range**2) + U_max_2\n\nE_c2 = RF+SR**2/A2\nVol_c2 = Weight_P_2*Port_Vol_ORP\n\n#%% bar chart OCP2 weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP*Weight_P_2)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation with A = '+ str(A2),ylabel='Names')\n\n#%% plot Capital Market Line and Indifference Utility Curves\nfig,ax=plt.subplots()\nax.plot(vol_range,CML)\nax.plot(vol_range,R1,color=\"green\")\nax.plot(vol_range,R2,color=\"green\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D')\n\nax.scatter(Vol_c1,E_c1, marker='*', color=\"purple\")\nax.scatter(Vol_c2,E_c2, marker='*', color=\"purple\")\n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n#%% plot everything\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='x')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.scatter(0,RF,color=\"red\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D')\nax.plot(vol_range,CML)\n\nax.plot(vol_range,R1,color=\"green\")\nax.plot(vol_range,R2,color=\"green\")\n\nax.scatter(Vol_c1,E_c1, marker='*', color=\"purple\")\nax.scatter(Vol_c2,E_c2, marker='*', color=\"purple\")\n\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n"
      },
      {
        "id": "ex3",
        "title": "12.3 Editor-in-chief: Weisheng Jiang, and Sheng Tu",
        "filename": "B2_Ch12_3.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, append, zeros_like, ones_like, size, identity\nfrom pandas import read_excel, DataFrame\nfrom qpsolvers import solve_qp\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Define Risk Free asset\nRF = 0.02\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\nax.scatter(0,RF,color=\"red\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nWeight_GMVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.1\nWeight_MVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean), \n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n    array([1.,Port_Return]).reshape(2,))\n\n\n#%% Efficient Frontier\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,max(Singlename_Mean), num=15)\n\nfor Rp in Rp_range:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))\n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(min(Singlename_Mean),Port_Return_GMVP, num=8)\n\nfor Rp in Rp_range_inEF:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))  \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(min(Singlename_Mean),max(Singlename_Mean), num=50)\n\nfor Rp in Rp_range_Hcurve:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))  \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% Optimal Risky portfolio\nEr_initial = 0.05\nSolution=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    array([Singlename_Mean.to_numpy()-RF]),\n    array([Er_initial-RF]))\n\nWeight_ORP = Solution/sum(Solution)\n\nPort_Vol_ORP = sqrt(dot(dot(Weight_ORP,CovarianceMatrix.to_numpy()),Weight_ORP))\nPort_Return_ORP = dot(Weight_ORP,Singlename_Mean.to_numpy())\n\nSR = (Port_Return_ORP-RF)/Port_Vol_ORP\n\n#%% bar chart ORP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation',ylabel='Names')\n\n#%% Capital Market Line\nvol_range = linspace(0,0.3,100)\nCML = RF + SR*vol_range\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='x')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.scatter(0,RF,color=\"red\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D',color=\"red\")\nax.plot(vol_range,CML)\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% Optimal Indifference Utility Curve 1\nA1 = 3\nU_max_1 = RF + SR**2/(2*A1) \nWeight_P_1 = SR/(A1*Port_Vol_ORP) \n\nR1 = 1/2*A1*(vol_range**2) + U_max_1\n\nE_c1 = RF+SR**2/A1\nVol_c1 = Weight_P_1*Port_Vol_ORP\n\n#%% bar chart OCP1 weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP*Weight_P_1)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation with A = '+ str(A1),ylabel='Names')\n\n#%% Optimal Indifference Utility Curve 2\nA2 = 5\nU_max_2 = RF + SR**2/(2*A2)\nWeight_P_2 = SR/(A2*Port_Vol_ORP) \n\nR2 = 1/2*A2*(vol_range**2) + U_max_2\n\nE_c2 = RF+SR**2/A2\nVol_c2 = Weight_P_2*Port_Vol_ORP\n\n#%% bar chart OCP2 weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP*Weight_P_2)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation with A = '+ str(A2),ylabel='Names')\n\n#%% plot Capital Market Line and Indifference Utility Curves\nfig,ax=plt.subplots()\nax.plot(vol_range,CML)\nax.plot(vol_range,R1,color=\"green\")\nax.plot(vol_range,R2,color=\"green\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D')\n\nax.scatter(Vol_c1,E_c1, marker='*', color=\"purple\")\nax.scatter(Vol_c2,E_c2, marker='*', color=\"purple\")\n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n#%% plot everything\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='x')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.scatter(0,RF,color=\"red\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D')\nax.plot(vol_range,CML)\n\nax.plot(vol_range,R1,color=\"green\")\nax.plot(vol_range,R2,color=\"green\")\n\nax.scatter(Vol_c1,E_c1, marker='*', color=\"purple\")\nax.scatter(Vol_c2,E_c2, marker='*', color=\"purple\")\n\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n"
      },
      {
        "id": "ex4",
        "title": "12.4 Editor-in-chief: Weisheng Jiang, and Sheng Tu",
        "filename": "B2_Ch12_4.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import sqrt, linspace, corrcoef, zeros\nfrom pandas import read_excel, DataFrame\n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_2.xlsx')\n\n#%% CAPM beta\nMean = DataFrame.mean(data)*12\nVol = DataFrame.std(data)*sqrt(12)\n\nSinglename_Return = data.iloc[:,1:-2]\n\nMktExcess = data.iloc[:,-2]\nRF = data.iloc[:,-1]\n\nSinglename_ExcessReturn = Singlename_Return\n\nn= len(Singlename_Return.columns)\n\nCorrelation_v_Mkt = zeros(n)\n\nfor k in linspace(0,n-1,n):\n    k=int(k)\n    Singlename_ExcessReturn.iloc[:,k] = Singlename_Return.iloc[:,k] - RF\n    Correlation_v_Mkt[k] = corrcoef(Singlename_ExcessReturn.iloc[:,k].to_numpy(),\n                                    MktExcess.to_numpy())[1,0]\n    \n\nVol_Excess = DataFrame.std(Singlename_ExcessReturn)*sqrt(12) \nVol_Mkt = DataFrame.std(MktExcess)*sqrt(12) \n\n\nBeta = zeros(n)\nSys_exp_Vol = zeros(n)\nSys_exp_prct = zeros(n)\n\nfor k in linspace(0,n-1,n):\n    k=int(k)\n    Beta[k] = Correlation_v_Mkt[k]*Vol_Excess[k]/Vol_Mkt\n    Sys_exp_Vol[k] = Beta[k]*Vol_Mkt\n    Sys_exp_prct[k] = Sys_exp_Vol[k]**2/Vol_Excess[k]**2\n\n\n"
      }
    ]
  }
]