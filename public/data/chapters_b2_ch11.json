{
  "id": "b2_ch11",
  "title": "第11章：投資組合理論Ⅰ",
  "number": 11,
  "content": {
    "intro": {
      "title": "第 11 章：投資組合理論 I - 重點詳解 (Detail)",
      "roadmap": {
        "guide": "本章介紹現代投資組合理論（MPT）的核心架構。由馬可維茨提出的平均值-方差模型，為如何在給定風險下最大化回報，或在給定回報下最小化風險提供了數學基礎。",
        "objectives": "*   理解雙資產與多資產投資組合的收益率與風險（方差）計算。\n*   掌握拉格朗日求解法在等式約束（如總權重等於 1）下的應用。\n*   學會利用二次規劃求解器處理不等式約束（如不可賣空）。",
        "topics": "*   11.1 平均值-方差理論 (Mean-Variance Theory)\n*   11.2 拉格朗日乘數法 (Lagrange Multipliers) 求解\n*   11.3 全球最小變異數投資組合 (GMVP)\n*   11.4 有效前緣 (Efficient Frontier) 的幾何意義\n*   11.5 有效前緣實例分析與數據解析\n*   11.6 不可賣空 (No-Shorting) 約束下的有效前緣"
      },
      "value": {
        "practical": "*   **實務場景**：根據歷史報酬與共變異數矩陣，為客戶建構一個風險最小化的防禦型組合。\n*   **考試重點**：掌握當相關係數 $\\rho < 1$ 時，風險分散效應（Diversification）如何降低組合波動率。",
        "theory": "投資組合風險 $\\sigma_p^2 = w^T \\Sigma w$。GMVP 是有效前緣上最左側的點。不可賣空約束使問題從矩陣運算轉為二次規劃。",
        "further_reading": "*   Markowitz (1952) 原始論文。"
      },
      "implementation": {
        "python": "*   **矩陣運算**：使用 `numpy` 與矩陣解析解求解最佳權重。\n*   **最佳化求解**：利用 `qpsolvers` 或 `scipy.optimize` 處理包含不等式約束的投資組合問題。\n*   **視覺化**：繪製 Return-Volatility 曲線與有效前緣曲面。",
        "logic": "*   解析解：拉格朗日乘數法。\n*   數值解：二次規劃 (Quadratic Programming)。",
        "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B2_Ch11_1.py** | **[核心]** 實作雙資產投資組合收益率與波動率計算，分析相關係數對風險的影響。 |\n| **B2_Ch11_2.py** | **[矩陣]** 實作最小變異數投資組合 (GMVP) 矩陣運算與解析解求解。 |\n| **B2_Ch11_3.py** | **[最佳化]** 利用二次規劃 (Quadratic Programming) 求解多資產有效前緣。 |\n| **B2_Ch11_4.py** | 演示多資產投資組合效率前緣的連續視覺化分析。 |\n| **B2_Ch11_5.py** | **[約束]** 實作包含「不可賣空」約束的投資組合最佳化。 |\n| **B2_Ch11_6.py** | 利用 SciPy `minimize` 函數數值求解複雜約束下的最佳配置。 |"
      }
    },
    "body": {
      "11.1": "### 11.1 平均值-方差理論 (Mean-Variance Theory)：量化風險分散的基石\n由 Harry Markowitz 引領的現代投資組合理論 (MPT)，將資產配置從「單純選股」轉化為「分散化管理」。核心理念在於：資產的風險不應孤立看待，而應觀察其對整個投資組合波動率的貢獻。資深基金經理透過優化資產權重，旨在尋找特定回報下的最低風險，或特定風險下的最高回報。\n\n#### 專家定義：組合收益與風險的矩陣表達\n給定權重向量 $\\mathbf{w}$ 與資產收益共變異數矩陣 $\\mathbf{\\Sigma}$，組合的預期回報 $\\mu_p$ 與方差 $\\sigma_p^2$ 定義如下：\n\n$$\n  \\mu_p = \\mathbf{w}^T \\mathbf{\\mu}, \\quad \\sigma_p^2 = \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}\n$$\n\n#### 專家決策矩陣：相關係數 $\\rho$ 的風險分散效應\n相關係數是分散化投資中最有價值的參數：\n\n| 相關性 ($\\rho$) | 風險分散效果 | 幾何特徵 |\n| :--- | :--- | :--- |\n| **$\\rho = +1$ (完全正相關)** | **無分散效果** | 組合風險是各資產風險的線性加權 |\n| **$-1 < \\rho < 1$** | **顯著分散** | 風險曲線向左側彎曲，產生大於部分之和的安定度 |\n| **$\\rho = -1$ (完全負相關)** | **完美對沖** | 理論上可以建構出風險為零的投資組合 |\n\n> [!IMPORTANT]\n> 在生產端計算波動率時（見 `B2_Ch11_1.py`），資深開發者會使用 `np.dot` 執行矩陣對乘。必須注意，當資產數量 $N$ 增加時，相關係數對總風險的影響遠大於單個資產的方差。這正是「不要把雞蛋放在同一個籃子裡」的數學實證。\n\n#### 11.1 資深從業人員行動清單 (Action Items)\n執行組合初步分析前，必須確認：\n- **共變異數矩陣正定性審核**：確保 $\\mathbf{\\Sigma}$ 為正定矩陣，防止在優化求解時出現負值風險或數值崩潰。\n- **收益率年化校準**：確保所有輸入的 $\\mu$ 與 $\\sigma$ 均已統一為年化基數，消除期限錯位導致的分配偏差。\n- **相關性穩定度回測**：分析在市場壓力期 (Crises)，資產間相關係數是否會趨近於 1（分散失效），並對此進行壓力場景模擬。",
      "11.2": "### 11.2 拉格朗日乘數法 (Lagrange Multipliers) 求解：約束條件下的最優化\n在構建投資組合時，我們面臨著諸多硬性約束（如權重總合必須為 1）。**拉格朗日乘數法**是解決此類含約束最優化問題的解析黃金工具。它透過引入輔助參數 $\\lambda$，將有約束問題轉換為無約束方程組，從而獲取精確的權重解析解。\n\n#### 技術核心：拉格朗日函數構建\n假設目標是最小化方差 $\\frac{1}{2} \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}$，且滿足權重之和等於 1 ($\\mathbf{w}^T \\mathbf{1} = 1$)，其構建如下：\n\n$$\n  \\mathcal{L}(\\mathbf{w}, \\lambda) = \\frac{1}{2} \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w} + \\lambda (1 - \\mathbf{w}^T \\mathbf{1})\n$$\n\n#### 專家決策矩陣：解析解 vs. 數值解的選型\n資深計量師需根據約束的複雜度決定求解路徑：\n\n| 求解方法 | 適用場景 | 核心優勢 |\n| :--- | :--- | :--- |\n| **解析解 (Lagrange)** | 僅含等式約束（如總權重=1，目標回報=k） | 運算極速，可直接推導出權重公式 |\n| **數值解 (QP)** | 包含不等式約束（如不可賣空 $w \\ge 0$，權重上限） | **工業標配**：能處理現實中絕大多數的投資限制 |\n| **隨機搜索 (Heuristic)**| 包含離散約束（如買入整數手、資產數量上限）| 適用於非連續、非凸的複雜優化表面 |\n\n> [!TIP]\n> 在 Python 資深實作中（見 `B2_Ch11_2.py`），對於不含不等式約束的全球最小變異數組合，我們直接套用矩陣公式 $\\mathbf{w} = \\frac{\\mathbf{\\Sigma}^{-1} \\mathbf{1}}{\\mathbf{1}^T \\mathbf{\\Sigma}^{-1} \\mathbf{1}}$。這比呼叫優化器更具效率且無數值收斂問題。\n\n#### 11.2 資深從業人員行動清單 (Action Items)\n執行公式求解前，必須落實：\n- **矩陣可逆性檢查**：確認 $\\mathbf{\\Sigma}$ 無奇異性，防止求逆運算失效。\n- **拉格朗日乘數物理含義審核**：監控 $\\lambda$ 的數值大小，它反映了邊際約束對風險降低的阻礙程度。\n- **約束完備性驗證**：確保所有法律與業務要求的等式約束已全部寫入拉格朗日算式，無一遺漏。",
      "11.3": "### 11.3 全球最小變異數投資組合 (GMVP)：風險防禦的北極星\n**全球最小變異數投資組合 (Global Minimum Variance Portfolio, GMVP)** 是有效前緣上最左側的頂點。它在不考量任何報酬預期的情況下，純粹利用資產間的共變異數特徵來實現物理上的最低風險。資深經理常在市場極度動盪、無法預測收益方向時，將資金撤回至 GMVP 作為「防禦性泊位」。\n\n#### 技術核心：矩陣解析解\nGMVP 的權重分配完全由 $\\mathbf{\\Sigma}$ 決定，與期待收益率無關：\n\n$$\n  \\mathbf{w}_{GMVP} = \\frac{\\mathbf{\\Sigma}^{-1} \\mathbf{1}}{\\mathbf{1}^T \\mathbf{\\Sigma}^{-1} \\mathbf{1}}\n$$\n\n#### 專家決策矩陣：GMVP 的配置屬性\n資深分析師應根據 GMVP 的權重分佈洞察市場結構：\n\n| 權重特徵 | 市場含義 | 配置建議 |\n| :--- | :--- | :--- |\n| **權重集中度高** | 代表某個低波動資產（如債券）佔據主導 | 需警惕單一資產的流動性風險 |\n| **出現大量負權重** | 部分資產被作為「波動抵扣項」而大量融券賣出 | **警惕**：若法令限制賣空，此 GMVP 將無法實施 |\n| **權重分佈均勻** | 各資產間具備良好的相關性抵校特徵 | **優選**：具備更高的結構穩健性 |\n\n> [!IMPORTANT]\n> 在視覺化分析中（見 `B2_Ch11_2.py`），GMVP 是有效前緣曲線的變換點。在其之上的曲線部分代表「有效前緣」，在其之下的部分則為「無效區域」。資深分析師絕不應持有比 GMVP 更低報酬且更高風險的無效組合。\n\n#### 11.3 資深從業人員行動清單 (Action Items)\n執行 GMVP 模型前，必須確認：\n- **空頭頭寸法律審核**：檢查解析解算出的配置是否包含賣空。若合規不允許，則必須轉向包含 $w \\ge 0$ 約束的二次規劃求解。\n- **波動率分位數分析**：比對 GMVP 的總波動率與單一最低風險資產的波動率，量化分散化帶來的「風險節省額」。\n- **樣本外穩定性測試**：利用歷史數據進行滾動回測，檢查 GMVP 的權重是否隨樣本窗口的微動而產生劇烈跳變（翻轉不穩定性）。",
      "11.4": "### 11.4 有效前緣 (Efficient Frontier) 的幾何意義：投資的最佳可行域\n**有效前緣 (Efficient Frontier)** 是由所有「最優組合」構成的集合。在給定回報下，沒有其他組合具備更低風險；在給定風險下，沒有其他組合具備更高回報。資深從業人員將有效前緣視為配置的「最優邊界」，任何不在前緣上的組合都被視為效率低下（Inefficient）。\n\n#### 技術核心：超平面與二次曲線\n在均值-方差空間中，有效前緣呈現為一條向右開口的雙曲線。其上半部分（從 GMVP 開始向上）才是投資人感興趣的「有效」部分。\n\n#### 專家決策矩陣：前緣形態對宏觀環境的映射\n前緣的形狀決定了資產配置的吸引力：\n\n| 前緣特徵 | 宏觀含義 | 配置策略 |\n| :--- | :--- | :--- |\n| **極度扁平** | 各資產回報與風險極度接近 | 隨便配哪種資產差別都不大，建議降低交易成本 |\n| **陡峭且向左突出** | 存在強力的風險分散資產（低相關性） | **黃金機會**：應積極分配權重以獲取高夏普比率 |\n| **向右平移** | 市場整體風險溢價下降或波動率激增 | 應實行防禦性減持，或尋找新的低相關因子 |\n\n> [!IMPORTANT]\n> 在生產端繪製曲線時（見 `B2_Ch11_4.py`），資深開發者會使用掃描法（掃描不同的目標收益率 $r$）來繪製前緣。必須注意，當資產數量 $N > 100$ 時，曲線的分辨率與求解器的收斂速度將成為核心瓶頸，應優先使用矩陣優化的算法。\n\n#### 11.4 資深從業人員行動清單 (Action Items)\n分析有效前緣時，必須落實：\n- **可行性集合碰撞測試**：隨機生成萬個隨機權重組合，確認它們全部落在有效前緣曲線的「右側」，以驗證前緣的正確性。\n- **資產子集效應分析**：對比不同資產池（如「僅股票」vs「股票+債券」）的有效前緣。新資產應使前緣向「左上方」移動，否則應剔除該資產。\n- **估計偏誤校正**：由於 $\\mu$ 和 $\\Sigma$ 是估得的，前緣存在估計誤差，建議使用 Black-Litterman 模型進行平滑化校準。",
      "11.5": "### 11.5 有效前緣實例分析與數據解析：理論到實戰的跨越\n理解有效前緣的關鍵在於對真實市場數據的「敏感度」。資深從業人員通過對比不同資產類別（如 A 股、美股、債券、黃金）在不同歷史時期勾勒出的邊界，可以識別出市場效率的變動與投資組合的分散化紅利。本節聚焦於如何將 `numpy` 的矩陣運算轉化為具備業務深度的投資決策。\n\n#### 專家讀圖：有效前緣的「指紋」特徵\n資深經理透過曲線形態判斷市場狀態：\n\n| 曲線特徵 | 數據解讀 | 操作決策 |\n| :--- | :--- | :--- |\n| **前緣極向左下方縮回** | 資產池中出現了具備穩定高收益、低風險的「核心資產」 | 應將權重向該「定海神針」資產傾斜 |\n| **曲線向右下方平移** | 全球系統性風險激增，所有資產夏普比率下降 | **防禦策略**：增加現金比例，等待前緣重新修復 |\n| **出現多個「角點」** | 受制於特定資產的權重上限或不可賣空約束 | 代表法規限制已顯著阻礙了分散化效益的獲取 |\n\n#### 技術核心：樣本外 (Out-of-Sample) 穩定性分析\n資深計量師不會盲目信任基於歷史數據的完美曲線。我們使用回測技術驗證：\n\n$$\n  \\text{Weights}_{t} = \\arg\\min \\mathbf{w}^T \\mathbf{\\Sigma}_{t-1} \\mathbf{w}\n$$\n\n> [!IMPORTANT]\n> 在 Python 繪圖實作中（見 `B2_Ch11_4.py`），資深開發者會疊加展示「單個資產」與「分散組合」的散點圖。如果單一資產落在前緣的左側，說明模型輸入存在嚴重錯誤或市場存在明顯套利機會（這通常是數據錄入錯誤的標誌）。\n\n#### 11.5 資深從業人員行動清單 (Action Items)\n執行實例分析前，必須確認：\n- **回報率統計分佈檢定**：確認資產收益是否具備重尾 (Fat-tail) 特性。若有，標準均值-方差模型會低估極端風險，需引入 CVaR 調整。\n- **再平衡頻率敏感度測試**：評估每月、每季再平衡對前緣穩定度的影響，考量交易手續費對「表面優化回報」的侵蝕。\n- **資產容量限制審查**：確保前緣計算出的最佳權重對應的成交金額，不會超過市場的日均成交量（防止衝擊成本）。",
      "11.6": "### 11.6 不可賣空 (No-Shorting) 約束下的有效前緣：現實世界的枷鎖\n在真實的資產管理環境中（如 公募基金、養老金），法規通常明令禁止「空頭頭寸」（即 $w \\ge 0$）。這一約束從根本上改變了投資組合理論的解空間：它將問題從具備解析解的線性方程組，推向了必須依賴數值求解的**二次規劃 (Quadratic Programming)** 領域。\n\n#### 技術核心：二次規劃 (QP) 形式\n在含有 $w_i \\ge 0$ 約束下，目標函數如下，這不再能透過簡單矩陣求逆獲得：\n\n$$\n  \\min_{\\mathbf{w}} \\frac{1}{2} \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}, \\quad \\text{subject to } \\mathbf{w}^T \\mathbf{1} = 1, \\text{ and } \\mathbf{w} \\ge 0\n$$\n\n#### 專家決策矩陣：含權重下限 $w \\ge 0$ 的影響點\n資深分析師應識別約束帶來的幾何變化：\n\n| 維度 | 無約束 (允許賣空) | 有約束 (不可賣空) |\n| :--- | :--- | :--- |\n| **有效前緣形態** | 完美的平滑雙曲線 | 可能存在「折點」或「角點」，且前緣縮減 |\n| **風險水平** | 可達到的風險更低（因可槓桿對沖） | 風險下限被推高，無法進行負權重抵銷 |\n| **資產集中度** | 權重分散於正負兩端 | 權重趨向於歸零，僅保留少數核心資產 |\n\n> [!IMPORTANT]\n> 在生產端實作 `qpsolvers` 求解時（見 `B2_Ch11_3.py` 和 `B2_Ch11_5.py`），資深開發者會設定矩陣 $\\mathbf{P}$ 為共變異數矩陣。必須檢查當目標收益率超過單資產最高收益時，求解器是否回傳「無可行解」(Infeasible)。此時應調低回報預期，而非盲目信任系統回傳的錯誤權重。\n\n#### 11.6 資深從業人員行動清單 (Action Items)\n執行有約束最佳化前，必須落實：\n- **權重集中度審計 (Concentration Risk)**：檢查是否有單一資產權重比例過高（如 $> 40\\%$），必要時增加人為上限約束 $w_i \\le 0.25$。\n- **解決器收斂誤差監控**：紀錄求解器的迭代次數與殘差值，確保在高維資產下依然能獲取穩定解。\n- **對比分析 (Constrained vs Unconstrained)**：向決策層量化展示「禁空令」導致的風險成本與潛在收益損失（即有效前緣的萎縮程度）。\n\n#### 核心技術結論\n投資組合理論Ⅰ是風險管理的幾何學。從馬可維茨的均值-方差映射，到解析與數值求解技術的博弈，資深從業人員透過勾勒「有效前緣」，在紛繁複雜的市場資產中，編碼出了風險與回報的最佳平衡點。"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "11.1 雙資產投資組合收益與風險",
        "filename": "B2_Ch11_1.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import sqrt, linspace\nimport matplotlib.pyplot as plt\n\n#%%  Specify Individual Assets' Returns, Volatilities, and Correlation\n\nr1 = 0.11\nr2 = 0.16\nvol1 = 0.25\nvol2 = 0.38\n\nrho_range = [-1., -0.5, 0., 0.5, 1.]\n\n#%%  Two Assets Mean-Variance Framework\ndef TwoAssetPort(w1,w2,r1,r2,sigma1,sigma2,rho):\n    PortReturn = w1*r1 + w2*r2\n    PortVol = sqrt((w1*sigma1)**2+(w2*sigma2)**2+2*w1*w2*sigma1*sigma2*rho)\n    return PortReturn,PortVol\n\n#%% Plot Return-Volatility\nw1 = linspace(-0.3,1.5,190)\nw2 = 1- w1\n\nfig,ax=plt.subplots()\n\nfor rho in linspace(-1,1,17):\n    TwoAssetPort_Return,TwoAssetPort_Vol = TwoAssetPort(w1,w2,r1,r2,vol1,vol2,rho)\n    #ax.plot(TwoAssetPort_Vol,TwoAssetPort_Return,label='rho = '+str(int(rho*100))+'%')\n    ax.plot(TwoAssetPort_Vol,TwoAssetPort_Return)\n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% find GMVP of a Two-asset portfolio\ndef GMVP_TwoAssetPort(r1,r2,sigma1,sigma2,rho):\n    w1_star = (sigma2**2-rho*sigma1*sigma2)/(sigma1**2-2*rho*sigma1*sigma2+sigma2**2)\n    w2_star = 1-w1_star\n    PortReturn = w1_star*r1 + w2_star*r2\n    PortVol = sqrt((w1_star*sigma1)**2+(w2_star*sigma2)**2+2*w1_star*w2_star*sigma1*sigma2*rho)\n    return PortReturn,PortVol,w1_star,w2_star\n\nfor rho in rho_range:\n    GMVP_return,GMVP_Vol,w1_star,w2_star = GMVP_TwoAssetPort(r1,r2,vol1,vol2,rho)\n    print(rho,GMVP_return,GMVP_Vol,w1_star,w2_star)\n\n#%% \nfig,ax=plt.subplots()\n\nfor rho in rho_range[0:4]:\n\n    GMVP_return,GMVP_Vol,w1_star,w2_star = GMVP_TwoAssetPort(r1,r2,vol1,vol2,rho)\n    \n    if r1 < r2:\n        w1_under = linspace(w1_star,1.5,100)\n        w2_under = 1 - w1_under\n        w1 = linspace(-0.3,w1_star,100)\n        w2 = 1 - w1\n    else:\n        w1 = linspace(w1_star,1.5,100)\n        w2 = 1 - w1\n        w1_under = linspace(-0.3,w1_star,100)\n        w2_under = 1 - w1_under    \n    \n    TwoAssetPort_Return_under,TwoAssetPort_Vol_under = TwoAssetPort(w1_under,w2_under,r1,r2,vol1,vol2,rho)\n    TwoAssetPort_Return,TwoAssetPort_Vol = TwoAssetPort(w1,w2,r1,r2,vol1,vol2,rho)\n    \n    ax.plot(TwoAssetPort_Vol,TwoAssetPort_Return,'-', \n            TwoAssetPort_Vol_under,TwoAssetPort_Return_under,'--',\n            #label='rho = '+str(int(rho*100))+'%')\n            )\n    ax.plot(GMVP_Vol,GMVP_return,'o')\n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% Plot Weight 1 vs Return & Volatility\nw1 = linspace(-1.0,2.8,190)\nw2 = 1- w1\n\nfig,ax=plt.subplots()\n\nfor rho in rho_range:\n    TwoAssetPort_Return,TwoAssetPort_Vol = TwoAssetPort(w1,w2,r1,r2,vol1,vol2,rho)\n    ax.plot(w1,TwoAssetPort_Vol,label='rho = '+str(int(rho*100))+'%')\n\nax.set(xlabel='Weight 1',ylabel='Portfolio Volatility')\nplt.legend()\n\n\nfig,ax=plt.subplots()\nax.plot(w1,TwoAssetPort_Return)\nax.set(xlabel='Weight 1',ylabel='Portfolio Return')\nplt.legend()\n\n\n#%% Plot Two-Asset GMVP\nfrom numpy import matrix, dot, ones, array, linspace, append, sqrt\nfrom numpy.linalg import inv\nimport matplotlib.pyplot as plt\n\nr1 = 0.11\nr2 = 0.16\nvol1 = 0.25\nvol2 = 0.38\n\nrho_range = linspace(-1,1,500)\nVol_GMVP_range = array([])\nR_GMVP_range = array([])\n\nfor rho in rho_range:    \n    CovM = matrix([[vol1**2, rho*vol1*vol2],[rho*vol1*vol2, vol2**2]])\n    Var_GMVP = 1/dot(dot(ones(2),inv(CovM)),ones((2,1)))\n    \n    Vol_GMVP = sqrt(Var_GMVP)\n    R_GMVP = Var_GMVP*dot(dot(ones(2),inv(CovM)),array([[r1],[r2]]))\n    \n    Vol_GMVP_range = append(Vol_GMVP_range,Vol_GMVP)\n    R_GMVP_range = append(R_GMVP_range,R_GMVP)\n    \nfig,ax=plt.subplots()\nax.plot(rho_range,R_GMVP_range)\nax.set(xlabel='Correlation',ylabel='Portfolio Return')\n\nfig,ax=plt.subplots()\nax.plot(rho_range,Vol_GMVP_range)\nax.set(xlabel='Correlation',ylabel='Portfolio Vol')\n\nfig,ax=plt.subplots()\nax.plot(Vol_GMVP_range,R_GMVP_range,'o')\nax.set(xlabel='Portfolio Vol',ylabel='Portfolio Return')\n    "
      },
      {
        "id": "ex2",
        "title": "11.2 最小變異數投資組合 (GMVP) 解析解",
        "filename": "B2_Ch11_2.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, ones, zeros, size, append\nfrom pandas import read_excel, DataFrame\nfrom numpy.linalg import inv\n\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nCalMat = ones((size(Singlename_Mean)+1,size(Singlename_Mean)+1))\nCalMat[0:-1,0:-1] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-1,-1] = - CalMat[0:-1,-1]\nCalMat[-1,-1] = 0.0\n\nVec1 = zeros((size(Singlename_Mean)+1))\nVec1[-1] = 1\n\nSolutionVec1 = dot(inv(CalMat),Vec1)\n\nWeight_GMVP = SolutionVec1[0:-1]\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.30\nCalMat = ones((size(Singlename_Mean)+2,size(Singlename_Mean)+2))\nCalMat[0:-2,0:-2] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-2,-2] = - CalMat[0:-2,-2]\nCalMat[0:-2,-1] = - Singlename_Mean.to_numpy()\nCalMat[-1,0:-2] = Singlename_Mean.to_numpy()\nCalMat[-2:,-2:] = zeros((2,2))\n\nVec2 = zeros((size(Singlename_Mean)+2))\nVec2[-2] = 1\nVec2[-1] = Port_Return\n\nSolutionVec2 = dot(inv(CalMat),Vec2)\n\nWeight_MVP = SolutionVec2[0:-2]\n\n#%% Efficient Frontier\n\nCalMat = ones((size(Singlename_Mean)+2,size(Singlename_Mean)+2))\nCalMat[0:-2,0:-2] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-2,-2] = - CalMat[0:-2,-2]\nCalMat[0:-2,-1] = - Singlename_Mean.to_numpy()\nCalMat[-1,0:-2] = Singlename_Mean.to_numpy()\nCalMat[-2:,-2:] = zeros((2,2))\nVec2 = zeros((size(Singlename_Mean)+2))\nVec2[-2] = 1\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,0.3, num=25)\n\nfor Rp in Rp_range:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(0.0,Port_Return_GMVP, num=10)\n\nfor Rp in Rp_range_inEF:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(0.0,0.3, num=100)\n\nfor Rp in Rp_range_Hcurve:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='^')\nax.scatter(InEF_vol,Rp_range_inEF)\nax.scatter(EF_vol,Rp_range)\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n\n\n\n\n\n"
      },
      {
        "id": "ex3",
        "title": "11.3 二次規劃求解有效前緣",
        "filename": "B2_Ch11_3.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, append, zeros_like, ones_like\nfrom pandas import read_excel, DataFrame\nfrom qpsolvers import solve_qp\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nWeight_GMVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    None,None,\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.30\nWeight_MVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean), \n    None,None,\n    array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n    array([1.,Port_Return]).reshape(2,))\n\nfig,ax=plt.subplots()\ntickers = Singlename_Mean.index.tolist()\nax.barh(tickers,Weight_MVP)\nax.set(xlabel='Weight',ylabel='Names')\n\n\n#%% Efficient Frontier\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,0.3, num=25)\n\nfor Rp in Rp_range:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))\n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(0.0,Port_Return_GMVP, num=10)\n\nfor Rp in Rp_range_inEF:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(0.001,0.3, num=100)\n\nfor Rp in Rp_range_Hcurve:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))      \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='^')\nax.scatter(InEF_vol,Rp_range_inEF)\nax.scatter(EF_vol,Rp_range)\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n    \nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n"
      },
      {
        "id": "ex4",
        "title": "11.4 有效前緣連續視覺化",
        "filename": "B2_Ch11_4.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, append, zeros_like, ones_like, size, identity\nfrom pandas import read_excel, DataFrame\nfrom qpsolvers import solve_qp\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nWeight_GMVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.1\nWeight_MVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean), \n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n    array([1.,Port_Return]).reshape(2,))\n\n\n#%% Efficient Frontier\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,max(Singlename_Mean), num=15)\n\nfor Rp in Rp_range:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))\n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(min(Singlename_Mean),Port_Return_GMVP, num=8)\n\nfor Rp in Rp_range_inEF:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))  \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(min(Singlename_Mean),max(Singlename_Mean), num=50)\n\nfor Rp in Rp_range_Hcurve:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))  \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='^')\nax.scatter(InEF_vol,Rp_range_inEF)\nax.scatter(EF_vol,Rp_range)\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n    \nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n\n"
      },
      {
        "id": "ex5",
        "title": "11.5 不可賣空約束投資組合",
        "filename": "B2_Ch11_5.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, append, zeros_like, ones_like, size, identity\nfrom pandas import read_excel, DataFrame\nfrom qpsolvers import solve_qp\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% GMVP portfolio w short\nWeight_GMVP_wShort=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    None,None,\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP_wShort = sqrt(dot(dot(Weight_GMVP_wShort,CovarianceMatrix.to_numpy()),Weight_GMVP_wShort))\nPort_Return_GMVP_wShort = dot(Weight_GMVP_wShort,Singlename_Mean.to_numpy())\n\n#%% GMVP portfolio wo short\nWeight_GMVP_woShort=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP_woShort = sqrt(dot(dot(Weight_GMVP_woShort,CovarianceMatrix.to_numpy()),Weight_GMVP_woShort))\nPort_Return_GMVP_woShort = dot(Weight_GMVP_woShort,Singlename_Mean.to_numpy())\n\n#%% Efficient Frontier\n# =============================================================================\n# Hyperbola curve \n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(0.00,0.2, num=200)\n\nfor Rp in Rp_range_Hcurve:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))      \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve - wo short\n# =============================================================================\nHcurve_vol_woshort = array([])\nRp_range_Hcurve_woshort =  linspace(min(Singlename_Mean),max(Singlename_Mean), num=100)\n\nfor Rp in Rp_range_Hcurve_woshort:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))  \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol_woshort = append(Hcurve_vol_woshort,array(Port_vol))\n\n#%% plot Efficient Frontier portfolios\ntickers = Singlename_Mean.index.tolist()\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.plot(Hcurve_vol_woshort,Rp_range_Hcurve_woshort)\n#ax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='^')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.plot(Port_Vol_GMVP_wShort,Port_Return_GMVP_wShort,'^',label='GMVP w/ Short')\nax.plot(Port_Vol_GMVP_woShort,Port_Return_GMVP_woShort,'^',label='GMVP w/o Short')\n\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\nplt.legend()\n\n\n#%% MVP portfolio, fixed return, w/o short\nPort_Return = 0.30\nWeight_MVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean), \n    None,None,\n    array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n    array([1.,Port_Return]).reshape(2,))\n\nfig,ax=plt.subplots()\nax.barh(tickers,Weight_MVP)\nax.set(xlabel='Weight',ylabel='Names')\n\n"
      },
      {
        "id": "ex6",
        "title": "11.6 複雜約束數值求解",
        "filename": "B2_Ch11_6.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import sqrt, dot, zeros_like, ones_like\nfrom pandas import read_excel, DataFrame\nfrom scipy.optimize import minimize, LinearConstraint, Bounds\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% define portfolio variance\nw0= zeros_like(Singlename_Vol)\nw0[1]=1\n\ndef MinVar(weight, *args):        \n    CovMatrix = args\n    \n    obj = dot(dot(weight,CovMatrix),weight)\n    return obj\n\n#%% GMVP portfolio\nlinear_constraint = LinearConstraint(ones_like(Singlename_Vol),[1],[1])\n\nres = minimize(MinVar, w0,\n               args=(CovarianceMatrix.to_numpy()),\n               method='trust-constr',\n               constraints=[linear_constraint])\n\nWeight_GMVP = res.x\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n\n#%% GMVP portfolio w/o short\nlinear_constraint = LinearConstraint(ones_like(Singlename_Vol),[1],[1])\nbounds = Bounds(zeros_like(Singlename_Vol), ones_like(Singlename_Vol))\nres = minimize(MinVar, w0,\n               args=(CovarianceMatrix.to_numpy()),\n               method='trust-constr',\n               bounds = bounds,\n               constraints=[linear_constraint])\n\nWeight_GMVP = res.x\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight w/o short\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation (w/o Short)',ylabel='Names')"
      }
    ]
  }
}