{
  "id": "b2_ch1",
  "title": "第1章：波動性",
  "number": 1,
  "content": {
    "intro": {
      "title": "第 1 章：波動性 - 重點詳解 (Detail)",
      "roadmap": {
        "guide": "波動性（Volatility）是金融風險管理中最基礎也最重要的指標。本章詳細探討了從簡單的回報率計算到複雜的隨機波動模型（ARCH/GARCH），並實作了期權市場中至關重要的隱含波動率計算。",
        "objectives": "*   掌握算術收益率與對數收益率的區別與應用場景。\n*   實作 EWMA 與 GARCH 模型來捕捉波動率聚集（Volatility Clustering）。\n*   利用數值方法求解期權的隱含波動率（IV）。",
        "topics": "*   1.1 回報率 (Returns)\n*   1.2 歷史與動態波動率\n*   1.3 移動平均 (MA) 與動態波動率\n*   1.4 ARCH 模型理論\n*   1.5 GARCH 模型理論\n*   1.6 波動性估計與預測\n*   1.7 隱含波動性與數值求解"
      },
      "value": {
        "practical": "在 FRM 考試與實務中，波動率是計算 VaR 的核心輸入。掌握 GARCH 模型能讓你更準確地預測極端市場下的風險水平，而不僅僅是依賴過時的歷史平均值。",
        "theory": "波動率並非固定不變的常數，而是具備「集群性」與「均值回歸」特質的機率過程。理解這一點是從傳統金融轉向現代量化金融的關鍵步階。",
        "further_reading": "建議閱讀 Robert Engle 的諾貝爾獎論文，深入理解 ARCH 模型的誕生背景與對現代計量經濟學的貢獻。"
      },
      "implementation": {
        "python": "Python 的 `arch` 套件提供了工業級的模型配適工具，而 `scipy.optimize` 則是求解隱含波動率的利器。透過本章實作，你將學會如何將複雜數學轉化為自動化風險監控工具。",
        "logic": "*   GARCH(1,1) 方程定義：$\\sigma_t^2 = \\omega + \\alpha \\epsilon_{t-1}^2 + \\beta \\sigma_{t-1}^2$。\n*   Black-Scholes 模型與牛頓法求解 IV。",
        "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B2_Ch1_1.py** | 實作時間序列位移與收益率計算，涵蓋數據擷取。 |\n| **B2_Ch1_2.py** | 多資產收益率視覺化對比與百分比變化 analysis。 |\n| **B2_Ch1_3.py** | 波動率（標準差）動態計算與圖表呈現。 |\n| **B2_Ch1_4.py** | 深入分析歷史波動率的時間序列特徵。 |\n| **B2_Ch1_5.py** | 演示金融數據的多維視覺化佈局。 |\n| **B2_Ch1_6.py** | 收益率分佈特徵與統計繪圖實作。 |\n| **B2_Ch1_7.py** | **[核心]** ARCH/GARCH 模型配適與波動率預測。 |\n| **B2_Ch1_8.py** | 期權希臘字母 Delta 的基礎計算與視覺化。 |\n| **B2_Ch1_9.py** | **[核心]** 實作 Black-Scholes Formula 與 IV 求解算例。 |\n| **B2_Ch1_10.py** | 期權鏈數據分析與隱含波動率曲面初步。 |"
      }
    },
    "body": {
      "1.1": "### 1.1 回報率 (Returns)：金融建模的絕對核心\n在量化風險管理中，資產價格本身不具備統計平穩性，我們必須將其轉換為**回報率 (Returns)** 進行建模。回報率是市場動能的精確度量，也是所有機率模型與風險預測的物理基礎。\n\n#### 專家決策矩陣：收益率選型標準\n選擇正確的收益率計算方式是確保風險模型穩定性的首要任務：\n\n| 特性 | 算術收益率 (Simple) | 對數收益率 (Log) |\n| :--- | :--- | :--- |\n| **核心定義** | $(P_t - P_{t-1}) / P_{t-1}$ | $\\ln(P_t / P_{t-1})$ |\n| **資深建議** | 強調資產組合的可加性 | 具備時間可加性與持續複利特性 |\n| **實務場景** | 應用於單期績效歸因與資產估值 | 應用於動態風險演化、隨機建模 (GBM) |\n| **關鍵約束** | 計算直觀但長期存在累計偏誤 | 確保股價恆正 ($e^x > 0$)，符合市場邏輯 |\n\n#### 技術推導：時間可加性的權威優勢 (Fixed Layout)\n對數收益率支援多期累加，這是構建動態風險模型的核心技術優勢：$$\n\begin{aligned}\n  r_{0,2} &= \\ln(P_2/P_1) + \\ln(P_1/P_0) \\\\\n          &= \\ln\\left(\\frac{P_2}{P_1} \\cdot \\frac{P_1}{P_0}\\right) \\\\\n          &= \\ln(P_2/P_0)\n\\end{aligned}\n$$\n\n> [!IMPORTANT]\n> 在 Python 資工體系（使用 **NumPy**）中，我們統一使用 `np.log(df['price'] / df['price'].shift(1))` 進行向量化運算。在高頻交易或長序列環境下，對數回報能有效消除浮點運算累積誤差並極大化計算效率。\n\n#### 1.1 資深從業人員行動清單 (Action Items)\n執行波動率建模前，必須依序完成以下項目：\n- **確認收益率選型**：長期隨機過程模擬或衍生品定價必須選用對數回報。\n- **執行平穩性校驗**：所有回報序列必須通過 ADF 定常性檢定，嚴格禁止對非平穩數據進行統計建模。\n- **數據邊界清洗**：必須排除價格數據中的負值與零值，確保對數計算的數值稳定性。\n\n#### 核心技術結論\n我們之所以在幾何布朗運動 (GBM) 與風險演化系統中使用對數回報，是因為它不僅提供了時間維度的計算便利性，更從數學底層保證了資產價格的非負性。這是構建任何穩健金融風險模型的前提條件。",
      "1.2": "### 1.2 歷史波動性 (Historical Volatility)：風險的統計標尺\n波動性（Volatility）反映的是回報率的不確定性，是金融風險管理的靈魂指標。在標準統計框架下，我們將其定義為收益率序列的**樣本標準差**。資深從業人員必須將其視為計算風險價值（VaR）與期權定價的物理輸入。\n\n#### 專家定義：樣本標準差\n我們對日對數收益率序列 $r_t$ 計算其離散程度，嚴格定義如下：\n\n$$\n\\sigma_{sample} = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^n (r_i - \\bar{r})^2}\n$$\n\n#### 決策矩陣：估計窗口 (Look-back Windows) 選型\n觀測窗口的選擇直接決定了模型在靈敏度與穩健性之間的平衡：\n\n| 窗口長度 | 適用場景 | 優點 | 缺點 |\n| :--- | :--- | :--- | :--- |\n| **短期 (20-30天)** | 高頻交易、極端壓力測試 | 反應靈敏，能迅速捕捉市場劇震 | 存在高度隨機雜訊，數值不穩定 |\n| **長期 (1年/252天)** | 資本計提、戰略資產配置 | 數據穩健，反映產期風險特徵 | 存在幽靈效應 (Ghost Effect)，反應遲鈍 |\n\n#### 技術標準：年化與平方根定律 (Fixed)\n由於風險隨時間累積的速度與時間平方根成正比，標準化年化轉換是業界通用的物理準則：$$\n\begin{aligned}\n  \\sigma_{annual} &= \\sigma_{daily} \\times \\sqrt{T_{trading}} \\\\\n                  &= \\sigma_{daily} \\times \\sqrt{252}\n\\end{aligned}\n$$\n\n> [!IMPORTANT]\n> 在 **Pandas** 實作中（見 `B2_Ch1_3.py`），使用 `.rolling(window=22).std()` 進行滾動窗口計算是標準流程。必須在「估計誤差」與「數據時效性」之間做出精確權衡，避免使用過時數據誤導當前的風險判斷。\n\n#### 1.2 資深從業人員行動清單 (Action Items)\n執行歷史波動率分析前，必須確認：\n- **數據一致性校驗**：確保價格序列已根據分紅與拆股進行調整（使用 Adjusted Close）。\n- **窗口匹配審計**：交易策略的持有期與波動率估計窗口必須具備邏輯一致性。\n- **年化標準化**：嚴格遵守 252 個交易日的轉換標準，禁止混淆日度與年度波動率維度。",
      "1.3": "### 1.3 移動平均 (Moving Average) 與動態波動率：捕捉緩衝情緒\n金融市場並非靜態過程，而是存在顯著的「冷熱更迭」與「波動聚集」。為了精確反映當前風險，我們必須採用動態權重模型，使系統具備即時的情緒感知能力。\n\n#### 專家對比：SMA 模式 vs. EWMA 模式\n模型對新資訊的反應速度是風險管理決策的核心權衡指標：\n\n| 特性 | 簡單移動平均 (SMA) | 指數加權移動平均 (EWMA) |\n| :--- | :--- | :--- |\n| **權重分配策略** | 所有歷史數據權重均等 ($1/m$) | 近期數據權重高，隨時間呈指數衰減 |\n| **主要缺陷** | **幽靈效應**：過時大波動移出窗口時造成假性跳空 | 對衰減因子 $\\lambda$ 的選擇極度敏感 |\n| **工業標準** | 基礎回測、輔助趨勢判定 | **RiskMetrics 標準**、動態 VaR 計算 |\n\n#### 核心技術：EWMA 遞迴解法\nEWMA 利用遞迴特性實現極高的計算效率。其方差更新方程如下：\n\n$$\n\\sigma_t^2 = (1-\\lambda) r_{t-1}^2 + \\lambda \\sigma_{t-1}^2\n$$\n\n- **衰減參數 $\\lambda$**：業界標準針對日資料建議使用 **0.94**。$\\lambda$ 值越高，代表模型對過去狀態的「記憶」越久，波動率曲線越趨於平滑。\n\n> [!TIP]\n> 在 **Pandas** 生態中（見 `B2_Ch1_4.py`），使用 `.ewm(span=m)` 函數能快速構建動態風險監控器。資深分析師會優先選用 EWMA 應對突發性的市場衝換，因為它能立即賦予最新價格變動顯著的權重。\n\n#### 1.3 資深從業人員行動清單 (Action Items)\n佈署動態波動率系統前，必須完成：\n- **參數精確校準**：根據資產類別與持有期設定 $\\lambda$ 值，嚴禁盲目套用預設參數。\n- **幽靈效應監控**：定期審計 SMA 曲線，防止因舊數據移出而產生誤導性的交易訊號。\n- **遞迴初始優化**：對第 0 期的 $\\sigma_0^2$ 進行合理初始化（通常採用長期樣本方差）。",
      "1.4": "### 1.4 自回歸條件異方差模型 (ARCH)：波動聚集的計量基礎\nRobert Engle 在 1982 年揭示了市場的重要特徵：波動是會傳染的。這種「大波動後往往接著大波動」的現象被稱為**波動聚集 (Volatility Clustering)**。ARCH 模型是歷史上首個成功量化此類非定常方差現象的數學框架。\n\n#### 專家定義：ARCH(q) 過程\nARCH(q) 模型將當前方差定義為過去 $q$ 期殘差平方（市場衝擊）的線性組合：\n\n$$\n\\sigma_t^2 = \\alpha_0 + \\sum_{i=1}^q \\alpha_i \\epsilon_{t-i}^2\n$$\n\n- **統計約束**：為確保方差恆正，必須滿足 $\\alpha_0 > 0$ 且 $\\alpha_i \\ge 0$。為了保證過程平穩且方差不發生發散，$\\sum \\alpha_i$ 必須嚴格小於 1。\n- **物理意涵**：殘差項 $\\epsilon_{t-i}^2$ 代表市場受到的非預期衝擊。這解釋了市場在極端事件後，恐慌情緒為何會持續停留而非瞬間消散。\n\n#### 決策矩陣：ARCH 模型實務侷限性\n雖然 ARCH 是開創性的，但在現代複雜系統中使用時需考量以下限制：\n\n| 評估維度 | ARCH(q) 模型表現 | 解決方案 |\n| :--- | :--- | :--- |\n| **參數效率** | 捕捉長記憶需極大化 $q$，導致過度擬合 | 升級為 GARCH 模型 |\n| **殘差假设** | 傳統假設為正態分佈，忽略了數據的肥尾特徵 | 採用 t-分佈或 GED 模型 |\n| **不對稱性** | 無法區分利多與利空對波動的差異化打擊 | 使用 GJR-GARCH 或 EGARCH |\n\n> [!IMPORTANT]\n> 在 Python 的 **arch** 套件部署中（見 `B2_Ch1_7.py`），必須通過 Ljung-Box 檢定驗證殘差平方是否存在自相關。若無連貫的 ARCH 效應，則無需使用複雜的異方差模型進行建模。\n\n#### 1.4 資深從業人員行動清單 (Action Items)\n分析 ARCH 效應前，必須落實：\n- **自相關性檢定**：對收益率殘差平方執行統計檢驗，確保具備建模的物理前提。\n- **資訊準則選型**：利用 AIC/BIC 確定最佳滯後階數 $q$，在模型複雜度與精確度間取得平衡。\n- **係數邊界校核**：嚴格檢查估計出的 $\\alpha$ 參數是否符合非負與平穩性約束條件。",
      "1.5": "### 1.5 廣義自回歸條件異方差模型 (GARCH)：波動性的長期記憶\nBollerslev 於 1986 年提出的 GARCH(1,1) 模型是風險管理的業界標準。它透過引入方差的自回歸項，成功解決了 ARCH 模型參數臃腫的問題，並完美描述了波動率向長期均值回歸的物理特性。\n\n#### 專家決策矩陣：模型係數與風險特徵\n在方程 $\\sigma_t^2 = \\omega + \\alpha \\epsilon_{t-1}^2 + \\beta \\sigma_{t-1}^2$ 中，參數配置決定了市場的性格：\n\n| 參數 | 核心內涵 | 市場解釋 | 實務警示 |\n| :--- | :--- | :--- | :--- |\n| **$\\alpha$** | ARCH 項係數 | 市場受衝擊後的反應敏感度 | $\\alpha$ 過高代表波動會出現劇烈跳空 |\n| **$\\beta$** | GARCH 項係數 | 波動路徑的持久度（記憶力） | $\\beta$ 越高代表波動聚集現象越難消失 |\n| **$\\alpha + \\beta$** | 持久度總和 | 波動回歸長線平均的速度 | 接近 1 代表系統恢復穩定的速度極慢 |\n\n#### 技術推導：均值回歸與長期均衡方差 (Fixed)\n資深從業人員必須確保模型具備穩定性。當 $\\alpha + \\beta < 1$ 時，模型最終將回歸其長期均衡水平 $V_L$$\n\begin{aligned}\n  \\sigma_t^2 &= \\omega + (\\alpha + \\beta) \\sigma_{t-1}^2 \\quad (\\text{假設預期 } \\epsilon_{t-1}^2 = \\sigma_{t-1}^2) \\\\\n  V_L &= \\omega + (\\alpha + \\beta) V_L \\\\\n  V_L &= \\frac{\\omega}{1 - \\alpha - \\beta}\n\\end{aligned}\n$$\n\n> [!IMPORTANT]\n> 在 **arch** 部署實作中（見 `B2_Ch1_7.py`），我們必須隨時監控 $\\alpha + \\beta$ 的總和。若該值 $\\ge 1$ (IGARCH)，代表模型不具備回歸特性，長期風險預估將失去統計學上的收斂基礎。\n\n#### 1.5 資深從業人員行動清單 (Action Items)\n部署 GARCH 模型前，必須完成：\n- **穩定性極限測試**：計算並驗證 $\\alpha + \\beta < 1$，計算對應的長期年化波動率 $100 \\times \\sqrt{V_L \\times 252}$。\n- **參數顯著性檢查**：確保 $\\alpha$ 與 $\\beta$ 的 t-統計量均具備顯著性，排除過度擬合嫌疑。\n- **條件分佈優化**：若數據存在極端偏離，必須從 `dist='Normal'` 切換為更具魯棒性的 `dist='t'` 分佈。",
      "1.6": "### 1.6 波動性估計與預測：從模型配適到風險判斷\n掌握 GARCH 理論後，核心任務是利用最大似然估計 (MLE) 獲取最佳參數，並對未來的風險分佈進行精準投射。資深從業人員必須識別出統計顯著的模型，而非僅僅是擬合數據。\n\n#### 專家決策矩陣：模型預測範圍\n在實務中，預測時間跨度的選擇直接決定了風險管理的深度：\n\n| 預測週期 | 核心使命 | 實務依賴 |\n| :--- | :--- | :--- |\n| **1-Day Forecast** | 日內頭寸限額監控、動態 VaR | 基於 $t$ 時刻所有資訊的條件方差 |\n| **Multi-Day (K-Days)** | 資本計提、長期衍生品套期保值 | 依賴均值回歸特性向長期平均 $V_L$ 逼近 |\n\n#### 技術核心：MLE 與配適度\n我們透過極大化似然函數來尋找最能解釋歷史回報序列的參數集合。在 `B2_Ch1_7.py` 中，我們實作了這一工業級流程：$$\n\begin{aligned}\n  \\mathcal{L}(\\theta) &= \\sum_{t=1}^T \\ln f(r_t | \\sigma_t^2; \\theta) \\\\\n  \\text{Forecast } \\hat{\\sigma}_{T+1}^2 &= \\hat{\\omega} + \\hat{\\alpha} \\epsilon_T^2 + \\hat{\\beta} \\sigma_T^2\n\\end{aligned}\n$$\n\n> [!IMPORTANT]\n> 在 **arch** 實務中，必須檢查 `result.summary()` 中的收斂狀態。若優化器未收斂 (Non-convergence)，則所有參數均不可信。資深分析師會通過更換 `update_freq` 或調整初值來解決收斂問題。\n\n#### 1.6 資深從業人員行動清單 (Action Items)\n執行模型預測前，必須確保：\n- **顯著性分析**：檢查 $\\alpha$ 與 $\\beta$ 的 p-value。若不顯著，應簡化模型為 EWMA。\n- **殘差白噪聲化**：對配適後的標準化殘差進行自相關測試，確保模型已完全吸納波動路徑。 \n- **外推校準**：長期預測必須考量市場結構性變化，禁止盲目進行超長期的純統計預測。",
      "1.7": "### 1.7 隱含波動性 (Implied Volatility) 與數值求解：市場的預期代碼\n隱含波動率 (IV) 反映的是期權市場參與者對未來風險的「報價組合」。它不是對過去的總結，而是對未來的診斷。在資深定價體系中，我們透過反推 Black-Scholes 方程來獲取這個關鍵維度。\n\n#### 專家決策矩陣：隱含 vs. 歷史波動率\n理解兩者的維度差異是構建套利策略或套期保值方案的前提：\n\n| 指標 | 歷史波動率 (HV) | 隱含波動率 (IV) |\n| :--- | :--- | :--- |\n| **資訊來源** | 過去的收盤價序列 | 當前的期權成交價格 |\n| **時間方向** | 向後看 (Backward-looking) | 向前看 (Forward-looking) |\n| **核心用途** | 估計資產真實風險特徵 | 市場情緒分析、尋找定價偏差 (VRP) |\n\n#### 技術核心：數值算法與牛頓法策略\n由於 Black-Scholes 方程中 $\\sigma$ 是超越變量，我們無法獲得解析解，必須使用數值方法。其核心數學邏輯如下：$$\n\begin{aligned}\n  \\text{Minimize } & | C_{BS}(\\sigma) - C_{Market} | \\\\\n  \\sigma_{n+1} &= \\sigma_n - \\frac{C_{BS}(\\sigma_n) - C_{Market}}{Vega}\n\\end{aligned}\n$$\n\n> [!TIP]\n> 在 Python 實作中（見 `B2_Ch1_9.py`），使用 `scipy.optimize.brentq` 比牛頓法更穩定，因為它結合了二分法與插值法，能更安全地處理目標函數的不連續性。資深開發者應優先選擇 Brent 算法以確保 IV 求解的魯棒性。\n\n#### 1.7 資深從業人員行動清單 (Action Items)\n執行 IV 計算時，必須落實：\n- **模型邊界檢查**：若市場價格低於期權的內在價值 (Intrinsic Value)，則 IV 無解，必須檢查輸入的利率與股息參數。\n- **Vega 敏感度監控**：在期權極度價外 (OTM) 時，Vega 趨近於 0，數值求解容易失效，此時應考慮區間縮減法。\n- **微笑曲線分析**：計算不同執行價的 IV，構建波動率微笑 (Volatility Smile)，以識別市場對極端尾部風險的定價偏好。\n\n#### 核心技術結論\n隱含波動率是期權交易的「通用語言」。掌握數值求解技術不僅能讓你獲得這一語言的解碼權，更是通往複雜波動率交易（如 Straddles 或 Delta-Neutral 策略）的必經之路。"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "1.1 收益率計算與數據擷取實作",
        "filename": "B2_Ch1_1.py",
        "code": "# B2_Ch1_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch1_1_A.py\nimport numpy as np\nimport pandas_datareader \n\nticker = 'AMZN'\nstock = pandas_datareader.data.DataReader(ticker, data_source='yahoo', start='12-21-2020', end='12-28-2020')['Adj Close']\nprint(stock)\n\n# B2_Ch1_1_B.py\n# via formula\nreturns_daily = (stock / stock.shift(1)) - 1\nprint(returns_daily)\n\n# B2_Ch1_1_C.py\n# alternative via pct_change() function\nreturns_daily = stock.pct_change()\nprint(returns_daily)\n\n# B2_Ch1_1_D.py\n# log return\nlog_return_daily = np.log(stock / stock.shift(1))\nprint(log_return_daily)"
      },
      {
        "id": "ex2",
        "title": "1.2 多資產收益率視覺化對比",
        "filename": "B2_Ch1_2.py",
        "code": "# B2_Ch1_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch1_2_A.py\nimport pandas_datareader \nimport matplotlib.pyplot as plt\n\n# sp500 price\nsp500 = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2010', end='12-28-2020')\n# plot sp500 price\nplt.plot(sp500['sp500'], color='dodgerblue')\nplt.title('S&P 500 price')\nplt.xlabel('Date')\nplt.ylabel('Price')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n# B2_Ch1_2_B.py\n# daily return\nsp500['return_daily'] = sp500['sp500'].pct_change()\nsp500.dropna(inplace=True)\n# plot daily return\nplt.plot(sp500['return_daily'], color='dodgerblue')\nplt.title('S&P 500 daily returns')\nplt.xlabel('Date')\nplt.ylabel('Daily return')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n# B2_Ch1_2_C.py\n# monthly return\nsp500_monthly_returns = sp500['sp500'].resample('M').ffill().pct_change()\n# plot monthly return\nplt.plot(sp500_monthly_returns, color='dodgerblue')\nplt.title('S&P 500 monthly returns')\nplt.xlabel('Date')\nplt.ylabel('Monthly return')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n# B2_Ch1_2_D.py\n# daily cumulative return\nsp500_cum_returns_daily = (sp500['return_daily'] + 1).cumprod()\n# plot daily cumulative return\nplt.plot(sp500_cum_returns_daily, color='dodgerblue')\nplt.title('S&P 500 daily cumulative returns')\nplt.xlabel('Date')\nplt.ylabel('Cumulative return')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n# B2_Ch1_2_E.py\n# monthly cumulative return\nsp500_cum_returns_monthly = (sp500_monthly_returns + 1).cumprod()\n# plot monthly cumulative return\nplt.plot(sp500_cum_returns_monthly, color='dodgerblue')\nplt.title('S&P 500 daily cumulative returns')\nplt.xlabel('Date')\nplt.ylabel('Cumulative return')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex3",
        "title": "1.3 波動率動態計算與視覺化",
        "filename": "B2_Ch1_3.py",
        "code": "# B2_Ch1_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib as mpl\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas_datareader\n \n# sp500 price\nsp500 = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2019', end='12-28-2020')\n\n# daily log return\nlog_return_daily = np.log(sp500 / sp500.shift(1))\nlog_return_daily.dropna(inplace=True)\n     \n# calculate daily standard deviation of returns\ndaily_std = np.std(log_return_daily)[0]\n \n# annualize daily standard deviation\nstd = daily_std * 252 ** 0.5\n \n# Plot histograms\nmpl.style.use('ggplot')\nfig, ax = plt.subplots(1, 1, figsize=(10, 6))\nn, bins, patches = ax.hist(\n    log_return_daily['sp500'],\n    bins='auto', alpha=0.7, color='dodgerblue', rwidth=0.85)\n\nax.set_xlabel('Log return')\nax.set_ylabel('Frequency of log return')\nax.set_title('Historical volatility for SP500')\n \n# get x and y coordinate limits\nx_corr = ax.get_xlim()\ny_corr = ax.get_ylim()\n \n# make room for text\nheader = y_corr[1] / 5\ny_corr = (y_corr[0], y_corr[1] + header)\nax.set_ylim(y_corr[0], y_corr[1])\n\n# print historical volatility on plot\nx = x_corr[0] + (x_corr[1] - x_corr[0]) / 30\ny = y_corr[1] - (y_corr[1] - y_corr[0]) / 15\nax.text(x, y , 'Annualized volatility: ' + str(np.round(std*100, 1))+'%',\n    fontsize=11, fontweight='bold')\nx = x_corr[0] + (x_corr[1] - x_corr[0]) / 15\ny -= (y_corr[1] - y_corr[0]) / 20\n\nfig.tight_layout()"
      },
      {
        "id": "ex4",
        "title": "1.4 歷史波動率時間序列分析",
        "filename": "B2_Ch1_4.py",
        "code": "# B2_Ch1_4.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport pandas_datareader\nimport matplotlib.pyplot as plt \n\n# sp500 price\ndf = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2010', end='12-28-2020')\ndf.dropna(inplace=True)\n\n# daily log return\ndf['Daily return squared'] = np.log(df['sp500'] / df['sp500'].shift(1))*np.log(df['sp500'] / df['sp500'].shift(1))\ndf.dropna(inplace=True)\n\n# calculate simple moving average\nwin_list = [5, 50, 100, 250]\nfor win in win_list:\n    ma = df['sp500'].rolling(win).std()\n    df[win] = ma\n    df.rename(columns={win:'Vol via '+str(win)+' days MA'}, inplace=True)\n\n# plot dataframe\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 12))\n# sp500 price\nax1.plot(df['sp500'])\nax1.set_title('SP500 price')\nax1.set_xlabel(\"Date\")\nax1.set_ylabel(\"Price\")\nax1.spines['right'].set_visible(False)\nax1.spines['top'].set_visible(False)\nax1.yaxis.set_ticks_position('left')\nax1.xaxis.set_ticks_position('bottom')\n# daily log return squared\nax2.plot(df['Daily return squared'])\nax2.set_title('Daily return squared')\nax2.set_xlabel(\"Date\")\nax2.set_ylabel(\"Daily return squared\")\nax2.spines['right'].set_visible(False)\nax2.spines['top'].set_visible(False)\nax2.yaxis.set_ticks_position('left')\nax2.xaxis.set_ticks_position('bottom')\n# ma vol\nax3.plot(df.loc[:, (df.columns != 'sp500') & (df.columns != 'Daily return squared')])\nax3.legend(df.loc[:, (df.columns != 'sp500') & (df.columns != 'Daily return squared')].columns)\nax3.set_title('SP500 price volatility via moving average analysis')\nax3.set_xlabel(\"Date\")\nax3.set_ylabel(\"Volatility\")\nax3.spines['right'].set_visible(False)\nax3.spines['top'].set_visible(False)\nax3.yaxis.set_ticks_position('left')\nax3.xaxis.set_ticks_position('bottom')\n\nfig.tight_layout()"
      },
      {
        "id": "ex5",
        "title": "1.5 金融數據多維視覺化佈局",
        "filename": "B2_Ch1_5.py",
        "code": "# B2_Ch1_5.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport pandas_datareader\nimport matplotlib.pyplot as plt \n\n# sp500 price\ndf = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2010', end='12-28-2020')\ndf.dropna(inplace=True)\n\n# calculate cumulative moving average\ndf['cma'] = df['sp500'].expanding(1).std()\ndf.dropna(inplace=True)\n# df.rename(columns={win:'Vol via '+str(win)+' days MA'}, inplace=True)\n\n# plot dataframe\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 12))\nax1.plot(df['sp500'])\nax1.set_title('SP500 price')\nax1.set_xlabel(\"Date\")\nax1.set_ylabel(\"Price\")\nax1.spines['right'].set_visible(False)\nax1.spines['top'].set_visible(False)\nax1.yaxis.set_ticks_position('left')\nax1.xaxis.set_ticks_position('bottom')\n\nax2.plot(df['cma'])\nax2.set_title('SP500 price volatility via cumulative moving average analysis')\nax2.set_xlabel(\"Date\")\nax2.set_ylabel(\"Volatility\")\nax2.spines['right'].set_visible(False)\nax2.spines['top'].set_visible(False)\nax2.yaxis.set_ticks_position('left')\nax2.xaxis.set_ticks_position('bottom')\n\nfig.tight_layout()\n"
      },
      {
        "id": "ex6",
        "title": "1.6 收益率分佈特徵與統計繪圖",
        "filename": "B2_Ch1_6.py",
        "code": "# B2_Ch1_6.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport pandas_datareader\nimport matplotlib.pyplot as plt \nimport numpy as np\n\n# sp500 price\ndf = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2010', end='12-28-2020')\ndf.dropna(inplace=True)\n\n# daily log return\ndf['Daily return squared'] = np.log(df['sp500'] / df['sp500'].shift(1))*np.log(df['sp500'] / df['sp500'].shift(1))\ndf.dropna(inplace=True)\n\n# calculate exponentially weighted moving average\nalpha_list = [0.01, 0.03, 0.06]\nfor alpha in alpha_list:\n    ma = df['sp500'].ewm(alpha=alpha, adjust=False).std()\n    df[alpha] = ma\n    df.rename(columns={alpha:'$\\lambda$ = '+str(1-alpha)}, inplace=True)\n\n# plot dataframe\n# sp500 price\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 12))\nax1.plot(df['sp500'])\nax1.set_title('SP500 price')\nax1.set_xlabel(\"Date\")\nax1.set_ylabel(\"Price\")\nax1.spines['right'].set_visible(False)\nax1.spines['top'].set_visible(False)\nax1.yaxis.set_ticks_position('left')\nax1.xaxis.set_ticks_position('bottom')\n\n# daily log return squared\nax2.plot(df['Daily return squared'])\nax2.set_title('Daily return squared')\nax2.set_xlabel(\"Date\")\nax2.set_ylabel(\"Daily return squared\")\nax2.spines['right'].set_visible(False)\nax2.spines['top'].set_visible(False)\nax2.yaxis.set_ticks_position('left')\nax2.xaxis.set_ticks_position('bottom')\n# ewma vol\nax3.plot(df.loc[:, (df.columns != 'sp500') & (df.columns != 'Daily return squared')])\nax3.legend(df.loc[:, (df.columns != 'sp500') & (df.columns != 'Daily return squared')].columns)\nax3.set_title('SP500 price volatility via EWMA analysis')\nax3.set_xlabel(\"Date\")\nax3.set_ylabel(\"Volatility\")\nax3.spines['right'].set_visible(False)\nax3.spines['top'].set_visible(False)\nax3.yaxis.set_ticks_position('left')\nax3.xaxis.set_ticks_position('bottom')\n\nfig.tight_layout()"
      },
      {
        "id": "ex7",
        "title": "1.7 ARCH/GARCH 模型配適與預測",
        "filename": "B2_Ch1_7.py",
        "code": "# B2_Ch1_7.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch1_7_A.py\nimport numpy as np\nimport pandas_datareader\nimport matplotlib.pyplot as plt \nfrom arch import arch_model\n\n# sp500 price\nsp500 = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2009', end='12-28-2020')\n\n# daily log return\nlog_return_daily = np.log(sp500 / sp500.shift(1))\nlog_return_daily.dropna(inplace=True)\n\n# ARCH(1) model\narch=arch_model(y=log_return_daily,mean='Constant',lags=0,vol='ARCH',p=1,o=0,q=0,dist='normal')\narchmodel=arch.fit()\narchmodel.summary()\narchmodel.plot()\n\n# B2_Ch1_7_B.py\nplt.figure(figsize=(12,8))\nplt.plot(log_return_daily,label='Daily return')\nplt.plot(archmodel.conditional_volatility, label='Conditional volatility')\nplt.legend()\nplt.xlabel('Date')\nplt.ylabel('Return/Volatility')\n\n# B2_Ch1_7_C.py\n# GARCH(1,1) model\ngarch=arch_model(y=log_return_daily,mean='Constant',lags=0,vol='GARCH',p=1,o=0,q=1,dist='normal')\ngarchmodel=garch.fit()\ngarchmodel.summary()\ngarchmodel.plot()\n\n# B2_Ch1_7_D.py\nplt.figure(figsize=(12,8))\nplt.plot(log_return_daily,label='Daily return')\nplt.plot(archmodel.conditional_volatility, label='Conditional volatility')\nplt.legend()\nplt.xlabel('Date')\nplt.ylabel('Return/Volatility')"
      },
      {
        "id": "ex8",
        "title": "1.8 期權 Delta 基礎計算與視覺化",
        "filename": "B2_Ch1_8.py",
        "code": "# B2_Ch1_8.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport pandas_datareader\nimport matplotlib.pyplot as plt \nimport datetime\nimport matplotlib.dates as mdates\n\n\n# sp500 price\nsp500 = pandas_datareader.data.DataReader(['sp500'], data_source='fred', start='12-28-2009', end='12-28-2020')\n\n# daily log return\nlog_return_daily = np.log(sp500 / sp500.shift(1))\nlog_return_daily.dropna(inplace=True)\n\nn = 250\nr = log_return_daily.iloc[-n:]\n\n# volatility prediction by EWMA with λ=0.94\nlmd = 0.94\nvol_ewma = np.zeros(n)\nvol_ewma[0] = log_return_daily[(-n+1):(-n+6)].std()\nfor i in range(n-1):\n    vol_ewma[i+1] = np.sqrt(lmd*vol_ewma[i]**2 + (1-lmd)*r.iloc[i]**2)\n    \n# volatility prediction by ARCH(1)\nomega_arch = 0.000068\nalpha1 = 0.45 \nvol_arch = np.zeros(n)\nvol_arch[0] = np.sqrt(omega_arch + alpha1*log_return_daily.iloc[-n-1]**2)\nfor i in range(n-1):\n    vol_arch[i+1] = np.sqrt(omega_arch + alpha1*r.iloc[i]**2)\n\n#GARCH(1,1)\nomega = 0.000002\nalpha1 = 0.2\nbeta1 = 0.78\n\nvol_garch = np.zeros(n)\nvol_garch[0] = log_return_daily[-n+1:-n+6].std()\nfor i in range(n-1):\n    vol_garch[i+1] = np.sqrt(omega + alpha1*r.iloc[i]**2 + beta1*vol_garch[i]**2)\n\n# plot the curves\nxdate=(r.index+datetime.timedelta(days=1))\nplt.figure(figsize=(12,8))\nplt.xlabel('Date')\nplt.ylabel('Volatility')\nplt.title('Volatility comparison')\nplt.plot(xdate,vol_arch, label='ARCH(1)')\nplt.plot(xdate,vol_garch, label='GARCH(1,1)')\nplt.plot(xdate,vol_ewma, label='EWMA') \n\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%m/%d/%Y'))\nplt.gca().xaxis.set_major_locator(mdates.DayLocator(15))\nplt.xticks(rotation=30)\nplt.legend()\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex9",
        "title": "1.9 Black-Scholes Formula 與 IV 求解",
        "filename": "B2_Ch1_9.py",
        "code": "# B2_Ch1_9.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nfrom scipy import stats\n\n# function to calculate price of options (call or put) by BS\ndef option_price_BS(option_type, sigma, s, k, r, T, q=0.0):    \n    d1 = (np.log(s / k) + (r - q + sigma ** 2 * 0.5) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    if option_type == 'call':\n        option_price = np.exp(-r*T) * (s * np.exp((r - q)*T) * stats.norm.cdf(d1) - k *  stats.norm.cdf(d2))\n        return option_price\n    elif option_type == 'put':\n        option_price = np.exp(-r*T) * (k * stats.norm.cdf(-d2) - s * np.exp((r - q)*T) *  stats.norm.cdf(-d1))\n        return option_price\n    else:\n        print('Option type should be call or put.')\n\n# funciton to calculate implied volatility by bisection method\ndef implied_vol(option_type, option_price, s, k, r, T, q):  \n    precision = 0.00001\n    upper_vol = 500.0\n    lower_vol = 0.0001\n    iteration = 0\n\n    while iteration >= 0:\n\n        iteration +=1\n        mid_vol = (upper_vol + lower_vol)/2.0\n        price = option_price_BS(option_type, mid_vol, s, k, r, T, q)\n        \n        if option_type == 'call':\n            lower_price = option_price_BS(option_type, lower_vol, s, k, r, T, q)\n            if (lower_price - option_price) * (price - option_price) > 0:\n                lower_vol = mid_vol\n            else:\n                upper_vol = mid_vol\n            if abs(price - option_price) < precision: \n                break \n\n        elif option_type == 'put':\n            upper_price = option_price_BS(option_type, upper_vol, s, k, r, T, q)\n\n            if (upper_price - option_price) * (price - option_price) > 0:\n                upper_vol = mid_vol\n            else:\n                lower_vol = mid_vol\n            if abs(price - option_price) < precision: \n                break \n            \n        if iteration == 100: \n            break\n    print('Implied volatility: %.2f' % mid_vol)\n    return mid_vol\n\n\nimplied_vol('call', 17.5, 586.08, 585, 0.0002, 30.0/365, 0.0)\n"
      },
      {
        "id": "ex10",
        "title": "1.10 期權鏈數據分析與 IV 曲面初步",
        "filename": "B2_Ch1_10.py",
        "code": "# B2_Ch1_10.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch1_10_A.py\nfrom mibian import BS\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# convert data to dataframe and initialize \"Implied volatility\" column\noption_data = pd.read_csv(r\"C:\\Users\\anran\\Dropbox\\FRM Book\\Volatility\\SPX_Option.csv\")\noption_data['date'] = pd.to_datetime(option_data['date'])\noption_data['Implied volatility'] = 0\noption_data.head\n\n\n# B2_Ch1_10_B.py\n# function to calculate implied volatility\ndef compute_implied_volatility(row):\n    underlyingPrice = row['underlying value']\n    strikePrice = row['strike']\n    interestRate = 0.002\n    daysToMaturity = row['days to maturity']\n    optionPrice = row['call price']\n    result = BS([underlyingPrice, strikePrice, interestRate, daysToMaturity], callPrice= optionPrice)\n    return result.impliedVolatility\n\noption_data['Implied volatility'] = option_data.apply(compute_implied_volatility, axis=1)\n\n\n# B2_Ch1_10_C.py\n# plot volatility smile\noption_data = option_data[option_data['date'] == pd.to_datetime('1/15/2021')]\nplt.plot(option_data['strike'], option_data['Implied volatility'])\nplt.title('Volatility smile')\nplt.ylabel('Implied volatility')\nplt.xlabel('Strike price')           \n\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')"
      }
    ]
  }
}