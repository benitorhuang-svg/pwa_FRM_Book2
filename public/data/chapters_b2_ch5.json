{
  "id": "b2_ch5",
  "title": "第5章：選擇權二元樹",
  "number": 5,
  "content": {
    "intro": {
      "title": "第 5 章：選擇權二元樹 - 重點詳解 (Detail)",
      "roadmap": {
        "guide": "二元樹模型（Binomial Tree Model）是衍生品定價中最重要的離散時間模型。它不僅在理論上揭示了風險中性定價與無套利原理，更在實務上成為處理「美式選擇權」提前行權問題的首選工具。",
        "objectives": "*   理解如何將波動率 $\\sigma$ 映射為向上 $(u)$ 與向下 $(d)$ 的變動幅度。\n*   掌握風險中性機率 ($p$) 的推導及其與無套利原理的關係。\n*   掌握逆向誘導（Backward Induction）在定價過程中的應用。",
        "topics": "*   5.1 選擇權市場與合約規格\n*   5.2 標的物二元樹 (Asset Tree) 構建\n*   5.3 歐式選擇權二元樹 (European Options)\n*   5.4 美式選擇權二元樹 (American Options) 與提前行權\n*   5.5 二元樹步數 (Steps) 對收斂性的影響\n*   5.6 其他二元樹變體與擴展"
      },
      "value": {
        "practical": "*   **實務場景**：計算具有複雜提前行權條件的個股選擇權價值。\n*   **考試重點**：理解二元樹步數增加時，其結果如何趨近於 Black-Scholes 解析解。",
        "theory": "二元樹的構建基於價格僅有 $Su$ 或 $Sd$ 兩種可能。其中 $u = e^{\\sigma \\sqrt{\\Delta t}}, d = 1/u$，風險中性機率 $p = \\frac{e^{r\\Delta t} - d}{u - d}$。",
        "further_reading": "*   Cox, Ross, & Rubinstein (1979) 原始論文。"
      },
      "implementation": {
        "python": "*   **逆向遞迴**：實作 `Binomialtree()` 函數進行期權價值推導。\n*   **美式行權**：在節點處加入 `max(intrinsic_value, option_value)` 邏輯。\n*   **收斂性分析**：對比離散計步與 BSM 解析解的差異。",
        "logic": "*   逆向誘導：從到期日回推至當前價值。\n*   美式期權：考量提前行權的最優決策。",
        "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B2_Ch5_1.py** | 定義期權損益與 Payoff 函數，演示多種金融衍生品策略視覺化。 |\n| **B2_Ch5_2.py** | 實作基礎二項樹模型 (Binomial Tree) 計算期權價格。 |\n| **B2_Ch5_3.py** | 演示二項樹模型在不同步數設定下，期權價值的波動與收斂。 |\n| **B2_Ch5_4.py** | 實作二項樹模型定價分析，演示波動率對期權價值的非線性影響。 |\n| **B2_Ch5_5.py** | **[對比]** 二項樹模型與 Black-Scholes 解析解的收斂性分析。 |\n| **B2_Ch5_6.py** | **[核心]** 實作美式期權二項樹定價模型，分析提前行權邊界。 |\n| **B2_Ch5_7.py** | 演示二項樹模型在包含紅利 (Dividend Yield) 下的定價調整。 |\n| **B2_Ch5_8.py** | 實作多參數敏感性分析，繪製期權價值與參數關係圖。 |"
      }
    },
    "body": {
      "5.1": "### 5.1 選擇權市場與合約規格：權利與義務的結構化\n在衍生品風險管理中，選擇權合約定義了一種「非對稱」的風險收益特徵。買方擁有權利但無義務，這使得選擇權具備了與生俱來的凸性 (Convexity)。資深從業人員必須精確掌握合約規格，這是所有定價模型與對沖算法的輸入底層。\n\n#### 專家決策矩陣：選擇權分類與風險屬性\n理解不同合同條款對風險敞口的決定性影響：\n\n| 合約特徵 | 看漲選擇權 (Call) | 看跌選擇權 (Put) |\n| :--- | :--- | :--- |\n| **核心權利** | 以約定價格 $K$ 「買入」標的資產 | 以約定價格 $K$ 「賣出」標的資產 |\n| **市場預期** | 看好標的價格上漲（多頭情緒） | 預期市場下跌（對沖或空頭情緒） |\n| **理論損益** | $\\max(S - K, 0)$ | $\\max(K - S, 0)$ |\n| **風險極限** | 買方損失上限為權利金，收益理論無限 | 買方損失上限為權利金，收益上限為 $K$ |\n\n#### 技術核心：內在價值與時間價值\n期權價格 $C = IV + TV$。資深分析師必須監控兩者的構成比例。隨著到期日臨近，時間價值 (Time Value) 會加速衰減（即 Theta Risk），這要求對沖策略具備極高的動態性。\n\n> [!IMPORTANT]\n> 在生產端計算 Payoff 時（見 `B2_Ch5_1.py`），我們統一使用向量化的 `np.maximum` 運算。必須注意，選擇權合約的流動性隨執行價與到期日的不同而存在巨大差異，這在計算希臘字母與執行 Delta 對沖時會引入顯著的市場衝擊成本。\n\n#### 5.1 資深從業人員行動清單 (Action Items)\n執行期權定價前，必須確認：\n- **合約乘數審計**：確認報價單位的標的數量（如每份合約代表 100 股），防止風險敞口計算出現量級錯誤。\n- **行權樣式定義**：明確區分歐式（僅到期行權）與美式（可提前行權），這將直接決定模型選型。\n- **股息處理配置**：確認標的資產在合約期間是否支付紅利，這對看跌期權的定價至關重要。",
      "5.2": "### 5.2 標的物二元樹 (Asset Tree) 構建：離散化波動率路徑\n二元樹模型將連續的時間軸切分為離散步長 $\\Delta t$，假設在每個時點價格僅具備向上或向下兩種演化路徑。它是將波動率 $\\sigma$ 轉化為可計算節點的物理映射，是風險中性定價理論的視覺化呈現。\n\n#### 專家定義：Cox-Ross-Rubinstein (CRR) 映射規則\n為了確保離散模型收斂至連續的 GBM 過程，參數 $u, d, p$ 必須精確配對：\n\n$$\n$$\n\\begin{aligned}\n  u &= e^{\\sigma \\sqrt{\\Delta t}} \\\\\n  d &= 1/u = e^{-\\sigma \\sqrt{\\Delta t}} \\\\\n  p &= \\frac{e^{r \\Delta t} - d}{u - d}\n\\end{aligned}\n$$\n$$\n\n#### 專家決策矩陣：風險中性機率 $p$ 的含義\n$p$ 並非市場真實預期的機率，而是為了滿足無套利定價而構造的數學權重：\n\n| 指標 | 風險中性機率 ($p$) | 真實機率 ($\\pi$) |\n| :--- | :--- | :--- |\n| **核心用途** | **定價**：計算折現期望值 | **預測**：估計實際收益路徑 |\n| **投資人假設** | 假設所有投資人皆為風險中性 | 承認投資人存在風險溢價要求 |\n| **漂移項匹配** | 資產預期回報恆等於 $r$ | 資產預期回報等於 $\\mu$ |\n\n> [!IMPORTANT]\n> 在構建二元樹時（見 `B2_Ch5_2.py`），資深開發者會使用 `np.arange` 預先生成各層級的節點座標。必須保證 $u > e^{r \\Delta t} > d$；若不滿足此條件，則代表發生套利空間，模型在數學上將不再收斂且失去實務意義。\n\n#### 5.2 資深從業人員行動清單 (Action Items)\n構建資產樹前，必須確認：\n- **波動率參數一致性**：確保 $\\sigma$ 與標的資產的歷史或隱含波動率水平相匹配。\n- **步數 $N$ 穩定性測試**：步數過少會導致估值擺動 (Oscillation)，資深分析師應選取足以讓 $e^{r \\Delta t} \\approx 1+r\\Delta t$ 的步數。\n- **分佈對象檢核**：確認所得的終端節點分佈符合對數正態分佈的離散近似形態。",
      "5.3": "### 5.3 歐式選擇權二元樹 (European Options)：逆向誘導定價法\n歐式選擇權的價值演化是一個典型的「逆向工程」。我們首先根據終端資產樹計算各節點的 Payoff，隨後利用風險中性機率一步步向當前時刻折現。這一過程體現了期權價值對未來期望損失與收益的動態定價。\n\n#### 技術核心：遞迴折現公式\n在任何一個中間節點 $t$，期權價值 $V_t$ 是其後繼兩個節點 $V_u$ 與 $V_d$ 的風險中性期望折現值：\n\n$$\n  V_t = e^{-r \\Delta t} [p V_u + (1-p) V_d]\n$$\n\n#### 決策矩陣：二元樹定價精度控管\n資深分析師需在計算成本與精度間進行決策：\n\n| 觀測項 | 表現特徵 | 優化策略 |\n| :--- | :--- | :--- |\n| **步數 $N$ 的影響** | 結果隨 $N$ 呈現鋸齒狀收斂 | 使用平均法（如 $N$ 與 $N+1$ 均值）或升級至泰勒展開修正 |\n| **計算邊界** | 記憶體消耗隨 $N^2$ 增長 | 採用單一向量更新法而非儲存整棵樹的節點 |\n| **希臘字母計算** | 透過初始節點的微小差異獲取 Delta/Gamma | 使用節點層級差分法以提升數值穩定性 |\n\n> [!IMPORTANT]\n> 在實作逆向遞迴時（見 `B2_Ch5_2.py`），資深分析師會使用「動態規劃」思維，僅保留當前層與下一層的數組。這在執行超大規模（如 $N=10,000$）的定價任務時，能將記憶體佔用降低幾個數量級。\n\n#### 5.3 資深從業人員行動清單 (Action Items)\n執行歐式定價前，必須確認：\n- **折現因子檢核**：確保 $\\Delta t$ 的單位（年、日）與利率 $r$ 的表達維度完全一致。\n- **終端節點邏輯**：嚴格檢查 $\\max(S_T - K, 0)$ 之類邊界函數的落實，防止行權判斷錯誤。\n- **解析解對標**：對標準歐式期權，必須與 BSM 公式結果核對，誤差應隨 $N$ 的增加而收斂至 $0$。",
      "5.4": "### 5.4 美式選擇權與提前行權：最優停時問題的解決方案\n美式選擇權賦予合約持有者在到期前任何時刻行權的權利，這在數學上被稱為「最優停時問題」。二元樹模型在此處展現了其超越 BSM 解析解的工業優勢：它能透過節點上的決策比較，精確識別提前行權的經濟價值。\n\n#### 核心邏輯：每個節點的抉擇\n在逆向誘導的每個路徑節點，我們必須強行比較「等待」與「立即行權」的價值：\n\n$$\n  V_{node} = \\max\\left( \\underbrace{e^{-r \\Delta t} [p V_u + (1-p) V_d]}_{\\text{Holding Value}}, \\underbrace{\\text{Intrinsic Value}}_{\\text{Early Exercise}} \\right)\n$$\n\n#### 專家決策矩陣：提前行權的最優環境\n資深分析師必須識別哪些因素會觸發提前行權決策：\n\n| 情況 | 行權動機 | 實務判斷 |\n| :--- | :--- | :--- |\n| **深度價內看跌 (Deep-in-the-money Put)** | 為了儘早獲取現金並賺取利息 | 常態現象：利息收入超過期權的時間價值消失 |\n| **標的資產派息 (Dividends)** | 為了在除息日前獲取股息（對看漲期權） | 當預期股息 > 時間價值損耗時，應提前行權 |\n| **無息資產看漲 (No-div Call)** | 無提前行權動機 | **理論黃金律**：不含息標的之美式 Call 等於歐式 Call |\n\n> [!IMPORTANT]\n> 在生產端演算法中（見 `B2_Ch5_6.py`），資深開發者會使用 `np.where` 同步處理所有節點的比較。必須意識到，美式期權的價格永遠 $\\ge$ 同規格歐式期權，這多出的溢價即為「行權靈活性溢價」。\n\n#### 5.4 資深從業人員行動清單 (Action Items)\n執行美式定價前，必須落實：\n- **行權邊界映射**：逐層記錄並繪製「提前行權區域」，分析標的價格觸碰該區域的機率。\n- **利率敏感度分析**：針對 Put 期權，嚴密監控 $r$ 的變化，利率上升會加速提前行權的誘因。\n- **股息時間點校準**：精確估計股息發放日期對二元樹節點的影響，確保「分紅跳水」已正確反映在資產樹中。",
      "5.5": "### 5.5 二元樹步數 (Steps) 對收斂性的影響：離散與連續的極限對話\n二元樹是一種「數值近似」，其核心挑戰在於結果的收斂穩定性。隨著步數 $N$ 的增加，二項分佈趨向於正態分佈，二元樹定價也將收斂於 Black-Scholes 解析解。資深分析師必須掌握這一動態規規，以確保在受限的計算資源下獲取最高精度的結果。\n\n#### 技術核心：中央極限定理的離散體現\n二元樹的收斂並非線性的，而是呈現出特殊的「鋸齒狀 (Sawtooth)」特徵，這是因為節點在執行價 $K$ 周圍的分布位置會隨著 $N$ 的變動而跳躍。\n\n| 觀測維度 | 低步數 ($N < 50$) | 高步數 ($N > 500$) |\n| :--- | :--- | :--- |\n| **估值噪聲** | 隨機性強，受節點與 $K$ 距離影響大 | 趨於平滑穩定，對 $K$ 的中心性不敏感 |\n| **計算速度** | 近乎瞬間完成 | 運算時間以 $O(N^2)$ 指數級上升 |\n| **主要應用** | 教學演示、粗略估值 | **工業級估值**、高精度 VaR 計算 |\n\n#### 專家決策矩陣：收斂性優化策略\n當標準二元樹收斂太慢時，資深計量師會採用以下變體：\n\n| 算法變體 | 優化原理 | 主要優勢 |\n| :--- | :--- | :--- |\n| **Leisen-Reimer (LR) 樹** | 調整 $u, d, p$ 使中心節點完美對齊 $K$ | 在極低步下即具備極高精度 |\n| **三元樹 (Trinomial Tree)** | 增加一個「保持不變」的機率分支 | **更穩定**：減少了二元項的擺動雜訊 |\n| **平滑處理** | 在到期前一期對 Payoff 進行線性插值 | 顯著消除鋸齒效應 |\n\n> [!IMPORTANT]\n> 在生產端測試中（見 `B2_Ch5_3.py`），我們對比了不同 $N$ 下的結果。資深開發者會發現，$N$ 遞增至一定閾值（如 $5,000$）後，精度提升將進入邊際遞減階段。必須識別此平衡點，避免無謂的算力浪費。\n\n#### 5.5 資深從業人員行動清單 (Action Items)\n執行大型模擬前，必須確認：\n- **收斂穩定性稽核**：隨機抽取幾個 $N = \\{100, 200, 500\\}$ 觀測價格波動是否在容許範圍內。\n- **算力邊界評估**：確認伺服器在執行萬次二元樹定價時的 IO 與內存壓力。\n- **誤差報告機制**：在提供估值報表時，標註所使用的步數參數及對應的理論誤差估計。",
      "5.6": "### 5.6 其他二元樹變體與擴展：應對複雜市場環境\n標準 CRR 二項樹雖然經典，但在處理含有股息、隨機利率或特定路障條件的衍生品時，其效率與精度往往不足。資深計量從業人員必須準備好一套「工具箱」，根據合約的奇異性 (Exotic nature) 選取最合適的樹狀變體。\n\n#### 專家決策矩陣：專業樹狀模型選型\n針對不同產品特徵，選取最優化路徑：\n\n| 市場環境 / 產品 | 首選模型 | 核心優勢 |\n| :--- | :--- | :--- |\n| **高發放率股息** | 調整後的離散股息樹 | 解決股息導致的資產路徑非重合問題 |\n| **利率衍生品 (Caps/Floors)** | BDT 樹或 Ho-Lee 樹 | 確保利率路徑符合當前期限結構且不為負 |\n| **極高精度需求** | Leisen-Reimer (LR) 樹 | 修正偏度與峰度，提昇 $d_1, d_2$ 的匹配度 |\n| **大量希臘字母計算** | 三元樹 (Trinomial Tree) | 節點更多，數值微分的穩定性顯著優於二元樹 |\n\n#### 技術核心：股息處理的資深對策\n處理分紅時，直接在每個股息發放日的節點將股價 $S$ 扣除紅利 $D$。這會導致二元樹「不重合」(Non-recombining)，使計算複雜度從 $O(N)$ 變為 $O(2^N)$。資深開發者的技術應對方案如下：\n\n$$\n  S_{total} = S_{risky} + S_{dividend\\_present\\_value}\n$$\n\n將股價分解為風險部分與確定的股息部分，使二元樹恢復重合性，保證計算效率。\n\n> [!TIP]\n> 在 Python 資深實作中（見 `B2_Ch5_7.py`），若標的具有連續股息率 $q$，我們透過將 $r$ 替換為 $r-q$ 來調整風險中性機率 $p$。這是處理股指期權、外匯期權的標準工業規格。\n\n#### 5.6 資深從業人員行動清單 (Action Items)\n執行進階定價前，必須確認：\n- **模型路徑連貫性測試**：檢查離散股息處理是否導致路徑斷裂或負值出現。\n- **參數動態更新**：確保利率樹模型已完全對齊目前的 OIS 或國債收益率曲線。\n- **算法複雜度審核**：識別是否存在計算爆炸路徑，必要時採用蒙地卡羅法替代高步數的非重合樹。"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "B2_Ch5_1",
        "filename": "B2_Ch5_1.py",
        "code": "# B2_Ch5_1.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef generic_payoff(buy_or_sell, put_call_indicator, strike, spot):\n    payoff = buy_or_sell*np.maximum(put_call_indicator*(spot - strike),0)\n    return payoff\n\ndef generic_pnl(buy_or_sell, put_call_indicator, strike, spot, premium):\n    pnl = buy_or_sell*np.maximum(put_call_indicator*(spot - strike),0) - buy_or_sell*premium\n    return pnl\n\ndef plot_decor(x, y, y_label):\n    plt.figure()\n    plt.plot(x, y)\n    plt.xlabel('S, spot price of underlying at expiration', fontsize=8)\n    plt.ylabel(y_label,fontsize=8) \n    plt.gca().set_aspect(1)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)\n    plt.gca().spines['left'].set_position(('data',0))\n    plt.gca().spines['bottom'].set_position(('data',0))\n\n    plt.axvline(x=strike, linestyle='--', color='r', linewidth = .5)\n\n    plt.xticks(np.arange(0, 200, step=20))\n    plt.yticks(np.arange(np.floor(np.min(pay_off)/10.0)*10.0, np.ceil(np.max(pay_off)/10.0)*10.0, step=20))\n    plt.grid(linestyle='--', axis='both', linewidth=0.25, color=[0.5,0.5,0.5])\n\nput_call_indicator = 1; \n# 1 for call; -1 for put\nbuy_or_sell = 1;\n# 1 for buy ;-1 for sell\nstrike = 100 \nspot = np.arange(0,200,1)\npremium = 10 \n\n# long a call\n\npay_off = generic_payoff(buy_or_sell,put_call_indicator,strike,spot)\ny_label = 'Payoff';\nplot_decor(spot, pay_off, y_label)\n\npnl = generic_pnl(buy_or_sell,put_call_indicator,strike,spot,premium)\ny_label = 'PnL';\nplot_decor(spot, pnl, y_label)\n\n# short a call\n\nput_call_indicator = 1; \nbuy_or_sell = -1;\npay_off = generic_payoff(buy_or_sell,put_call_indicator,strike,spot)\ny_label = 'Pay off';\nplot_decor(spot, pay_off, y_label)\n\npnl = generic_pnl(buy_or_sell,put_call_indicator,strike,spot,premium)\ny_label = 'PnL';\nplot_decor(spot, pnl, y_label)\n\n# long a put\n\nput_call_indicator = -1; \nbuy_or_sell = 1;\npay_off = generic_payoff(buy_or_sell,put_call_indicator,strike,spot)\ny_label = 'Pay off';\nplot_decor(spot, pay_off, y_label)\n\npnl = generic_pnl(buy_or_sell,put_call_indicator,strike,spot,premium)\ny_label = 'PnL';\nplot_decor(spot, pnl, y_label)\n\n# short a put\n\nput_call_indicator = -1; \nbuy_or_sell = -1;\npay_off = generic_payoff(buy_or_sell,put_call_indicator,strike,spot)\ny_label = 'Pay off';\nplot_decor(spot, pay_off, y_label)\n\npnl = generic_pnl(buy_or_sell,put_call_indicator,strike,spot,premium)\ny_label = 'PnL';\nplot_decor(spot, pnl, y_label)\n"
      },
      {
        "id": "ex2",
        "title": "B2_Ch5_2",
        "filename": "B2_Ch5_2.py",
        "code": "# B2_Ch5_2.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.special\n\ndef Binomialtree(n, S0, K, r, vol, t, PutCall, EuropeanAmerican):  \n    deltaT = t/n \n    u = np.exp(vol*np.sqrt(deltaT))\n    d = 1./u\n    p = (np.exp(r*deltaT)-d) / (u-d) \n \n    #Binomial tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]     \n    \n    scatter_x_stock = [0.0]\n    scatter_y_stock = [stockvalue[0,0]]\n    scatter_prob_stock = [1.0]\n       \n    plt.figure(1)\n    \n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            \n            x_stock_tree_u = [(i-1)*deltaT]\n            x_stock_tree_d = [(i-1)*deltaT]\n            y_stock_tree_upper = [stockvalue[i-1,j-1]]\n            y_stock_tree_lower = [stockvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT                  \n            y_temp1 = stockvalue[i,j-1]\n            y_temp3 = stockvalue[i,j]\n            \n            x_stock_tree_u.append(x_temp)\n            x_stock_tree_d.append(x_temp)\n            scatter_x_stock.append(i*deltaT)\n                        \n            y_stock_tree_lower.append(y_temp1)\n            y_stock_tree_upper.append(y_temp3)\n            scatter_y_stock.append(stockvalue[i,j-1])\n            \n            temp_prob = scipy.special.comb(i, j - 1, exact=True)*p**(j - 1)*(1 - p)**(i-j+1)\n            scatter_prob_stock.append(temp_prob)\n                       \n            plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'b-',linewidth=0.4)\n            plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'b-',linewidth=0.4)\n            \n      \n        temp_prob = scipy.special.comb(i, j, exact=True)*p**(j)*(1 - p)**(i-j)\n        scatter_prob_stock.append(temp_prob)    \n        scatter_x_stock.append(i*deltaT)\n        scatter_y_stock.append(stockvalue[i,j])\n    \n    colors = scatter_prob_stock\n    plt.scatter(np.array(scatter_x_stock),np.array(scatter_y_stock),c=colors,alpha=0.5,cmap ='RdBu_r')\n    plt.xlabel('Time (year)',fontsize=8)\n    plt.ylabel('Underlying price',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)\n    plt.colorbar()\n\n    plt.figure(2)\n    plt.stem(scatter_y_stock[len(scatter_y_stock)-n-1::],scatter_prob_stock[len(scatter_y_stock)-n-1::])\n    plt.xlabel('Underlying price, T = 1 year',fontsize=8)\n    plt.ylabel('Prob',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)\n           \n    return optionvalue[0,0]\n\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nK = 55   #strike price\nvol = 0.3 #volatility\n\nt = 1.0\ny = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"European\")\n"
      },
      {
        "id": "ex3",
        "title": "B2_Ch5_3",
        "filename": "B2_Ch5_3.py",
        "code": "# B2_Ch5_3.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.special\n\ndef Binomialtree(n, S0, K, r, vol, t, PutCall, EuropeanAmerican):  \n    deltaT = t/n \n    u = np.exp(vol*np.sqrt(deltaT))\n    d = 1./u\n    p = (np.exp(r*deltaT)-d) / (u-d) \n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]        \n    \n    scatter_x_option = [0.0]\n    scatter_y_option = [optionvalue[0,0]]\n    scatter_prob_option = [1.0]             \n            \n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            x_option_tree_u = [(i-1)*deltaT]\n            x_option_tree_d = [(i-1)*deltaT]\n            y_option_tree_upper = [optionvalue[i-1,j-1]]\n            y_option_tree_lower = [optionvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT\n            \n            y_temp1 = optionvalue[i,j-1]\n            y_temp3 = optionvalue[i,j]\n            \n            x_option_tree_u.append(x_temp)\n            x_option_tree_d.append(x_temp)\n            scatter_x_option.append(i*deltaT)\n                        \n            y_option_tree_upper.append(y_temp1)\n            y_option_tree_lower.append(y_temp3)\n            scatter_y_option.append(optionvalue[i,j-1])\n            temp_prob = scipy.special.comb(i, j - 1, exact=True)*p**(j - 1)*(1 - p)**(i-j+1)\n\n            scatter_prob_option.append(temp_prob) \n        \n        temp_prob = scipy.special.comb(i, j, exact=True)*p**(j)*(1 - p)**(i-j)\n        scatter_prob_option.append(temp_prob)    \n        scatter_x_option.append(i*deltaT)\n        scatter_y_option.append(optionvalue[i,j])\n    \n    option_T_level = np.array(scatter_y_option[len(scatter_y_option)-n-1::])\n    option_T_prob = scatter_prob_option[len(scatter_y_option)-n-1::]\n    a1, c1 = np.unique(option_T_level, return_inverse=True)\n    A1 = np.bincount(c1,option_T_prob)\n    \n    plt.figure()\n    plt.stem(a1, A1)\n    plt.xlabel('Option price, T = 1 year',fontsize=8)\n    plt.ylabel('Prob',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)\n           \n    return optionvalue[0,0]\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nK = 55   #strike price\nvol = 0.3 #volatility\n\nt = 1.0\ny = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"European\")\n"
      },
      {
        "id": "ex4",
        "title": "B2_Ch5_4",
        "filename": "B2_Ch5_4.py",
        "code": "# B2_Ch5_4.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.special\n\ndef Binomialtree(n, S0, K, r, vol, t, PutCall, EuropeanAmerican):  \n    deltaT = t/n \n    u = np.exp(vol*np.sqrt(deltaT))\n    d = 1./u\n    p = (np.exp(r*deltaT)-d) / (u-d) \n    \n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]     \n       \n    scatter_x_option = [0.0]\n    scatter_y_option = [optionvalue[0,0]]\n    scatter_prob_option = [1.0]     \n    plt.figure()        \n            \n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            x_option_tree_u = [(i-1)*deltaT]\n            x_option_tree_d = [(i-1)*deltaT]\n            y_option_tree_upper = [optionvalue[i-1,j-1]]\n            y_option_tree_lower = [optionvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT\n            \n            y_temp1 = optionvalue[i,j-1]\n            y_temp3 = optionvalue[i,j]\n            \n            x_option_tree_u.append(x_temp)\n            x_option_tree_d.append(x_temp)\n            scatter_x_option.append(i*deltaT)\n                        \n            y_option_tree_upper.append(y_temp1)\n            y_option_tree_lower.append(y_temp3)\n            scatter_y_option.append(optionvalue[i,j-1])\n            temp_prob = scipy.special.comb(i, j - 1, exact=True)*p**(j - 1)*(1 - p)**(i-j+1)\n\n            scatter_prob_option.append(temp_prob)\n            \n            plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'b-',linewidth=0.5)\n            plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'b-',linewidth=0.5)\n        \n        temp_prob = scipy.special.comb(i, j, exact=True)*p**(j)*(1 - p)**(i-j)\n        scatter_prob_option.append(temp_prob)    \n        scatter_x_option.append(i*deltaT)\n        scatter_y_option.append(optionvalue[i,j])\n    \n    colors = scatter_prob_option\n    plt.scatter(np.array(scatter_x_option),np.array(scatter_y_option),c=colors,alpha=0.5,cmap ='RdBu_r') \n    plt.xlabel('Time (year)',fontsize=8)\n    if  PutCall==\"Put\":\n        plt.ylabel('Put option price',fontsize=8)\n    else: \n        plt.ylabel('Call option price',fontsize=8)\n        \n    # plt.gca().set_aspect(1)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)\n    plt.colorbar()\n           \n    return optionvalue[0,0]\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nK = 55   #strike price\nvol = 0.3 #volatility\nt = 1.0\ny = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"American\")\ny = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Put\", EuropeanAmerican=\"American\")"
      },
      {
        "id": "ex5",
        "title": "B2_Ch5_5",
        "filename": "B2_Ch5_5.py",
        "code": "# B2_Ch5_5.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef Binomialtree(n, S0, K, r, q, vol, t, PutCall, EuropeanAmerican):  \n    deltaT = t/n \n    u = np.exp(vol*np.sqrt(deltaT))\n    d = 1./u\n    p = (np.exp((r-q)*deltaT)-d) / (u-d) \n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]\n        \n    return optionvalue[0,0]    \n\ndef option_analytical(S0, vol, r, q, t, K, PutCall):\n    d1 = (np.log(S0 / K) + (r - q + 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    d2 = (np.log(S0 / K) + (r - q - 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    \n    price =  PutCall*S0 * np.exp(-q * t) * norm.cdf(PutCall*d1, 0.0, 1.0) - PutCall* K * np.exp(-r * t) * norm.cdf(PutCall*d2, 0.0, 1.0)  \n        \n    return price\n\n    # Inputs\nn= 2   #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.03  #risk-free interest rate\nq = 0.0 # dividend yield\nK = 55   #strike price\nvol = 0.3 #volatility\nt = 2.0\nPutCall = 1 # 1 for call;-1 for put\n\nbs_price = option_analytical(S0, vol, r, q, t, K, PutCall=1)\nprint('analytical Price: %.4f' % bs_price)\n\nn= range(2, 1012, 10)\nprices = np.array([Binomialtree(x, S0, K, r, q, vol, t, PutCall=\"Call\", EuropeanAmerican=\"European\") for x in n])\ndiscrepancy = (prices/bs_price -1)/0.01 \n\nplt.figure()\nplt.plot(n, prices,\"-o\",markersize = 2)\nplt.plot([0,1012],[bs_price, bs_price], \"r-\", lw=2, alpha=0.6)\nplt.xlabel(\"Number of steps\")\nplt.ylabel(\"Call option price, C (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.figure()\nplt.plot(n, discrepancy,\"-o\",markersize = 2)\nplt.xlabel(\"Number of steps\")\nplt.ylabel(\"Discrepancy (%)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nbs_price = option_analytical(S0, vol, r, q, t, K, PutCall=-1)\nprint('analytical Price: %.4f' % bs_price)\n\nn= range(2, 1012, 10)\nprices = np.array([Binomialtree(x, S0, K, r, q, vol, t, PutCall=\"Put\", EuropeanAmerican=\"European\") for x in n])\ndiscrepancy = (prices/bs_price -1)/0.01 \n\nplt.figure()\nplt.plot(n, prices,\"-o\",markersize = 2)\nplt.plot([0,1012],[bs_price, bs_price], \"r-\", lw=2, alpha=0.6)\nplt.xlabel(\"Number of steps\")\nplt.ylabel(\"Put option price, C (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.figure()\nplt.plot(n, discrepancy,\"-o\",markersize = 2)\nplt.xlabel(\"Number of steps\")\nplt.ylabel(\"Discrepancy (%)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)"
      },
      {
        "id": "ex6",
        "title": "B2_Ch5_6",
        "filename": "B2_Ch5_6.py",
        "code": "# B2_Ch5_6.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef Binomialtree(n, S0, K, r, vol, t, PutCall, EuropeanAmerican,Tree):  \n    deltaT = t/n \n    if Tree == 'CRR':\n        u = np.exp(vol*np.sqrt(deltaT))\n        d = 1./u\n        p = (np.exp(r*deltaT)-d) / (u-d) \n    elif Tree == 'JD':\n        u = np.exp((r - vol**2*0.5)*deltaT + vol*np.sqrt(deltaT))\n        d = np.exp((r - vol**2*0.5)*deltaT - vol*np.sqrt(deltaT))\n        p = 0.5  \n    elif Tree =='LR':\n        def  h_function(z,n):\n            h = 0.5+np.sign(z)*np.sqrt(0.25-0.25*np.exp(-((z/(n+1/3+0.1/(n+1)))**2)*(n+1/6)))\n            return h\n        \n        if np.mod(n,2)>0:\n            n_bar = n\n        else:\n            n_bar = n + 1\n        \n        d1 = (np.log(S0/K)+(r+vol**2/2)*t)/vol/np.sqrt(t);\n        d2 = (np.log(S0/K)+(r-vol**2/2)*t)/vol/np.sqrt(t);\n        pbar = h_function(d1,n_bar)\n        p = h_function(d2,n_bar)\n        u = np.exp(r*deltaT)*pbar/p\n        d = (np.exp(r*deltaT)-p*u)/(1-p)  \n            \n    else:\n        print(\"Tree type not supported\")\n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]     \n    \n    scatter_x_stock = [0.0]\n    scatter_y_stock = [stockvalue[0,0]]\n    \n    plt.figure(1)\n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            \n            x_stock_tree_u = [(i-1)*deltaT]\n            x_stock_tree_d = [(i-1)*deltaT]\n            y_stock_tree_upper = [stockvalue[i-1,j-1]]\n            y_stock_tree_lower = [stockvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT \n            y_temp1 = stockvalue[i,j-1]\n            y_temp3 = stockvalue[i,j]\n            \n            x_stock_tree_u.append(x_temp)\n            x_stock_tree_d.append(x_temp)\n            scatter_x_stock.append(i*deltaT)\n                        \n            y_stock_tree_lower.append(y_temp1)\n            y_stock_tree_upper.append(y_temp3)\n            scatter_y_stock.append(stockvalue[i,j-1])\n                      \n            if Tree == 'CRR':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'b-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'b-o',linewidth=0.4,markersize = 2)\n            elif Tree == 'JD':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'r-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'r-o',linewidth=0.4,markersize = 2)\n            elif Tree == 'LR':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'r-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'r-o',linewidth=0.4,markersize = 2)    \n            else:\n                print(\"Tree type not supported\")  \n    \n    plt.xlabel('Time (year)',fontsize=8)\n    plt.ylabel('Underlying price',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)    \n\n    plt.figure(2)\n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            x_option_tree_u = [(i-1)*deltaT]\n            x_option_tree_d = [(i-1)*deltaT]\n            y_option_tree_upper = [optionvalue[i-1,j-1]]\n            y_option_tree_lower = [optionvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT\n            \n            y_temp1 = optionvalue[i,j-1]\n            y_temp3 = optionvalue[i,j]\n            \n            x_option_tree_u.append(x_temp)\n            x_option_tree_d.append(x_temp)\n                             \n            y_option_tree_upper.append(y_temp1)\n            y_option_tree_lower.append(y_temp3)\n            \n            if Tree == 'CRR':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'b-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'b-o',linewidth=0.5,markersize = 2)\n            elif Tree == 'JD':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'r-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'r-o',linewidth=0.5,markersize = 2)\n            elif Tree == 'LR':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'r-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'r-o',linewidth=0.5,markersize = 2)    \n            else:\n                print(\"Tree type not supported\") \n    \n    plt.xlabel('Time (year)',fontsize=8)\n    if PutCall==\"Put\":\n        plt.ylabel('Put option price',fontsize=8)    \n    else:\n        plt.ylabel('Call option price',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)             \n           \n    return optionvalue[0,0]\n\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nK = 55   #strike price\nvol = 0.3 #volatility\nt = 1.0\n\ny1 = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"American\",Tree = 'CRR')\ny2 = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"American\",Tree = 'JD')\n"
      },
      {
        "id": "ex7",
        "title": "B2_Ch5_7",
        "filename": "B2_Ch5_7.py",
        "code": "# B2_Ch5_7.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef Binomialtree(n, S0, K, r, vol, t, PutCall, EuropeanAmerican,Tree):  \n    deltaT = t/n \n    if Tree == 'CRR':\n        u = np.exp(vol*np.sqrt(deltaT))\n        d = 1./u\n        p = (np.exp(r*deltaT)-d) / (u-d) \n    elif Tree == 'JD':\n        u = np.exp((r - vol**2*0.5)*deltaT + vol*np.sqrt(deltaT))\n        d = np.exp((r - vol**2*0.5)*deltaT - vol*np.sqrt(deltaT))\n        p = 0.5  \n    elif Tree =='LR':\n        def  h_function(z,n):\n            h = 0.5+np.sign(z)*np.sqrt(0.25-0.25*np.exp(-((z/(n+1/3+0.1/(n+1)))**2)*(n+1/6)))\n            return h\n        \n        if np.mod(n,2)>0:\n            n_bar = n\n        else:\n            n_bar = n + 1\n        \n        d1 = (np.log(S0/K)+(r+vol**2/2)*t)/vol/np.sqrt(t);\n        d2 = (np.log(S0/K)+(r-vol**2/2)*t)/vol/np.sqrt(t);\n        pbar = h_function(d1,n_bar)\n        p = h_function(d2,n_bar)\n        u = np.exp(r*deltaT)*pbar/p\n        d = (np.exp(r*deltaT)-p*u)/(1-p)  \n            \n    else:\n        print(\"Tree type not supported\")\n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]     \n    \n    scatter_x_stock = [0.0]\n    scatter_y_stock = [stockvalue[0,0]]\n    \n    plt.figure(1)\n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            \n            x_stock_tree_u = [(i-1)*deltaT]\n            x_stock_tree_d = [(i-1)*deltaT]\n            y_stock_tree_upper = [stockvalue[i-1,j-1]]\n            y_stock_tree_lower = [stockvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT \n            y_temp1 = stockvalue[i,j-1]\n            y_temp3 = stockvalue[i,j]\n            \n            x_stock_tree_u.append(x_temp)\n            x_stock_tree_d.append(x_temp)\n            scatter_x_stock.append(i*deltaT)\n                        \n            y_stock_tree_lower.append(y_temp1)\n            y_stock_tree_upper.append(y_temp3)\n            scatter_y_stock.append(stockvalue[i,j-1])\n                      \n            if Tree == 'CRR':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'b-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'b-o',linewidth=0.4,markersize = 2)\n            elif Tree == 'JD':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'r-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'r-o',linewidth=0.4,markersize = 2)\n            elif Tree == 'LR':\n                plt.plot(np.array(x_stock_tree_u), np.array(y_stock_tree_upper),'r-o',linewidth=0.4,markersize = 2)\n                plt.plot(np.array(x_stock_tree_d), np.array(y_stock_tree_lower),'r-o',linewidth=0.4,markersize = 2)    \n            else:\n                print(\"Tree type not supported\")  \n    \n    plt.xlabel('Time (year)',fontsize=8)\n    plt.ylabel('Underlying price',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)    \n\n    plt.figure(2)\n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            x_option_tree_u = [(i-1)*deltaT]\n            x_option_tree_d = [(i-1)*deltaT]\n            y_option_tree_upper = [optionvalue[i-1,j-1]]\n            y_option_tree_lower = [optionvalue[i-1,j-1]]\n                         \n            x_temp = i*deltaT\n            \n            y_temp1 = optionvalue[i,j-1]\n            y_temp3 = optionvalue[i,j]\n            \n            x_option_tree_u.append(x_temp)\n            x_option_tree_d.append(x_temp)\n                             \n            y_option_tree_upper.append(y_temp1)\n            y_option_tree_lower.append(y_temp3)\n            \n            if Tree == 'CRR':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'b-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'b-o',linewidth=0.5,markersize = 2)\n            elif Tree == 'JD':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'r-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'r-o',linewidth=0.5,markersize = 2)\n            elif Tree == 'LR':\n                plt.plot(np.array(x_option_tree_u), np.array(y_option_tree_upper),'r-o',linewidth=0.5,markersize = 2)\n                plt.plot(np.array(x_option_tree_d), np.array(y_option_tree_lower),'r-o',linewidth=0.5,markersize = 2)    \n            else:\n                print(\"Tree type not supported\") \n    \n    plt.xlabel('Time (year)',fontsize=8)\n    if PutCall==\"Put\":\n        plt.ylabel('Put option price',fontsize=8)    \n    else:\n        plt.ylabel('Call option price',fontsize=8)\n    plt.gca().spines['right'].set_visible(False)\n    plt.gca().spines['top'].set_visible(False)             \n           \n    return optionvalue[0,0]\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nK = 55   #strike price\nvol = 0.3 #volatility\nt = 1.0\n\ny1 = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"American\",Tree = 'CRR')\ny2 = Binomialtree(n, S0, K, r, vol, t, PutCall=\"Call\", EuropeanAmerican=\"American\",Tree = 'LR')"
      },
      {
        "id": "ex8",
        "title": "B2_Ch5_8",
        "filename": "B2_Ch5_8.py",
        "code": "# B2_Ch5_8.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\ndef option_analytical(S0, vol, r, q, t, K, PutCall):\n    d1 = (np.log(S0 / K) + (r - q + 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    d2 = (np.log(S0 / K) + (r - q - 0.5 * vol ** 2) * t) / (vol * np.sqrt(t))\n    price =  PutCall*S0 * np.exp(-q * t) * norm.cdf(PutCall*d1, 0.0, 1.0) - PutCall* K * np.exp(-r * t) * norm.cdf(PutCall*d2, 0.0, 1.0)  \n        \n    return price\n\n\ndef Binomialtree(n, S0, K, r, q, vol, t, PutCall, EuropeanAmerican,Tree):  \n    deltaT = t/n \n    if Tree == 'CRR':\n        u = np.exp(vol*np.sqrt(deltaT))\n        d = 1./u\n        p = (np.exp((r - q)*deltaT)-d) / (u-d) \n    elif Tree == 'JD':\n        u = np.exp((r - q - vol**2*0.5)*deltaT + vol*np.sqrt(deltaT))\n        d = np.exp((r - q - vol**2*0.5)*deltaT - vol*np.sqrt(deltaT))\n        p = 0.5  \n    elif Tree =='LR':\n        def  h_function(z,n):\n            h = 0.5+np.sign(z)*np.sqrt(0.25-0.25*np.exp(-((z/(n+1/3+0.1/(n+1)))**2)*(n+1/6)))\n            return h\n        \n        if np.mod(n,2)>0:\n            n_bar = n\n        else:\n            n_bar = n + 1\n        \n        d1 = (np.log(S0/K)+(r-q+vol**2/2)*t)/vol/np.sqrt(t);\n        d2 = (np.log(S0/K)+(r-q-vol**2/2)*t)/vol/np.sqrt(t);\n        pbar = h_function(d1,n_bar)\n        p = h_function(d2,n_bar)\n        u = np.exp((r-q)*deltaT)*pbar/p\n        d = (np.exp((r-q)*deltaT)-p*u)/(1-p)    \n            \n    else:\n        print(\"Tree type not supported\")\n    #Binomial price tree\n    stockvalue = np.zeros((n+1,n+1))\n    stockvalue[0,0] = S0\n    for i in range(1,n+1):\n        stockvalue[i,0] = stockvalue[i-1,0]*u\n        for j in range(1,i+1):\n            stockvalue[i,j] = stockvalue[i-1,j-1]*d\n\n    #option value at final node   \n    optionvalue = np.zeros((n+1,n+1))\n    for j in range(n+1):\n        if PutCall==\"Call\": # Call\n            optionvalue[n,j] = max(0, stockvalue[n,j]-K)\n        elif PutCall==\"Put\": #Put\n            optionvalue[n,j] = max(0, K-stockvalue[n,j])\n    if deltaT != 0: \n    #backward calculation for option price    \n        for i in range(n-1,-1,-1):\n            for j in range(i+1):\n                if EuropeanAmerican==\"American\":\n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, K-stockvalue[i,j], np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, stockvalue[i,j]-K, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                elif EuropeanAmerican==\"European\":    \n                    if PutCall==\"Put\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    elif PutCall==\"Call\":\n                        optionvalue[i,j] = max(0, np.exp(-r*deltaT)*(p*optionvalue[i+1,j]+(1-p)*optionvalue[i+1,j+1]))\n                    else:\n                        print(\"PutCall type not supported\")\n                else:\n                    print(\"Excercise type not supported\")\n    else:\n        optionvalue[0,0] = optionvalue[n,j]     \n                    \n    return optionvalue[0,0]\n\n    # Inputs\nn = 20    #number of steps\nS0 = 50  #initial underlying asset price\nr = 0.01  #risk-free interest rate\nq = 0.0 #dividend yield\nK = 55   #strike price\nvol = 0.3 #volatility\nt = 1.0\n\nbs_price = option_analytical(S0, vol, r, q, t, K, PutCall=1)\nprint('analytical Price: %.4f' % bs_price)\n\nn= range(5, 300, 1)\nprices_crr = np.array([Binomialtree(x, S0, K, r, q, vol, t, PutCall=\"Call\", EuropeanAmerican=\"European\",Tree = 'CRR') for x in n])\ndiscrepancy_crr = (prices_crr/bs_price -1)/0.01 \n\nplt.figure()\nplt.plot(n, prices_crr,\"b-\",label='CRR',lw = 1)\n\nplt.plot([5,300],[bs_price, bs_price], \"r-\", label='BSM',lw=1, alpha=0.6)\nplt.xlabel(\"Number of steps\")\nplt.ylabel(\"Call option price, C (USD)\")\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nn= range(5, 300, 2)\nprices_lr = np.array([Binomialtree(x, S0, K, r, q, vol, t, PutCall=\"Call\", EuropeanAmerican=\"European\",Tree = 'LR') for x in n])\ndiscrepancy_lr = (prices_lr/bs_price -1)/0.01 \n\nplt.plot(n, prices_lr,\"k-\", label='LR',lw = 1)\nplt.legend(loc='upper center')\n"
      }
    ]
  }
}