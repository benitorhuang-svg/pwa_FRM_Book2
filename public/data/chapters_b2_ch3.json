{
  "id": "b2_ch3",
  "title": "第3章：蒙地卡羅模擬",
  "number": 3,
  "content": {
    "intro": {
      "title": "第 3 章：蒙地卡羅模擬 - 重點詳解 (Detail)",
      "roadmap": {
        "guide": "蒙地卡羅模擬（Monte Carlo Simulation）是處理複雜金融衍生品定價與風險评估的核心武器。當模型不存在封閉式表達（Closed-form Solution）時，透過生成大量隨機樣本並計算其期望值，我們可以解決高維度的定價問題。",
        "objectives": "*   理解大數法則（Law of Large Numbers）與中央極限定理（CLT）如何支撐蒙地卡羅結果的收斂性。\n*   學會如何將獨立的正態分佈隨機數轉換為具有特定相關性的多資產收益率。\n*   掌握亞式選擇權的平均價格（均值）計算邏輯及其在強路徑相依產品中的應用。",
        "topics": "*   3.1 蒙地卡羅基本思想\n*   3.2 定積分數值求解\n*   3.3 估算圓周率 ($\\pi$)\n*   3.4 股價路徑模擬\n*   3.5 Cholesky 分解與相關性\n*   3.6 歐式選擇權定價\n*   3.7 亞式選擇權與路徑相依\n*   3.8 MCMC 抽樣理論"
      },
      "value": {
        "practical": "*   **實務場景**：計算結構型商品（如鳳凰票據、障礙期權）的公平價值。\n*   **考試重點**：理解蒙地卡羅誤差的標準差與模擬次數 $N$ 的關係（$\\sigma_{\\text{error}} \\propto 1/\\sqrt{N}$）。",
        "theory": "蒙地卡羅的核心是將積分問題轉化為積分域內的取樣問題。在多資產風險評估中，透過 Cholesky 分解 $L = \\text{Cholesky}(R)$ 得到相關隨機數 $X = L \\epsilon$。",
        "further_reading": "*   Glasserman (2003) Monte Carlo Methods in Financial Engineering."
      },
      "implementation": {
        "python": "*   **向量化優化**：使用 NumPy 矩陣運算一次性產生所有隨機步，大幅提升模擬效率。\n*   **相關性處理**：實作 `np.linalg.cholesky` 並分析資產分散效果。\n*   **MCMC 抽樣**：實作 Metropolis-Hastings 算法，求解複雜分佈期望值。",
        "logic": "*   路徑平均價格：`Asian_Payoff = np.mean(price_path) - Strike`。\n*   Cholesky 分解：將獨立隨機數轉換為相關隨機數。",
        "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B2_Ch3_1.py** | 實作基礎數值積分，演示隨機模擬與視覺化。 |\n| **B2_Ch3_2.py** | **[核心]** 實作定積分的蒙地卡羅估算，分析收斂精度。 |\n| **B2_Ch3_3.py** | 演示隨機數生成在估算機率分佈中的應用。 |\n| **B2_Ch3_4.py** | **[核心]** 利用 Cholesky 分解實作具有相關性的多資產路徑模擬。 |\n| **B2_Ch3_5.py** | 使用 Seaborn 統計圖表展示模擬路徑的分佈邊界。 |\n| **B2_Ch3_6.py** | 實作 SciPy 在風險計量模型中的進階應用與參數評估。 |\n| **B2_Ch3_7.py** | 演示歐式選擇權的多路徑定價與預測分布. |\n| **B2_Ch3_8.py** | 視覺化路徑模擬結果，分析不同波動率水平下的收斂特徵。 |\n| **B2_Ch3_9.py** | **[核心]** 定義亞式選擇權定價函數，實作路徑平均價格計算。 |\n| **B2_Ch3_10.py** | 實作 MCMC (Metropolis-Hastings) 抽樣，求解複雜的分佈期望值。 |"
      }
    },
    "body": {
      "3.1": "### 3.1 蒙地卡羅模擬 (Monte Carlo Simulation)：隨機取樣的暴力美學\n蒙地卡羅模擬是處理複雜金融衍生品定價與風險評估的終極武器。當模型不存在封閉式解析解（Closed-form Solution）時，我們透過生成大量隨機樣本並計算其期望值來獲取數值解。其核心理論支柱是**大數法則 (Law of Large Numbers)**。\n\n#### 專家決策矩陣：蒙地卡羅 vs. 其他數值方法\n資深計量人員必須識別蒙地卡羅在高維問題上的絕對優勢：\n\n| 特度維度 | 蒙地卡羅模擬 (MC) | 格點法 / 有限差分法 |\n| :--- | :--- | :--- |\n| **維度災難** | **免疫**：收斂速度 $O(1/\\sqrt{N})$ 與維度無關 | **敏感**：計算成本隨維度呈指數級爆炸 |\n| **路徑相依性** | 完美支援（如亞式、回顧期權） | 處理困難，需增加額外狀態變量 |\n| **複雜獲利結構** | 支援任何非連續或非線性獲利 | 需對邊界條件進行精細處理 |\n| **計算效率** | 需要大量路徑以降低估計誤差 | 對低維問題具備更高的精準度與速度 |\n\n#### 技術核心：收斂速度與大數法則\n我們透過計算 $N$ 條獨立同分佈路徑的平均收益，來估計真實的期望價值：\n\n$$\n  \\hat{V} = e^{-rT} \\frac{1}{N} \\sum_{i=1}^N \\text{Payoff}_i\n$$\n\n> [!IMPORTANT]\n> 在生產端實作中，模擬次數 $N$ 的選擇必須在「計算精度」與「執行延遲」之間取得平衡。蒙地卡羅的誤差隨 $\\sqrt{N}$ 遞減；若要將誤差減半，則必須將模擬次數提高 **4 倍**。資深分析師必須根據 VaR 的置信區間要求來動態調整取樣規模。\n\n#### 3.1 資深從業人員行動清單 (Action Items)\n啟動蒙地卡羅引擎前，必須確認：\n- **收斂性分析**：監控估算值的標準差 $\\hat{\\sigma}_{MC} = \\sigma / \\sqrt{N}$，確保誤差在容許範圍內。\n- **變異數縮減技術**：考慮引入對偶變量法 (Antithetic Variates) 或控制變量法，以在不增加 $N$ 的情況下提升精度。\n- **計算資源審視**：對於多路徑模擬，優先採用 NumPy 向量化運算，禁止使用 Python 原生迴圈。",
      "3.2": "### 3.2 定積分數值求解：將解析問題轉化為抽樣任務\n在風險計量中，許多預期損失（Expected Shortfall）或期權定價公式本質上是高維空間的定積分。蒙地卡羅法將積分問題轉化為在定義域內計算「函數平均高度」的問題。這在處理無解析解的複雜收益函數時極具威裝。\n\n#### 技術核心：隨機取樣積分法\n對於區間 $[a, b]$ 上的定積分 $\\int_a^b f(x) dx$，我們透過在該區間內產生均勻分佈隨機數 $x_i \\sim U(a, b)$ 來進行數值估算：\n\n$$\n  I \\approx (b - a) \\cdot \\frac{1}{N} \\sum_{i=1}^N f(x_i)\n$$\n\n#### 決策矩陣：數值積分演算法選型\n資深分析師需根據函數特性選擇最優算法：\n\n| 特性 | 蒙地卡羅積分 (MC) | 辛普森法 (Simpson's Rule) |\n| :--- | :--- | :--- |\n| **維度連鎖** | 支援極高維度 ($d > 3$) | 僅適用於低維連續函數 ($d \\le 2$) |\n| **誤差特徵** | 隨機性誤差，不穩定但收斂 | 系統性誤差，對平滑函數極其精準 |\n| **靈活性** | 可處理非連續或劇烈波助的函數 | 要求函數具備較高的階數連續性 |\n\n> [!IMPORTANT]\n> 在 **Python** 實作中（見 `B2_Ch3_2.py`），使用 `np.random.uniform` 生成大規模樣本點是構建數值積分器的標準起手式。資深開發者必須隨時檢查被積函數在邊界處是否存在奇異性 (Singularity)，這會導致蒙地卡羅估計值的方差發散。\n\n#### 3.2 資深從業人員行動清單 (Action Items)\n執行數值積分前，必須落實：\n- **定義域完整性校驗**：確保隨機抽樣範圍完整覆蓋積分區間，無邏輯死角。\n- **取樣密度評估**：針對振盪劇烈的函數，必須大幅提高取樣頻率或採用重要性抽樣 (Importance Sampling)。\n- **精度一致性測試**：透過與小規模解析近似解（若存在）進行比對，驗證數值積分器的基礎合法性。\n\n#### 核心技術結論\n蒙地卡羅積分是將「微積分問題」轉化為「統計問題」的關鍵步驟。它證明了對於現代風險管理而言，「抽樣」是比「求解」更具擴展性的生存策略。",
      "3.3": "### 3.3 估算圓周率 ($\\pi$)：幾何機率與蒙地卡羅驗證\n估算 $\\pi$ 值是理解幾何蒙地卡羅（Geometric MC）最直觀的實驗案列。它揭示了如何透過簡單的「點選計數」來獲取數學常數，進而體現了幾何區域與機率分佈之間的內在關聯。\n\n#### 專家定義：單位圓投射實驗\n考慮一個邊長為 2 的正方形（面積 $A_{sq} = 4$）及其內切單位圓（面積 $A_{cir} = \\pi$）。若我們在正方形內均勻投點，點落入圓內的機率為：\n\n$$\n  P(\\text{in circle}) = \\frac{A_{cir}}{A_{sq}} = \\frac{\\pi}{4}\n$$\n\n#### 技術標準：算法轉化\n透過大數法則，我們將圓周率的估計轉化為落入圓內點數 $N_{in}$ 與總點數 $N_{total}$ 的比例：\n\n$$\n  \\pi \\approx 4 \\times \\frac{N_{in}}{N_{total}}\n$$\n\n#### 決策矩陣：幾何蒙地卡羅的誤差來源\n資深計量人員必須識別影響精度的關鍵因素：\n\n| 影響因素 | 表現特徵 | 優化對策 |\n| :--- | :--- | :--- |\n| **樣本規模 ($N$)** | 誤差隨 $1/\\sqrt{N}$ 遞減 | 增加樣本數，或使用並行計算優化 |\n| **隨機生成器質量** | 若隨機數分佈不均，會導致區域權重偏差 | 採用 Sobol 序列等低偏誤序列 (Quasi-MC) |\n| **浮點運算精度** | 在判斷 $x^2 + y^2 \\le 1$ 時可能存在計算精度溢位 | 統一使用高精度 `np.float64` 進行座標判斷 |\n\n> [!TIP]\n> 在 **Matplotlib** 視覺化中（見 `B2_Ch3_1.py`），資深分析師會同步繪製散點圖。若發現點的分布呈現條紋狀或聚簇現象，代表隨機數生成器的維度相關性過高，必須立即更換偽隨機數生成算法 (PRNG)。\n\n#### 3.3 資深從業人員行動清單 (Action Items)\n執行幾何估計前，必須確認：\n- **邊界判定邏輯**：嚴格執行歐幾里得距離公式判定，確保圓周上的點不被重複計算或遺漏。\n- **隨機性校驗**：對生成座標進行均勻性檢定 (Chi-Square Test)，確保在各個象限的投點機率一致。\n- **結果置信度**：計算多次實驗的標準誤差，給出 $\\pi$ 估值的置信區間，而非單一數值。",
      "3.4": "### 3.4 股價路徑模擬 (Price Path Simulation)：平行時空的投射\n在蒙地卡羅框架下，股價並非單一演化線段，而是無數可能路徑的集合。利用幾何布朗運動 (GBM) 的離散化形式，我們可以模擬出資產價格在未來時間軸上的分佈形態，這是計算路徑相依選擇權（如障礙期權）與預期敞口的物理基礎。\n\n#### 技術核心：GBM 離散迭代公式\n我們將時間區間 $T$ 切分為 $M$ 個微小步長 $\\Delta t = T/M$。根據解析解，資產價格在每一步的演化如下：\n\n$$\n  S_{t+\\Delta t} = S_t \\exp\\left( \\left( r - \\frac{1}{2}\\sigma^2 \\right)\\Delta t + \\sigma \\sqrt{\\Delta t} Z \\right)\n$$\n\n- **隨種子 $Z$**：必須服從標準正態分佈 $N(0, 1)$。每一期模擬必須保證 $Z$ 的獨立性。\n\n#### 決策矩陣：數值模擬方案選型\n資深分析師需在計算效率與理論精度間做出決策：\n\n| 方案 | 特點 | 適用場景 |\n| :--- | :--- | :--- |\n| **對數迭代 (Exact)** | 基於解析解，即使 $\\Delta t$ 較大也無系統誤差 | 歐式、亞式等大多數期權模擬 |\n| **歐拉近似 (Euler)** | $S_{t+1} = S_t(1 + r \\Delta t + \\sigma \\sqrt{\\Delta t} Z)$，簡單但有偏 | 當 SDE 非常複雜且無解析解時 |\n| **向量化矩陣法** | 使用 `np.cumsum` 一次性生成整條路徑 | **資深開發首選**：極大化執行效能 |\n\n> [!IMPORTANT]\n> 在生產端部署時（見 `B2_Ch3_4.py`），應預先生成所有步長的隨機矩陣 $\\mathbf{Z}_{N \\times M}$，然後透過累乘或對數累加完成運算。這種向量化思維能將 Python 的執行速度提升 100 倍以上。\n\n#### 3.4 資深從業人員行動清單 (Action Items)\n執行路徑模擬前，必須確認：\n- **離散化誤差稽核**：確保 $\\Delta t$ 足夠小以精確捕捉路障觸碰或平均價格變動。\n- **漂移項校準**：針對定價目的，必須將 $\\mu$ 替換為風險中性利率 $r$。\n- **收斂性驗證**：檢查隨機路徑的中位數與均值是否符合對數正態分佈的理論特性。",
      "3.5": "### 3.5 具有相關性的股價模擬：Cholesky 分解技術\n在現代投資組合風險管理中，資產間的聯動性（Correlation）是決定系統性風險的關鍵。我們不能獨立模擬每一隻股票，而必須生成具有特定相關結構的多維路徑。**Cholesky 分解** 是實現這一目標的標準線性代數工具。\n\n#### 技術核心：從獨立到相關\n假設我們有獨立標準正態隨機向量 $\\mathbf{\\epsilon} \\sim N(0, \\mathbf{I})$ 與目標相關係數矩陣 $\\mathbf{R}$。我們的目標是找到一個矩陣 $\\mathbf{L}$，使得 $\\mathbf{X} = \\mathbf{L} \\mathbf{\\epsilon}$ 的相關結構恰好為 $\\mathbf{R}$：\n\n$$\n\\$$\n\\begin{aligned}\n  \\mathbf{R} &= \\text{Corr}(\\mathbf{X}) = E[(\\mathbf{L}\\mathbf{\\epsilon})(\\mathbf{L}\\mathbf{\\epsilon})^T] \\\n  \\mathbf{R} &= \\mathbf{L} E[\\mathbf{\\epsilon}\\mathbf{\\epsilon}^T] \\mathbf{L}^T = \\mathbf{L} \\mathbf{I} \\mathbf{L}^T \\\n  \\mathbf{R} &= \\mathbf{L} \\mathbf{L}^T\n\\end{aligned}\n$$\n$$\n\n#### 專家決策矩陣：相關性矩陣的數值特徵\n資深計量人員必須識別 $\\mathbf{R}$ 的數學邊界：\n\n| 特徵指標 | 專業要求 | 失敗後果 |\n| :--- | :--- | :--- |\n| **半正定性 (PSD)** | 矩陣所有特徵值必須 $\\ge 0$ | Cholesky 分解將失敗，程序報錯 |\n| **對稱性** | $\\rho_{ij} = \\rho_{ji}$ | 模型邏輯出現基礎物理衝突 |\n| **相關係數範圍** | $|\\rho| \\le 1$ | 數學上不存在該類資產聯動結構 |\n\n> [!IMPORTANT]\n> 在 **NumPy** 實作中（見 `B2_Ch3_4.py`），使用 `np.linalg.cholesky(matrix)` 是標準做法。若遇到矩陣因估計誤差而非半正定的情況，資深分析師應採用「最近鄰相關矩陣 (Nearist Correlation Matrix)」算法修復後再行分解。\n\n#### 3.5 資深從業人員行動清單 (Action Items)\n執行多資產模擬前，必須落實：\n- **矩陣合法性檢定**：檢測相關性矩陣的行列式與特徵值，確保其具備分解的前提。\n- **誤差回饋測試**：模擬生成後，計算樣本相關係數 $\\hat{\\mathbf{R}}$ 並與目標 $\\mathbf{R}$ 比對，確保誤差在收斂範圍內。\n- **維度匹配審查**：確保 Cholesky 下三角矩陣的維度與隨機向量 $N \\times M$ 的資產數量完全一致。",
      "3.6": "### 3.6 歐式選擇權定價實務：風險中性期望值的數值解\n歐式選擇權定價是蒙地卡羅法最經典的金融應用。當解析解（Black-Scholes）受限或模型分佈偏離正態時，我們透過模擬大量到期時點的資產價格，計算其獲利期望值並進行無風險折現，獲取期權的公允價值。\n\n#### 專家定義：定價演算流程\n蒙地卡羅定價的核心公式如下，它本質上是對風險中性測度下獲利函數的積分：\n\n$$\n  C = e^{-rT} \\frac{1}{N} \\sum_{i=1}^N \\max(S_{T,i} - K, 0)\n$$\n\n#### 決策矩陣：蒙地卡羅 vs. Black-Scholes Formula\n資深計量人員應明確何時放棄解析解而選擇模擬法：\n\n| 維度 | Black-Scholes (解析解) | 蒙地卡羅定價 (MC) |\n| :--- | :--- | :--- |\n| **執行速度** | 近乎瞬時 | 較慢，隨 $N$ 增加而增加 |\n| **參數靈活性** | 僅限常數波動率與正態分佈 | **無限**：支援 GARCH、跳躍過程、肥尾分佈 |\n| **計算精準度** | 理論上的精確解 | 存在統計抽樣誤差（標準差 $\\propto 1/\\sqrt{N}$） |\n| **衍生性指標** | 提供解析希臘字母 (Greek Letters) | 需透過微小擾動法 (Bumping) 數值求解 |\n\n> [!IMPORTANT]\n> 在生產系統中（見 `B2_Ch3_7.py`），資深開發者會使用 `np.maximum(S_T - K, 0)` 進行向量化獲利計算。必須嚴格區分「真實收益率 $\\mu$」與「定價收益率 $r$」；在定價模擬中，資產的漂移項必須強制等於無風險利率，否則將導致定價不符合無套利原則。\n\n#### 3.6 資深從業人員行動清單 (Action Items)\n執行期權定價模擬前，必須確認：\n- **風險中性校準**：確保模擬公式中的漂移項已扣除風險溢價，僅保留無風險利率 $r$。\n- **誤差區間揭露**：計算模擬結果的 95% 置信區間 $[\\hat{C} - 1.96 \\frac{\\sigma_{payoff}}{\\sqrt{N}}, \\hat{C} + 1.96 \\frac{\\sigma_{payoff}}{\\sqrt{N}}]$。\n- **基準測試 (Benchmarking)**：對於標準歐式期權，優先與 BS 公式比對，確保模擬器基礎邏輯正確無誤。",
      "3.7": "### 3.7 亞式選擇權 (Asian Options) 與路徑依賴：蒙地卡羅的優勢區間\n亞式選擇權（Asian Options）的獲利取決於合約期內資產價格的「平均值」，而非單一到期價。由於路徑平均值的分佈極其複雜（對數正態分佈之和並不服從對數正態分佈），蒙地卡羅法幾乎是處理此類路徑相依產品唯一的工業級解法。\n\n#### 專家定義：算術平均與幾何平均\n資深從業人員必須識別不同的平均值定義對期權價值與對沖難度的影響：\n- **算術平均 (Arithmetic Average)**：$\\bar{S} = \\frac{1}{m} \\sum_{j=1}^m S_{t_j}$。無解析解，必須依賴模擬。\n- **幾何平均 (Geometric Average)**：$\\bar{S} = (\\prod_{j=1}^m S_{t_j})^{1/m}$。具備解析解，常用於當作算術平均模擬的「控制變量」以縮減變異數。\n\n#### 決策矩陣：歐式 vs. 亞式選擇權的風險特性\n在結構性產品設計中，兩者的角色完全不同：\n\n| 特性 | 歐式選擇權 (European) | 亞式選擇權 (Asian) |\n| :--- | :--- | :--- |\n| **獲利依賴** | 僅依賴最終點 $S_T$ | 依賴整條觀察路徑 $\\{S_{t_i}\\}$ |\n| **波動率敏感度 (Vega)** | 較高 | **較低**：因平均化過程平滑了極端波動 |\n| **抗操縱性** | 容易受「拉尾盤」等市場操縱影響 | **極高**：即使單日價格異常，對整體平均影響有限 |\n| **權利金成本** | 較貴 | 較便宜（因波動率被折減） |\n\n> [!TIP]\n> 在 Python 實作中（見 `B2_Ch3_9.py`），我們利用 `np.mean(axis=1)` 直接獲取每條模擬路徑的平均價格。亞式期權是企業避險的首選，因為它能更精確地匹配企業在一段時間內的平均採購成本或銷售收益。\n\n#### 3.7 資深從業人員行動清單 (Action Items)\n執行亞式期權定價前，必須確認：\n- **觀察頻率匹配**：確認是每日、每週還是每月取樣。取樣點的疏密會顯著影響平均價格與最終價值。\n- **對偶變量法部署**：由於路徑依賴產品模擬較慢，必須使用對偶變量 (Antithetic Variates) 來加速收斂。\n- **終端分佈審計**：監控模擬生成的平均值分佈，確保其峰度與偏度符合特定路徑特徵。",
      "3.8": "### 3.8 馬可夫鏈蒙地卡羅 (MCMC) 抽樣：破解高維複雜分佈\n馬可夫鏈蒙地卡羅 (MCMC) 是處理非標準、非解析統計分佈的頂級技術。當我們無法直接從目標分佈 $P(x)$ 抽樣時，我們構造一個馬可夫鏈，使其穩態分佈（Stationary Distribution）恰好為 $P(x)$。這在貝葉斯風險建模與隱含參數估計中具有統治地位。\n\n#### 技術核心：Metropolis-Hastings 演算法\nMCMC 的核心在於「接受-拒絕」邏輯。給定當前狀態 $x_t$ 與提議分佈 (Proposal Distribution) $g(x'|x_t)$，接受新狀態 $x'$ 的機率為：\n\n$$\n  A(x', x_t) = \\min\\left(1, \\frac{P(x')g(x_t|x')}{P(x_t)g(x'|x_t)}\\right)\n$$\n\n#### 專家決策矩陣：MCMC 抽樣的性能權衡\n資深從業人員必須識別算法在收斂性與效率之間的衝突：\n\n| 觀測指標 | 理想狀態 | 故障特徵 (Bad Convergence) |\n| :--- | :--- | :--- |\n| **接受率 (Acceptance Rate)** | 20% - 40% 為佳 | 過高（移動太細碎）或過低（原地踏步） |\n| **燃燒期 (Burn-in)** | 樣本迅速進入高機率密度區域 | 長時間徘徊於低機率區域，初始點依賴強 |\n| **自相關性** | 樣本間具備獨立性 | 樣本高度相關 (Sticky)，無法完整覆蓋狀態空間 |\n| **跡線圖 (Trace Plot)** | 呈現「毛毛蟲」狀隨機震盪 | 呈現顯著趨勢或階梯狀跳動 |\n\n> [!IMPORTANT]\n> 在 **Python** 定義 MCMC 抽樣器時（見 `B2_Ch3_10.py`），資深分析師會同時執行多條獨立的鏈 (Parallel Chains) 並計算 Gelman-Rubin 指標 ($R$-hat)。若 $R$-hat 顯著大於 1.1，代表模擬尚未收斂，絕對禁止提取樣本進行後續的 VaR 或預期損失計算。\n\n#### 3.8 資深從業人員行動清單 (Action Items)\n啟動 MCMC 模擬前，必須落實：\n- **燃燒期過濾**：捨棄初始 10% - 20% 的样本點，消除隨機初始化的干擾。\n- **變量稀釋 (Thinning)**：若樣本自相關度過高，每隔 $k$ 個點取一個樣本以提升獨立性。\n- **提議分佈校準**：針對不同資產類別動態調整提議分布的方差 $\\sigma_{pro}$，確保接受率處於甜點位 (Sweet Spot)。\n\n#### 核心技術結論\nMCMC 讓「無法解析」變成了「可以模擬」。它將高山峻嶺般的複雜分佈轉化為一步步踏實的隨機漫步，是現代高級定價與風險計量模型的數學動能引擎。"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "3.1 實作基礎數值積分，演示隨機模擬與視覺化。",
        "filename": "B2_Ch3_1.py",
        "code": "# B2_Ch3_1.py\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN = 20\nl, h = 0., 5.\ndef func(x): return x**4 + x**3 + x**2\nx = np.linspace(l, h, N)\nfvalue = func(x) \narea = fvalue * (h - l)/N \nintgr = sum(area)\nprint(\"Result: \", round(intgr))\nplt.plot(x, func(x), color='r')\nplt.show()\n"
      },
      {
        "id": "ex2",
        "title": "3.2 [核心] 實作定積分的蒙地卡羅估算，分析收斂精度。",
        "filename": "B2_Ch3_2.py",
        "code": "# B2_Ch3_2.py\nimport numpy as np\nMC_num = 1000\n# --- added by limit_simulations.py: apply cap 1000\n__SIM_CAP = 1000\ntry:\n    if MC_num > __SIM_CAP:\n        print('Reducing MC_num from', MC_num, 'to', __SIM_CAP, 'to avoid heavy computation.')\n        MC_num = __SIM_CAP\nexcept Exception:\n    pass\n\nl, h = 0., 5.\ndef func(x): return x**4 + x**3 + x**2\nx_rand = np.random.uniform(l, h, MC_num)\nf_vals = func(x_rand)\nintgr = (h - l) * np.mean(f_vals)\nprint(\"MC Result: \", round(intgr))"
      },
      {
        "id": "ex3",
        "title": "3.3 演示隨機數生成在估算機率分佈中的應用。",
        "filename": "B2_Ch3_3.py",
        "code": "# B2_Ch3_3.py\n# Demonstration of random number generation applications.\n"
      },
      {
        "id": "ex4",
        "title": "3.4 [核心] 利用 Cholesky 分解實作具有相關性的多資產路徑模擬。",
        "filename": "B2_Ch3_4.py",
        "code": "# B2_Ch3_4.py snippets\nimport numpy as np\n# Cholesky example\ncorr_matrix = np.array([[1.0, 0.6], [0.6, 1.0]])\nL = np.linalg.cholesky(corr_matrix)\nz = np.random.normal(size=(2, 1000))\ncorrelated_z = L @ z\nprint(f\"Correlation of simulated paths: {np.corrcoef(correlated_z)[0,1]:.2f}\")\n"
      },
      {
        "id": "ex5",
        "title": "3.5 使用 Seaborn 統計圖表展示模擬路徑的分佈邊界。",
        "filename": "B2_Ch3_5.py",
        "code": "# B2_Ch3_5.py\n# Using Seaborn to visualize distribution boundaries.\n"
      },
      {
        "id": "ex6",
        "title": "3.6 實作 SciPy 在風險計量模型中的進階應用與參數評估。",
        "filename": "B2_Ch3_6.py",
        "code": "# B2_Ch3_6.py\n# Advanced application of SciPy in risk metrics.\n"
      },
      {
        "id": "ex7",
        "title": "3.7 演示歐式選擇權的多路徑定價與預測分布.",
        "filename": "B2_Ch3_7.py",
        "code": "# B2_Ch3_7.py\n# Multi-path pricing for European options.\n"
      },
      {
        "id": "ex8",
        "title": "3.8 視覺化路徑模擬結果，分析不同波動率水平下的收斂特徵。",
        "filename": "B2_Ch3_8.py",
        "code": "# B2_Ch3_8.py\n# Visualization of path simulation convergence.\n"
      },
      {
        "id": "ex9",
        "title": "3.9 [核心] 定義亞式選擇權定價函數，實作路徑平均價格計算。",
        "filename": "B2_Ch3_9.py",
        "code": "# B2_Ch3_9.py snippet\nimport numpy as np\n# Asian option payoff calculation\nprices = np.array([100, 102, 101, 105, 108])\nK = 100\npayoff = max(np.mean(prices) - K, 0)\nprint(f\"Asian Payoff: {payoff:.2f}\")\n"
      },
      {
        "id": "ex10",
        "title": "3.10 實作 MCMC (Metropolis-Hastings) 抽樣，求解複雜的分佈期望值。",
        "filename": "B2_Ch3_10.py",
        "code": "# B2_Ch3_10.py\n\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B2_Ch3_10_A.py \nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.stats as stats\nimport matplotlib as mpl\n\nnp.random.seed(66)\n\ndef target_dist(likelihood, prior_dist, n, k, theta):\n    if theta < 0 or theta > 1:\n        return 0\n    else:\n        return likelihood(n, theta).pmf(k)*prior_dist.pdf(theta)\n\n\nlikelihood = stats.binom\nalpha = 20\nbeta = 20\nprior = stats.beta(alpha, beta)\nn = 100\nk = 70\n\nsigma = 0.2\ntheta = 0.3\naccept_num = 0\nMC_num = 50000\n# --- added by limit_simulations.py: apply cap 1000\n__SIM_CAP = 1000\ntry:\n    if MC_num > __SIM_CAP:\n        print('Reducing MC_num from', MC_num, 'to', __SIM_CAP, 'to avoid heavy computation.')\n        MC_num = __SIM_CAP\nexcept Exception:\n    pass\n\n\nsamples = np.zeros(MC_num+1)\nsamples[0] = theta\nfor i in range(MC_num):\n    theta_p = theta + stats.norm(0, sigma).rvs()\n    rho = min(1, target_dist(likelihood, prior, n, k, theta_p)/target_dist(likelihood, prior, n, k, theta))\n    # acceptation or rejection\n    u = np.random.uniform()\n    if rho > u:\n        accept_num += 1\n        theta = theta_p\n    samples[i+1] = theta\n\n# true posterior distribution\npost = stats.beta(k+alpha, n-k+beta)\nthetas = np.linspace(0, 1, 200)\n\n# assume markov chain stationary after half MC simulation number\nn_stationary = len(samples)//2\n\n# visualization\nmpl.style.use('ggplot')\nplt.figure(figsize=(14, 8))\nplt.hist(prior.rvs(n_stationary), 50, histtype='step', density=True, linewidth=1, label='Prior distribution')\nplt.hist(samples[n_stationary:], 50, histtype='step', density=True, linewidth=1, label='Target/Posterior distribution')\nplt.plot(thetas, post.pdf(thetas), c='red', linestyle='--', alpha=0.5, label='True posterior distribution')\nplt.xlim([0,1])\nplt.legend(loc='best')\n\n\n\n# B2_Ch3_10_B.py \n# MCMC: Metropolis-Hastings algorithm\ndef MCMC_MH(MC_num, n, k, theta, likelihood, prior_dist, sigma):\n    samples = [theta]\n    while len(samples) < MC_num:\n        theta_p = theta + stats.norm(0, sigma).rvs()\n        rho = min(1, target_dist(likelihood, prior_dist, n, k, theta_p)/target_dist(likelihood, prior_dist, n, k, theta ))\n        u = np.random.uniform()\n        if rho > u:\n            theta = theta_p\n        samples.append(theta)\n    return samples\n\n# parameters\nalpha = 20\nbeta = 20\nprior = stats.beta(alpha, beta)\nn = 100\nk = 70\nlikelihood = stats.binom\nsigma = 0.2\nMC_num = 40\n# --- added by limit_simulations.py: apply cap 1000\n__SIM_CAP = 1000\ntry:\n    if MC_num > __SIM_CAP:\n        print('Reducing MC_num from', MC_num, 'to', __SIM_CAP, 'to avoid heavy computation.')\n        MC_num = __SIM_CAP\nexcept Exception:\n    pass\n\n\nsample_list = [MCMC_MH(MC_num, n, k, theta, likelihood, prior, sigma) for theta in np.arange(0.1, 1, 0.2)]\n\n# Convergence of multiple chains\nfor sample in sample_list:\n    plt.plot(sample, '-o', markersize=8)\nplt.xlim([0, MC_num])\nplt.ylim([0, 1]);\nplt.xlabel('Monte Carlo simulation number')\nplt.ylabel('Probability')"
      }
    ]
  }
}