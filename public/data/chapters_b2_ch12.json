{
  "id": "b2_ch12",
  "title": "第12章：投資組合理論Ⅱ",
  "number": 12,
  "content": {
    "intro": {
      "title": "第 12 章：投資組合理論 II - 重點詳解 (Detail)",
      "roadmap": {
        "guide": "本章引入了「無風險資產」的概念，並將馬可維茨模型推廣至資本配置線（CAL）與證券市場線（SML）。核心目標是幫助投資者在具備個人風險偏好的情況下，找到最優的配置。",
        "objectives": "*   掌握資本配置線 (CAL) 的斜率（夏普比率 Sharpe Ratio）及其意義。\n*   掌握切點投資組合 (Tangency Portfolio) 的數學求解。\n*   理解如何結合個人的風險厭惡係數 $A$ 與無差別曲線尋找最優效用點。\n*   理解 CAPM 模型中系統性風險 ($\\beta$) 與預期報酬的線性關係。",
        "topics": "*   12.1 包含無風險產品的投資組合 (Risk-free Asset)\n*   12.2 最佳風險投資組合 (Optimal Risky Portfolio) 及實例分析\n*   12.3 無差別效用曲線 (Indifference Utility Curves)\n*   12.4 最佳完全投資組合 (Optimal Complete Portfolio) 實例分析\n*   12.5 資產定價理論 (Asset Pricing Theory) 與 CAPM 模型"
      },
      "value": {
        "practical": "*   **實務場景**：根據客戶的風險厭惡程度，決定在指數基金與國債之間的資金分配比例。\n*   **考試重點**：掌握分離定理（Separation Theorem）：資產配置決策可以分為「找尋最佳風險組合」與「根據心理偏好分配權重」兩個獨立步驟。",
        "theory": "夏普比率最高的點即為「最佳風險投資組合」。效用函數 $U = E(R) - \\frac{1}{2} A \\sigma^2$ 決定了最終的資產配比。CAPM 則將焦點轉向系統性風險 $\\beta$。",
        "further_reading": "*   Sharpe (1964) 經典文獻。"
      },
      "implementation": {
        "python": "*   **組建模擬**：實作均值-變異數模型，求解最佳風險投資組合與夏普比率。\n*   **效用曲線**：視覺化呈現無差別效用曲線與 CAL 線的切點。\n*   **Beta 估計**：計算資產與市場回報的協方差以確系統性風險。",
        "logic": "*   分離定理：最佳化與偏好分配的分離。\n*   CAPM：單因子風險定價。 ",
        "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B2_Ch12_1.py** | **[核心]** 實作馬可維茨 (Markowitz) 均值-變異數模型，求解最佳投資組合。 |\n| **B2_Ch12_2.py** | 利用 QP 求解器分析不同預期收益率下的組合風險最小化與 CAL 線。 |\n| **B2_Ch12_3.py** | **[進階]** 實作多維資產權重分配與風險邊際貢獻分析。 |\n| **B2_Ch12_4.py** | **[理論]** 計算資產貝塔係數 (Beta) 與系統性風險，演示 CAPM 模型基礎應用。 |"
      }
    },
    "body": {
      "12.1": "### 12.1 包含無風險產品的投資組合：資本配置的起點\n當我們在投資組合中引入**無風險資產 (Risk-free Asset)**（如 國債）時，投資者的可行集從馬可維茨的「有效前緣曲線」擴展到了連帶著無風險收益率與風險資產組合的「射線」。這條射線被稱為**資本配置線 (Capital Allocation Line, CAL)**。資深從業人員將此視為資產配置決策的第一步：將資金在無風險與風險資產間進行初級分配。\n\n#### 技術核心：CAL 的數學定義\n給定預期收益率 $E(R_p)$ 與波動率 $\\sigma_p$，CAL 的方程定義如下：\n\n$$\n  E(R_{complete}) = R_f + \\left( \\frac{E(R_i) - R_f}{\\sigma_i} \\right) \\sigma_{complete}\n$$\n\n其中括號內的項即為夏普比率 (Sharpe Ratio)。\n\n#### 專家決策矩陣：夏普比率與組合效率\n夏普比率衡量的是每承擔一單位風險所獲得的超額收益 (Excess Return)：\n\n| 指標情況 | 財務含義 | 決策行動 |\n| :--- | :--- | :--- |\n| **夏普比率高** | 同樣風險下回報更高 | **優選**：此資產或組合具備更高的配置效率 |\n| **夏普比率負** | 回報低於無風險利率 | **拒絕**：無配置價值，除非作為特殊的負相關對沖項 |\n| **比率隨時間上升** | 組合盈利能力增強或波動率受控 | 適合增加該槓桿頭寸 |\n\n> [!IMPORTANT]\n> 在 Python 模擬中（見 `B2_Ch12_1.py`），CAL 是從 $R_f$ 點出發與有效前緣相切的直線。資深分析師必須確保 $R_f$ 數據使用了與回報率相同期限的國債收益率（如月回報對應 1 個月 OIS），否則會因「利差錯位」導致夏普比率失真。\n\n#### 12.1 資深從業人員行動清單 (Action Items)\n執行資本配置分析前，必須確認：\n- **無風險利率來源審計**：確認 $R_f$ 是「真正無風險」且具備流動性的，而非包含信用點差的企業債利率。\n- **夏普比率一致性校準**：在對比多個基金或策略時，確保計算期間與數據頻率（日、週、月）完全統一。\n- **槓桿成本考量**：若權重總和 $> 1$，則在計算 CAL 時必須考慮借貸成本可能高於存款利率 (Lending-Borrowing Spread)。",
      "12.2": "### 12.2 最佳風險投資組合 (Optimal Risky Portfolio) 與夏普比率最大化\n**最佳風險投資組合 (ORP)**，又稱切點組合 (Tangency Portfolio)，是有效前緣上具備最高夏普比率的唯一點。它是資本配置線 (CAL) 出發與前緣曲線相切的切點。資深投資顧問的核心工作，就是幫助客戶找到這個「最具性價比」的風險核心，無論客戶是保守還是激進，其風險資產的比例構成都應是這個 ORP（分離定理）。\n\n#### 技術核心：分離定理 (Separation Theorem)\n分離定理指出，投資決策可以分解為兩個互不干擾的步驟：\n1.  **純技術步驟**：尋找最高夏普比率的 ORP。這與投資人的心理偏好無關，純粹由 $\\mu$ 和 $\\Sigma$ 決定。\n2.  **心理偏好步驟**：根據風險厭惡程度，在無風險資產與 ORP 之間分配資金。\n\n#### 專家決策矩陣：切點組合的特性判讀\n資深計量師透過 ORP 的組成來診斷市場情緒：\n\n| 配置特徵 | 市場含義 | 決策回饋 |\n| :--- | :--- | :--- |\n| **權重集中於成長股** | 市場環境利好風險情緒 | 可適度增加槓桿配置 |\n| **權重向債券/防禦金轉移** | 夏普比率最高的點已左移 | 市場進入衰退預期，應執行防禦性轉換 |\n| **切點消失 (無可行解)** | 收益率低於利率或相關性鎖定 | 市場可能進入無套利或持續下行，考慮持有 100% 現金 |\n\n> [!IMPORTANT]\n> 在生產端實作 `Optimization` 時（見 `B2_Ch12_1.py`），我們最大化的目標函數是 $\\frac{\\mathbf{w}^T \\mathbf{\\mu} - R_f}{\\sqrt{\\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}}}$。資深開發者會使用 `scipy.optimize.minimize` 取負值來求極大。若求解出的權重出現極端單一（Corner Solution），需檢查數據是否包含異常值或錄入了相同的相關資產。\n\n#### 12.2 資深從業人員行動清單 (Action Items)\n執行 ORP 求解後，必須落實：\n- **切點邊界校驗**：繪製圖表確認繪出的直線確實與有效前緣相切，無穿透或重疊現象。\n- **參數靈敏度審查 (Estimation Error)**：測試若某些資產的 $\\mu$ 下降 0.5%，ORP 的權重會發生多大的位移。這能衡量模型的穩健性。\n- **動態調倉限額**：設定當前持倉與理論 ORP 的「偏離限額」，決定何时發起自動化的再平衡 (Rebalancing) 操作。",
      "12.3": "### 12.3 無差別效用曲線 (Indifference Utility Curves)：心理風險的數學量化\n資產配置的最終步驟是將「客觀模型」與「主觀偏好」結合。**效用函數 (Utility Function)** 將投資者對收益的喜好與對風險的痛苦感進行權衡。**無差別曲線 (Indifference Curve)** 則是效用相等（滿意度相同）的所有風險回報組合。資深理財經理透過識別客戶的風險厭惡係數 $A$ 來決定最終的「最佳完全組合」。\n\n#### 技術核心：效用函數公式\n在均值-方差框架下，標準效用函數如下：\n\n$$\n  U = E(R_p) - \\frac{1}{2} A \\sigma_p^2\n$$\n\n- $A > 0$: 風險厭惡者（數值越大越保守）。\n- $A = 0$: 風險中性者（僅看收益）。\n- $A < 0$: 風險愛好者（享受波動）。\n\n#### 專家決策矩陣：不同風險厭惡係數下之配置策略\n資深顧問依據 $A$ 值進行資產類別指引：\n\n| 厭惡係數 ($A$) | 客戶類型 | 配置建議 |\n| :--- | :--- | :--- |\n| **$2 \\sim 4$** | **激進型** | 高比例配置於 ORP，甚至使用槓桿 (Margin) 擴大收益 |\n| **$5 \\sim 10$** | **穩健型** | 平衡配置，風險與無風險資產各佔一部分 |\n| **$> 20$** | **極端保守型** | 配置 90%+ 於收息產品或現金，僅獲取極少風險溢價 |\n\n> [!IMPORTANT]\n> 在三維視覺化中（見 `B2_Ch12_3.py`），效用曲線是向上開口的拋物線。最佳配置點出現在效用曲線與資本配置線 (CAL) 的「切點」上。資深開發者會使用 $A$ 作為參數動態調整曲面，這能直觀展示為何在相同市場環境下，不同人會選擇不同的權重方案。\n\n#### 12.3 資深從業人員行動清單 (Action Items)\n分析客戶效用時，必須落實：\n- **壓力情境下的 $A$ 值校準**：投資者在牛市中自認為激進 ($A=2$)，但在熊市中往往變為保守 ($A=15$)。應取多個場景下的平均係數。\n- **效用損益感應度分析**：量化若收益率下降 1%，需要多少的風險降低才能維持相同的客戶滿意度。\n- **策略透明度溝通**：向客戶展示其效用切點與有效前緣的距離，確認配置是否位於最優效率邊界上。",
      "12.4": "### 12.4 最佳完全投資組合 (Optimal Complete Portfolio) 實例分析\n當投資者確定了「最佳風險投資組合 (ORP)」後，最後的挑戰是根據其個人效用函數，在無風險資產與 ORP 之間做出最終選擇。這被稱為構建**最佳完全投資組合 (Optimal Complete Portfolio)**。資深投資顧問將這一過程視為「個性化配置」與「市場效率」的精準對接。\n\n#### 技術核心：最佳風險資產配置比例 $y^*$\n假設 ORP 的預期回報為 $E(R_p)$、風險為 $\\sigma_p^2$，投資人的風險厭惡係數為 $A$，則分配給 ORP 的最佳比例 $y$ 為：\n\n$$\n  y^* = \\frac{E(R_p) - R_f}{A \\sigma_p^2}\n$$\n\n#### 專家決策矩陣：配置比例 $y^*$ 的極端情境分析\n資深分析師需向客戶解釋 $y^*$ 數值的現實意義：\n\n| $y^*$ 數值 | 投資狀態 | 配置含義 |\n| :--- | :--- | :--- |\n| **$y^* = 0$** | **極致保守** | 全部資金存放於無風險資產，不參與任何市場博弈 |\n| **$y^* = 1$** | **純粹風險** | 恰好 100% 投資於 ORP，不保留現金準備 |\n| **$y^* > 1$** | **槓桿投資** | 透過融資、融券或其他槓桿工具，擴大風險資產權重以滿足高效用追求 |\n| **$0 < y^* < 1$** | **混合配置** | 在現金與多樣化組合間保持平衡，多數穩健投資者的常態 |\n\n> [!IMPORTANT]\n> 在生產端演算法中（見 `B2_Ch12_1.py` 的後段邏輯），資深開發者會對 $y^*$ 進行「合規性蓋帽」。即便數學計算得出 $y^* = 2.5$，若公司政策限制最高槓桿為 1.5 倍，則最終執行比例必須強制下調至 1.5。此時，理論效用將被迫下降，這是風控對模型的必要制約。\n\n#### 12.4 資深從業人員行動清單 (Action Items)\n執行完全配置前，必須確認：\n- **資金流動性匹配**：確保分配給「無風險資產」的部分具備即時變現能力，以應對風險部分可能的意外損失。\n- **保證金成本 (Margin Cost) 校準**：針對 $y^* > 1$ 的情況，必須將融資利率與 $R_f$ 的差額計入成本，防止過度樂觀估算收益。\n- **心理承受力壓力測試**：向客戶展示在未來 1 年內，該完全組合可能發生的最大回撤 (Max Drawdown)，確認其與係數 $A$ 的真實心理匹配度。",
      "12.5": "### 12.5 資產定價理論 (Asset Pricing Theory) 與 CAPM 模型\n**資本資產定價模型 (CAPM)** 由 William Sharpe 提出，它定義了在一般均衡市場中，資產預期收益率與其**系統性風險 (Systematic Risk)** 之間的精確線性關係。CAPM 宣告：投資者不因承擔「可分散風險」獲得補償，僅因承擔「不可分散風險」（即市場風險 $\\beta$）獲取風險溢價。這是現代證券估值與資本成本計算的底層協議。\n\n#### 技術核心：證券市場線 (SML)\n任何資產 $i$ 的回報率應遵循以下線性映射：\n\n$$\n  E(R_i) = R_f + \\beta_i [E(R_m) - R_f]\n$$\n\n其中貝塔係數 $\\beta$ 是資產對市場超額收益的敏感度：\n\n$$\n  \\beta_i = \\frac{\\text{Cov}(R_i, R_m)}{\\text{Var}(R_m)}\n$$\n\n#### 專家決策矩陣：Beta 的風險含義判讀\n資深分析師根據 $\\beta$ 指標執行主動或被動投資策略：\n\n| Beta 數值 | 市場屬性 | 決策行動 |\n| :--- | :--- | :--- |\n| **$\\beta = 1$** | 與市場波动一致 | **被動配置**：適合構建指數基金 (Index Funds) |\n| **$\\beta > 1$** | **高貝塔資產**（攻擊型） | 牛市首選：獲取超額彈性收益，但熊市跌幅更大 |\n| **$\\beta < 1$** | **低貝塔資產**（防禦型） | 熊市首選：如公用事業，具備價值抗跌屬性 |\n| **$\\beta < 0$** | 反市場資產 | **罕見但珍貴**：如黃金或特定期權策略，是極佳的避險工具 |\n\n> [!IMPORTANT]\n> 在生產端實作 `CAPM` 參數估算時（見 `B2_Ch12_4.py`），資深開發者會使用 `stats.linregress` 提取係數。必須注意截距 $\\alpha$。若 $\\alpha$ 顯著大於零，代表該資產存在市場未定價的「超額回報」，這是阿爾法策略尋找的核心標的。\n\n#### 12.5 資深從業人員行動清單 (Action Items)\n執行 CAPM 定價分析前，必須確認：\n- **市場基準 (Benchmark) 選型**：確保使用的市場收益率 $R_m$ 與投資資產類別匹配（如美股用 S&P500，台股用加權指數）。\n- **預期溢價審查**：確認 $[E(R_m) - R_f]$ 的數值基於長期歷史回報，而非短期市場極端波動期，防止定價失真。\n- **Beta 穩定性測試**：利用滾動回測檢查貝塔係數的穩定性。若 $\\beta$ 隨時間劇烈偏移，則 CAPM 的預測價值將大幅下降。\n\n#### 核心技術結論\n投資組合理論Ⅱ將量化對象從資產延伸到了投資人的「心智」。透過 CAL 的比例分配與 CAPM 的風險定價，資深從業人員構建了一套整合了市場物理規律與人類風險偏好的全局性決策框架，這是通往資深組合經理的必經之路。"
    },
    "examples": [
      {
        "id": "ex1",
        "title": "12.1 馬可維茨均值-變異數模型",
        "filename": "B2_Ch12_1.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n\nfrom numpy import array, sqrt, dot, linspace, ones, zeros, size, append\nfrom pandas import read_excel, DataFrame\nfrom numpy.linalg import inv\n\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Define Risk Free asset\nRF = 0.02\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\nax.scatter(0,RF,color=\"red\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nCalMat = ones((size(Singlename_Mean)+1,size(Singlename_Mean)+1))\nCalMat[0:-1,0:-1] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-1,-1] = - CalMat[0:-1,-1]\nCalMat[-1,-1] = 0.0\n\nVec1 = zeros((size(Singlename_Mean)+1))\nVec1[-1] = 1\n\nSolutionVec1 = dot(inv(CalMat),Vec1)\n\nWeight_GMVP = SolutionVec1[0:-1]\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.30\nCalMat = ones((size(Singlename_Mean)+2,size(Singlename_Mean)+2))\nCalMat[0:-2,0:-2] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-2,-2] = - CalMat[0:-2,-2]\nCalMat[0:-2,-1] = - Singlename_Mean.to_numpy()\nCalMat[-1,0:-2] = Singlename_Mean.to_numpy()\nCalMat[-2:,-2:] = zeros((2,2))\n\nVec2 = zeros((size(Singlename_Mean)+2))\nVec2[-2] = 1\nVec2[-1] = Port_Return\n\nSolutionVec2 = dot(inv(CalMat),Vec2)\n\nWeight_MVP = SolutionVec2[0:-2]\n\n#%% Efficient Frontier\n\nCalMat = ones((size(Singlename_Mean)+2,size(Singlename_Mean)+2))\nCalMat[0:-2,0:-2] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-2,-2] = - CalMat[0:-2,-2]\nCalMat[0:-2,-1] = - Singlename_Mean.to_numpy()\nCalMat[-1,0:-2] = Singlename_Mean.to_numpy()\nCalMat[-2:,-2:] = zeros((2,2))\nVec2 = zeros((size(Singlename_Mean)+2))\nVec2[-2] = 1\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,0.3, num=25)\n\nfor Rp in Rp_range:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(0.0,Port_Return_GMVP, num=10)\n\nfor Rp in Rp_range_inEF:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(0.0,0.3, num=100)\n\nfor Rp in Rp_range_Hcurve:    \n    Vec2[-1] = Rp    \n    SolutionVec2 = dot(inv(CalMat),Vec2)\n    \n    Weight_MVP = SolutionVec2[0:-2]\n    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% Optimal Risky portfolio\nEr_initial = 0.15\nCalMat = zeros((size(Singlename_Mean)+1,size(Singlename_Mean)+1))\nCalMat[0:-1,0:-1] = 2*CovarianceMatrix.to_numpy()\nCalMat[0:-1,-1] = -(Singlename_Mean.to_numpy()-RF)\nCalMat[-1,0:-1] = Singlename_Mean.to_numpy()-RF\n\nVec3 = zeros((size(Singlename_Mean)+1))\nVec3[-1] = Er_initial-RF\n\nSolutionVec3 = dot(inv(CalMat),Vec3)\n\nWeight_ORP = SolutionVec3[0:-1]/sum(SolutionVec3[0:-1])\n\nPort_Vol_ORP = sqrt(dot(dot(Weight_ORP,CovarianceMatrix.to_numpy()),Weight_ORP))\nPort_Return_ORP = dot(Weight_ORP,Singlename_Mean.to_numpy())\n\nSR = (Port_Return_ORP-RF)/Port_Vol_ORP\n\n#%% bar chart ORP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation',ylabel='Names')\n\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='x')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.scatter(0,RF,color=\"red\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D')\nax.plot([0,Port_Vol_ORP],[RF,Port_Return_ORP])\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n\n\n\n\n\n"
      },
      {
        "id": "ex2",
        "title": "12.2 範例程式",
        "filename": "B2_Ch12_2.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, append, zeros_like, ones_like\nfrom pandas import read_excel, DataFrame\nfrom qpsolvers import solve_qp\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Define Risk Free asset\nRF = 0.02\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\nax.scatter(0,RF,color=\"red\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nWeight_GMVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    None,None,\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.30\nWeight_MVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean), \n    None,None,\n    array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n    array([1.,Port_Return]).reshape(2,))\n\nfig,ax=plt.subplots()\ntickers = Singlename_Mean.index.tolist()\nax.barh(tickers,Weight_MVP)\nax.set(xlabel='Weight',ylabel='Names')\n\n\n#%% Efficient Frontier\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,0.3, num=25)\n\nfor Rp in Rp_range:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))\n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(0.0,Port_Return_GMVP, num=10)\n\nfor Rp in Rp_range_inEF:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))    \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(0.001,0.3, num=100)\n\nfor Rp in Rp_range_Hcurve:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        None,None,\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))      \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% Optimal Risky portfolio\nEr_initial = 0.15\nSolution=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    None,None,\n    array([Singlename_Mean.to_numpy()-RF]),\n    array([Er_initial-RF]))\n\nWeight_ORP = Solution/sum(Solution)\n\nPort_Vol_ORP = sqrt(dot(dot(Weight_ORP,CovarianceMatrix.to_numpy()),Weight_ORP))\nPort_Return_ORP = dot(Weight_ORP,Singlename_Mean.to_numpy())\n\nSR = (Port_Return_ORP-RF)/Port_Vol_ORP\n\n#%% bar chart ORP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation',ylabel='Names')\n\n\n#%% Capital Market Line\nvol_range = linspace(0,0.35,100)\nCML = RF + SR*vol_range\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='x')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.scatter(0,RF,color=\"red\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D',color=\"red\")\nax.plot(vol_range,CML)\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% Optimal Indifference Utility Curve 1\nA1 = 3\nU_max_1 = RF + SR**2/(2*A1) \nWeight_P_1 = SR/(A1*Port_Vol_ORP) \n\nR1 = 1/2*A1*(vol_range**2) + U_max_1\n\nE_c1 = RF+SR**2/A1\nVol_c1 = Weight_P_1*Port_Vol_ORP\n\n#%% bar chart OCP1 weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP*Weight_P_1)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation with A = '+ str(A1),ylabel='Names')\n\n#%% Optimal Indifference Utility Curve 2\nA2 = 5\nU_max_2 = RF + SR**2/(2*A2)\nWeight_P_2 = SR/(A2*Port_Vol_ORP) \n\nR2 = 1/2*A2*(vol_range**2) + U_max_2\n\nE_c2 = RF+SR**2/A2\nVol_c2 = Weight_P_2*Port_Vol_ORP\n\n#%% bar chart OCP2 weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP*Weight_P_2)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation with A = '+ str(A2),ylabel='Names')\n\n#%% plot Capital Market Line and Indifference Utility Curves\nfig,ax=plt.subplots()\nax.plot(vol_range,CML)\nax.plot(vol_range,R1,color=\"green\")\nax.plot(vol_range,R2,color=\"green\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D')\n\nax.scatter(Vol_c1,E_c1, marker='*', color=\"purple\")\nax.scatter(Vol_c2,E_c2, marker='*', color=\"purple\")\n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n#%% plot everything\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='x')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.scatter(0,RF,color=\"red\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D')\nax.plot(vol_range,CML)\n\nax.plot(vol_range,R1,color=\"green\")\nax.plot(vol_range,R2,color=\"green\")\n\nax.scatter(Vol_c1,E_c1, marker='*', color=\"purple\")\nax.scatter(Vol_c2,E_c2, marker='*', color=\"purple\")\n\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n"
      },
      {
        "id": "ex3",
        "title": "12.3 範例程式",
        "filename": "B2_Ch12_3.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import array, sqrt, dot, linspace, append, zeros_like, ones_like, size, identity\nfrom pandas import read_excel, DataFrame\nfrom qpsolvers import solve_qp\nimport matplotlib.pyplot as plt \n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_1.xlsx')\n\n#%% Return Vector, Volatility Vector, Variance-Covariance Matrix, Correlation Matrix\nSinglename_Mean = DataFrame.mean(data)*12\nSinglename_Vol = DataFrame.std(data)*sqrt(12)\nCorrelationMatrix = DataFrame.corr(data)\nCovarianceMatrix = DataFrame.cov(data)*12\n\n#%% Define Risk Free asset\nRF = 0.02\n\n#%% Scatter plot\ntickers = Singlename_Mean.index.tolist()\n\nfig,ax=plt.subplots()\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\nax.scatter(0,RF,color=\"red\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')      \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% GMVP portfolio\nWeight_GMVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    ones_like(Singlename_Mean),\n    array([1.]))\n\nPort_Vol_GMVP = sqrt(dot(dot(Weight_GMVP,CovarianceMatrix.to_numpy()),Weight_GMVP))\nPort_Return_GMVP = dot(Weight_GMVP,Singlename_Mean.to_numpy())\n\n#%% bar chart GMVP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_GMVP)\nax.set(xlabel='GMVP Weight Allocation',ylabel='Names')\n\n#%% MVP portfolio, fixed return\nPort_Return = 0.1\nWeight_MVP=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean), \n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n    array([1.,Port_Return]).reshape(2,))\n\n\n#%% Efficient Frontier\n\n# =============================================================================\n# Efficient Frontier\n# =============================================================================\nEF_vol = array([])\n#Rp_range =  linspace(0.07,0.3, num=24)\nRp_range =  linspace(Port_Return_GMVP,max(Singlename_Mean), num=15)\n\nfor Rp in Rp_range:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))\n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    EF_vol = append(EF_vol,array(Port_vol))\n\n# =============================================================================\n# In-efficient\n# =============================================================================\nInEF_vol = array([])\nRp_range_inEF =  linspace(min(Singlename_Mean),Port_Return_GMVP, num=8)\n\nfor Rp in Rp_range_inEF:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))  \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    InEF_vol = append(InEF_vol,array(Port_vol))\n# =============================================================================\n# Hyperbola curve\n# =============================================================================\nHcurve_vol = array([])\nRp_range_Hcurve =  linspace(min(Singlename_Mean),max(Singlename_Mean), num=50)\n\nfor Rp in Rp_range_Hcurve:\n    Weight_MVP=solve_qp(\n        CovarianceMatrix.to_numpy(),\n        zeros_like(Singlename_Mean), \n        -identity(size(Singlename_Mean)),\n        zeros_like(Singlename_Mean),\n        array([ones_like(Singlename_Mean),Singlename_Mean.to_numpy()]),\n        array([1.,Rp]).reshape(2,))  \n    Port_vol = sqrt(dot(dot(Weight_MVP,CovarianceMatrix.to_numpy()),Weight_MVP))\n    Hcurve_vol = append(Hcurve_vol,array(Port_vol))\n\n#%% Optimal Risky portfolio\nEr_initial = 0.05\nSolution=solve_qp(\n    CovarianceMatrix.to_numpy(),\n    zeros_like(Singlename_Mean),\n    -identity(size(Singlename_Mean)),\n    zeros_like(Singlename_Mean),\n    array([Singlename_Mean.to_numpy()-RF]),\n    array([Er_initial-RF]))\n\nWeight_ORP = Solution/sum(Solution)\n\nPort_Vol_ORP = sqrt(dot(dot(Weight_ORP,CovarianceMatrix.to_numpy()),Weight_ORP))\nPort_Return_ORP = dot(Weight_ORP,Singlename_Mean.to_numpy())\n\nSR = (Port_Return_ORP-RF)/Port_Vol_ORP\n\n#%% bar chart ORP weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation',ylabel='Names')\n\n#%% Capital Market Line\nvol_range = linspace(0,0.3,100)\nCML = RF + SR*vol_range\n\n#%% plot Efficient Frontier portfolios\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='x')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.scatter(0,RF,color=\"red\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D',color=\"red\")\nax.plot(vol_range,CML)\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\n\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n\n#%% Optimal Indifference Utility Curve 1\nA1 = 3\nU_max_1 = RF + SR**2/(2*A1) \nWeight_P_1 = SR/(A1*Port_Vol_ORP) \n\nR1 = 1/2*A1*(vol_range**2) + U_max_1\n\nE_c1 = RF+SR**2/A1\nVol_c1 = Weight_P_1*Port_Vol_ORP\n\n#%% bar chart OCP1 weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP*Weight_P_1)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation with A = '+ str(A1),ylabel='Names')\n\n#%% Optimal Indifference Utility Curve 2\nA2 = 5\nU_max_2 = RF + SR**2/(2*A2)\nWeight_P_2 = SR/(A2*Port_Vol_ORP) \n\nR2 = 1/2*A2*(vol_range**2) + U_max_2\n\nE_c2 = RF+SR**2/A2\nVol_c2 = Weight_P_2*Port_Vol_ORP\n\n#%% bar chart OCP2 weight\nfig,ax=plt.subplots()\n\nax.barh(tickers,Weight_ORP*Weight_P_2)\nax.set(xlabel='Optimal Risk Portfolio Weight Allocation with A = '+ str(A2),ylabel='Names')\n\n#%% plot Capital Market Line and Indifference Utility Curves\nfig,ax=plt.subplots()\nax.plot(vol_range,CML)\nax.plot(vol_range,R1,color=\"green\")\nax.plot(vol_range,R2,color=\"green\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D')\n\nax.scatter(Vol_c1,E_c1, marker='*', color=\"purple\")\nax.scatter(Vol_c2,E_c2, marker='*', color=\"purple\")\n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n\n#%% plot everything\nfig,ax=plt.subplots()\nax.plot(Hcurve_vol,Rp_range_Hcurve)\nax.scatter(Port_Vol_GMVP,Port_Return_GMVP, marker='x')\n#ax.scatter(InEF_vol,Rp_range_inEF)\n#ax.scatter(EF_vol,Rp_range)\nax.scatter(0,RF,color=\"red\")\nax.scatter(Port_Vol_ORP,Port_Return_ORP, marker='D')\nax.plot(vol_range,CML)\n\nax.plot(vol_range,R1,color=\"green\")\nax.plot(vol_range,R2,color=\"green\")\n\nax.scatter(Vol_c1,E_c1, marker='*', color=\"purple\")\nax.scatter(Vol_c2,E_c2, marker='*', color=\"purple\")\n\nax.scatter(Singlename_Vol,Singlename_Mean,color=\"blue\")\nfor x_pos, y_pos, label in zip(Singlename_Vol, Singlename_Mean, tickers):\n    ax.annotate(label,             \n                xy=(x_pos, y_pos), \n                xytext=(7, 0),     \n                textcoords='offset points', \n                ha='left',         \n                va='center')  \n\nax.set(xlabel='Portfolio Volatility',ylabel='Portfolio Return')\n"
      },
      {
        "id": "ex4",
        "title": "12.4 貝塔係數與 CAPM 模型基礎",
        "filename": "B2_Ch12_4.py",
        "code": "\n###############\n# Prepared by Ran An, Wei Lu, and Feng Zhang\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 2  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom numpy import sqrt, linspace, corrcoef, zeros\nfrom pandas import read_excel, DataFrame\n\n#%% Read data from excel\ndata = read_excel(r'insert_directory\\Data_portfolio_2.xlsx')\n\n#%% CAPM beta\nMean = DataFrame.mean(data)*12\nVol = DataFrame.std(data)*sqrt(12)\n\nSinglename_Return = data.iloc[:,1:-2]\n\nMktExcess = data.iloc[:,-2]\nRF = data.iloc[:,-1]\n\nSinglename_ExcessReturn = Singlename_Return\n\nn= len(Singlename_Return.columns)\n\nCorrelation_v_Mkt = zeros(n)\n\nfor k in linspace(0,n-1,n):\n    k=int(k)\n    Singlename_ExcessReturn.iloc[:,k] = Singlename_Return.iloc[:,k] - RF\n    Correlation_v_Mkt[k] = corrcoef(Singlename_ExcessReturn.iloc[:,k].to_numpy(),\n                                    MktExcess.to_numpy())[1,0]\n    \n\nVol_Excess = DataFrame.std(Singlename_ExcessReturn)*sqrt(12) \nVol_Mkt = DataFrame.std(MktExcess)*sqrt(12) \n\n\nBeta = zeros(n)\nSys_exp_Vol = zeros(n)\nSys_exp_prct = zeros(n)\n\nfor k in linspace(0,n-1,n):\n    k=int(k)\n    Beta[k] = Correlation_v_Mkt[k]*Vol_Excess[k]/Vol_Mkt\n    Sys_exp_Vol[k] = Beta[k]*Vol_Mkt\n    Sys_exp_prct[k] = Sys_exp_Vol[k]**2/Vol_Excess[k]**2\n\n\n"
      }
    ]
  }
}